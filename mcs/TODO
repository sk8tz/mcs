* Assignment

	string a, b;
	property string c;

	a = c = b = "hello"

	Problem is that setter properties do not return a value, so we must
	create a temporary on the situation above to store the value of "b"
	and then pass that on to "a".

* Optimizations

	Handle if (!x) converting to remove the `!' and instead of using
	a brfalse use a brtrue to jump to the end.

* LValueResolve

	Maybe we should only call Resolve on RValues and LValueRsolve
	on LValues so that DoREsolve can flag errors on properties
	missing `get' and indexers without a get indexer.

* Emitcontext

	Do we really need to instanciate this variable all the time?

	It could be static for all we care, and just use it for making
	sure that there are no recursive invocations on it.

* Static-ization

	Since AppDomain exists, maybe we can get rid of all the stuff
	that is part of the `compiler instance' and just use globals
	everywhere.

* FindMembers

	Move our utility FindMembers from TypeContainer to Decl, because interfaces
	are also scanned with it.

* Ordering

	Can a constant_expression invoke overloaded operators?
	Explicit user-defined conversions?

* Visibility

	I am not reporting errors on visibility yet.

* Enumerations

	Currently I am not resolving enumerations.

	Either I track them with `RecordEnum' as I do with classes,
	structs and interfaces or I rewrite the code to visit type
	containers and `walk' the enums with this process. 

* Known problems:

  Cast expressions

	They should should use:

		OPEN_PARENS type CLOSE_PARENS

	instead of the current production which is wrong, because it
	only handles a few cases.

	Complex casts like:

		Array r = (string []) object

	Wont be parsed.
  
* Interfaces

	For indexers, the output of ix2.cs is different from our
	compiler and theirs.  They use a DefaultMemberAttribute, which
	I have yet to figure out:

	.class interface private abstract auto ansi INTERFACE
	{
		.custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) 
		= ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..
		...
	}

* Interface indexers

	I have not figured out why the Microsoft version puts an
	`instance' attribute, and I am not generating this `instance' attribute.

	Explanation: The reason for the `instance' attribute on
	indexers is that indexers only apply to instances

* Constructors

	Currently it calls the parent constructor before initializing fields.
	It should do it the other way around.

* Use of EmitBranchable

	Currently I use brfalse/brtrue in the code for statements, instead of
	using the EmitBranchable function that lives in Binary

* Create an UnimplementedExpcetion

  	And use that instead of plain Exceptions to flag compiler errors.

* ConvertImplicit

	Currently ConvertImplicit will not catch things like:

	- IntLiteral in a float context to generate a -FloatLiteral.
	Instead it will perform an integer load followed by a conversion.

* In class.cs: Method.Define

	Need to use FindMembers to lookup the member for reporting
	whether a new is needed or not.  

* virtual-method.cs breaks

	It breaks on the call to: new B ();

	Where B is a class defined in the source code, my guess is that
	the look for ".ctor" fails

* Foreach on structure returns does not work

	I am generating invalid code instead of calling ldarga for the
	structure, I am calling ldarg:

	struct X {
		public IEnumerator GetEnumerator ();
	}

	X x;

	foreach (object a in x){
		...
	}

	I need to get the address of that bad boy

* Work todo:

	Understand how methods are invoked on structs

* Using Alias

	Need to reset the aliases for each compilation unit, so an
	alias defined in a file does not have any effect on another one:

	File.cs
	=======
	namespace A {
		using X = Blah;

		class Z : X {           <-- This X is `Blah' 
	}

	File2.cs
	namespace {
		class Y : X {		<-- This X Is not `Blah' 
		}
	}

	I think we can implement Aliases by having an `Alias' context in all
	the toplevel TypeContainers of a compilation unit.  The children typecontainers
	just chain to the parents to resolve the information.

	The driver advances the Alias for each file compiled, so that each file
	has its own alias set.

* Tests

	Write tests for the various reference conversions.  We have
	test for all the numeric conversions.
