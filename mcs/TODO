Dead Code Elimination bugs:
---------------------------

	I should also resolve all the children expressions in Switch, Fixed, Using.

Major tasks:
------------

	Pinned and volatile require type modifiers that can not be encoded
	with Reflection.Emit.

	Properties and 17.6.3: Finish it.

	Implement base indexer access.

readonly variables and ref/out
	
BUGS
----

* Check for Final when overriding, if the parent is Final, then we cant
  allow an override.

* Interface indexers

	I have not figured out why the Microsoft version puts an
	`instance' attribute, and I am not generating this `instance' attribute.

	Explanation: The reason for the `instance' attribute on
	indexers is that indexers only apply to instances

* Arrays

	We need to make sure at *compile time* that the arguments in
	the expression list of an array creation are always positive.

* Indexer bugs:

	the following wont work:

	x [0] = x [1] = N

	if x has indexers, the value of x [N] set is set to void.  This needs to be
	fixed.

* Array declarations

	Multi-dim arrays are declared as [,] instead of [0..,0..]

* Break/Continue statements

	A finally block should reset the InLoop/LoopBegin/LoopEnd, as
	they are logically outside the scope of the loop.

* Break/continue part 2.

	They should transfer control to the finally block if inside a try/catch
	block.

* Method Registration and error CS111

	The way we use the method registration to signal 111 is wrong.
	
	Method registration should only be used to register methodbuilders,
	we need an alternate method of checking for duplicates.

* We need to catch:

	extern string Property {
		get { } 
	}

	The get there should only have a semicolon
	
*
> // CSC sets beforefieldinit
> class X {
>   // .cctor will be generated by compiler
>   public static readonly object O = new System.Object ();
>   public static void Main () {}
> }
> 

PENDING TASKS
-------------

* IMprove error handling here:

	public static Process ()

	THat assumes that it is a constructor, check if its the same name
	as the class, if not report a different error than the one we use now.

* Merge test 89 and test-34

* Revisit

	Primary-expression, as it has now been split into 
	non-array-creation-expression and array-creation-expression.
		
* Static flow analysis

	Required to warn about reachability of code and definite
	assignemt as well as missing returns on functions.

* Code cleanup

	The information when registering a method in InternalParameters
	is duplicated, you can always get the types from the InternalParameters

* Emit modreq for volatiles

	Handle modreq from public apis.

* Emit `pinned' for pinned local variables.

	Both `modreq' and pinned will require special hacks in the compiler.

* Make sure that we are pinning the right variable

* Maybe track event usage?  Currently I am not tracking these, although they
  are fields.

* Merge tree.cs, rootcontext.cs

OPTIMIZATIONS
-------------

* Implement loop inversion for `For' as well.

* There is too much unshared code between MemberAccess.Resolve and SimpleName
  resolve.  
 
* User Defined Conversions is doing way too many calls to do union sets that are not needed

* Add test case for destructors

* Places that use `Ldelema' are basically places where I will be
  initializing a value type.  I could apply an optimization to 
  disable the implicit local temporary from being created (by using
  the method in New).

* Dropping TypeContainer as an argument to EmitContext

 	My theory is that I can get rid of the TypeBuilder completely from
	the EmitContext, and have typecasts where it is used (from
	DeclSpace to where it matters).  

	The only pending problem is that the code that implements Aliases
	is on TypeContainer, and probably should go in DeclSpace.

* Casts need to trigger a name resolution against types only.

	currently we use a secret hand shake, probably we should use
	a differen path, and only expressions (memberaccess, simplename)
	would participate in this protocol.

* Use of local temporary in UnaryMutator

	We should get rid of the Localtemporary there for some cases

* Emitcontext

	Do we really need to instanciate this variable all the time?

	It could be static for all we care, and just use it for making
	sure that there are no recursive invocations on it.

* Use of EmitBranchable

	Currently I use brfalse/brtrue in the code for statements, instead of
	using the EmitBranchable function that lives in Binary

* ConvertImplicit

	Currently ConvertImplicit will not catch things like:

	- IntLiteral in a float context to generate a -FloatLiteral.
	Instead it will perform an integer load followed by a conversion.

* Tests

	Write tests for the various reference conversions.  We have
	test for all the numeric conversions.

* Optimizations

	In Indexers and Properties, probably support an EmitWithDup
	That emits the code to call Get and then leaves a this pointer
	in the stack, so that later a Store can be emitted using that
	this pointer (consider Property++ or Indexer++)

* Optimizations: variable allocation.

	When local variables of a type are required, we should request
	the variable and later release it when we are done, so that
	the same local variable slot can be reused later on.

* Add a cache for the various GetArrayMethod operations.

* TypeManager.FindMembers:

	Instead of having hundreds of builder_to_blah hash table, have
	a single one that maps a TypeBuilder `t' to a set of classes
	that implement an interface that supports FindMembers.

* MakeUnionSet Callers

	If the types are the same, there is no need to compute the unionset,
 	we can just use the list from one of the types.

* Factor all the FindMembers in all the FindMembers providers.

* Factor the lookup code for class declarations an interfaces
  (interface.cs:GetInterfaceByName)

RECOMMENDATIONS
---------------

* Use of lexer.Location in the parser

	Currently we do:

	TOKEN nt TERMINAL nt TERMINAL nt3 {
		$$ = new Blah ($2, $4, $6, lexer.Location);
	}

	This is bad, because the lexer.Location is for the last item in `nt3'

	We need to change that to use this pattern:

	TOKEN { oob_stack.Push (lexer.Location) } nt TERMINAL nt TERMINAL nt3 {
		$$ = new Blah ($3, $5, $7, (Location) oob_stack.Pop ());
	}

	Notice how numbering of the arguments changes as the
	{ oob_stack.Push (lexer.Location) } takes a "slot"  in the productions.

* local_variable_declaration

	Not sure that this grammar is correct, we might have to
	resolve this during semantic analysis.

* Idea

	MethodGroupExpr

	These guys should only appear as part of an Invocation, so we
	probably can afford to have a special callback:

		Expression.ResolveAllowMemberGroups

	This is only called by Invocation (or anyone that consumes 
	MethodGroupExprs)

	And the regular DoResolve and DoResolveLValue do emit the error
	654 `Method referenced without argument list'.  

	Otherwise, a resolution will return a MethodGroupExpr which is
	not guaranteed to have set its `Expression.Type' to a non-null
	value.
