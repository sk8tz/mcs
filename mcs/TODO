* Reorganization

	There is a mess right now between SimpleName,
	ResolveMemberAccess and Invocation.

	Nested things like:

	class X {
		X Prop () {  get ... }
	}

	class Y {
		void a (X x)
		{
			x.Prop.Prop.Prop.Prop.method ();
		}
	}

	Are valid, and our current recursive-less implementation wont
	address these.  

	We need to make sure that SimpleNames (which are a horrible
	name, as they are really CompoundNames right now) will be remapped
	to the propper MemberAccess after parsing. 

* Reorganization: calling structure methods

	Structure methods do not expect a `this' pointer, they expect
	an address on the stack.  We can probably use all the LValue members
	to do this.

	Now, for cases like:

		struct A { void M ();}
		class B { A Func () {}}

	When we do:
		b.Func ().M ()

	A temporary is created by the compiler to store the result from 
	b.Func, we could then use this LocalVariable to invoke the
	AddressOf on it.

* FindMembers

	Move our utility FindMembers from TypeContainer to Decl, because interfaces
	are also scanned with it.

* Ordering

	Can a constant_expression invoke overloaded operators?
	Explicit user-defined conversions?

* Visibility

	I am not reporting errors on visibility yet.

* Error handling

	Normalize, and use Tokenizer location 

* Enumerations

	Currently I am not resolving enumerations.

	Either I track them with `RecordEnum' as I do with classes,
	structs and interfaces or I rewrite the code to visit type
	containers and `walk' the enums with this process. 

* Known problems:

  Cast expressions

	They should should use:

		OPEN_PARENS type CLOSE_PARENS

	instead of the current production which is wrong, because it
	only handles a few cases.

	Complex casts like:

		Array r = (string []) object

	Wont be parsed.
  
* Interfaces

	For indexers, the output of ix2.cs is different from our
	compiler and theirs.  They use a DefaultMemberAttribute, which
	I have yet to figure out:

	.class interface private abstract auto ansi INTERFACE
	{
		.custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) 
		= ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..
		...
	}

* Interface indexers

	I have not figured out why the Microsoft version puts an
	`instance' attribute, and I am not generating this `instance' attribute.

* Constructors

	Currently it calls the parent constructor before initializing fields.
	It should do it the other way around.

* Use of EmitBranchable

	Currently I use brfalse/brtrue in the code for statements, instead of
	using the EmitBranchable function that lives in Binary

* Create an UnimplementedExpcetion

  	And use that instead of plain Exceptions.

* ConvertImplicit

	Currently ConvertImplicit will not catch things like:

	- IntLiteral in a float context to generate a -FloatLiteral.
	Instead it will perform an integer load followed by a conversion.

* In class.cs: Method.Define

	Need to use FindMembers to lookup the member for reporting
	whether a new is needed or not.  

* virtual-method.cs breaks

	It breaks on the call to: new B ();

	Where B is a class defined in the source code, my guess is that
	the look for ".ctor" fails

* Foreach on structure returns does not work

	I am generating invalid code instead of calling ldarga for the
	structure, I am calling ldarg:

	struct X {
		public IEnumerator GetEnumerator ();
	}

	X x;

	foreach (object a in x){
		...
	}

	I need to get the address of that bad boy

* Work todo:

	Understand how methods are invoked on structs