Missing:

	Support parameters.

Removal:

	Probably remove the parameter mapping as well for iterators,
	and just embed the knowledge on the parameter class.

Moving Iterators/Anonymous to a more comprehensive Field-based setup
--------------------------------------------------------------------
	IDEA:

	Maybe turn LocalVariableReference into Field access?


	One issue to consider if iterators/references in anon-methods
	to a setup where we use a FieldExpr plus a "clever" instance
	expression is that the LocalVariableReference will transform
	itself into something else during Resolve, but the resulting
	information must still be tracked in the LocalInfo

	I believe this is because:

	EmitMeta should not generate locals for things that have been
	captured, so it is important to track this information.

	Which means that we eliminate the knowledge about captured
	information from LocalVariableReference/ParameterReference
	during the Emit phase, but we still need it during the resolve
	phase.

Iterators:

	In foreach, I do not like the if (.. InIterator) special
	handling that we have there, it should be handled differently.

Block.Parameters
----------------

	Maybe move this to Topblock?  There is a fixme there.


Clean Up
--------

	Move MapVariable from CodeGen into Block?

Improve test:

	Necesitamos que a-capture8.cs pruebe si la asignacion funciona o no.

Audit:

	Al emitir instancias de variables
	(EmitCaptureVariableInstance) parece ser que el loop de iteracion:

	while (si.ScopeBlock.ID != li.Block.ID)

	está mas actulizado que el codigo similar para parámetros, es posible
	que sea bitrot de parámetros o que en los parámetros usamos otra estrategia
	(lo segundo es más razonable).
	
Iteradores:

	En algún lugar no pongo el `FieldBuilder' a un valor con los
	iteradores, ver expression.cs: 3616, local_info.FieldBuilder es nulo.

Parameters:

	a-parameter4.cs falla por que no se liga el método anónimo
	anidado con el padre.

Cleanup:

			CaptureContext cc = ContextForParameter (ec.CurrentBlock.Toplevel, name);
			if (cc != this){
				cc.EmitParameter (ec, name);
				return;
			}

	That should be a static method, and call the instance method
	in the right CaptureContext, instead of having the CaptureContext
	compute that itself.

Refactor:

	The code that links ScopeInfos together, its replicated in 3 places.

MakePinned is gone:

	Need to audit the code now that use DeclareLocal, and that this uses
	a differnent code path than the main mcs.

Parameters:

	We can optimize and make sure that we point to a separate class that
	only holds the parameters.

We need to nest anonymous method hosts as anonymous classes, currently
they are all toplevel.

Need to fix the order in which types are closed: currently we are not
compatible with the MS requirement that the parent has to be created
before the children are.

Would be nice to name the anonymous methods after the method container name.

Problems:

	We cluster blocks at the scope level, not at the level the declaration
	when its really needed:

	ie:

		int a = 0;
		if (a == 1)
			;
		int b = 0

	We consider those:

		int a;
		{
			int b;
		}

	So we cluster them on separate anonymous helper classes, which
	means the resulting is not as efficient.

Optimization from MS:

	When creating an anonymous method that is static, cache its value.
	
	I do not like the call to DoInit() in anonymous.cs, move it?

	Parameter assignment seems too simple.

Tests and pending features:

	Support access to parameters of a delegate (see a11.cs)

	How do parameters map to nested anonymous methods?

	Helper classes should be nested classes of the original host class.
	(permission: access private fields from another part)
	
	Switch statement is broken (because it uses ILGenerator during
	the Resolve phase, which with the `anonymous' branch is no longer
	the case: so we have to delay the creation of labels until they 
	are needed, during the Emit phase).

	Iteratorks are broken.

Validation:

	For testing, set ec.IG == null during resolve, restore value
	for emit.

	Currently it is commented out: there is a bug in the
	statement.cs changes (see the old-statement.cs, the compiler
	fails during bootstrap)

	Need to set `S.R.CompilerServices.CompilerGeneratedAttribute'
	on classes that the compiler generates.
