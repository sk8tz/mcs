%{
//
// Mono::ILASM::ILParser
// 
// (C) Sergey Chaban (serge@wildwestsoftware.com)
// (C) 2003 Jackson Harper, All rights reserved
//

using PEAPI;
using System;
using System.IO;
using System.Collections;
using System.Globalization;

namespace Mono.ILASM {

	public class ILParser {

		private CodeGen codegen;

		private bool is_value_class;
		private bool is_enum_class;
                private bool pinvoke_info;
                private string pinvoke_mod;
                private string pinvoke_meth;
                private PEAPI.PInvokeAttr pinvoke_attr;
                private ILTokenizer tokenizer;
                                
		public ILParser (CodeGen codegen, ILTokenizer tokenizer)
                {
			this.codegen = codegen;
                        this.tokenizer = tokenizer;
		}

		public CodeGen CodeGen {
			get { return codegen; }
		}

                private ITypeRef GetTypeRef (ITypeRef b)
                {
                        ExternTypeRefInst etri = b as ExternTypeRefInst;
                        ExternTypeRef etr;

                        if (etri != null)
                                return etri.Clone ();

                        etr = b as ExternTypeRef;
                        if (etr != null)
                                return etr.Clone ();

                        return b;
                }
%}

%token EOF

/* ID - alpha-numeric identifier */
%token ID

/* QSTRING - quoted string */
%token QSTRING

/* SQSTRING - single quoted string */
%token SQSTRING

/* COMP_NAME - A name with dots */
%token COMP_NAME

/* INT32 - 32 bit integer */
%token INT32

/* INT64 - 64 bit integer */
%token INT64

/* FLOAT64 - floating point number */
%token FLOAT64

/* HEXBYTE - two digit hex number */
%token HEXBYTE


/* Punctuation */
%token DOT           "."
%token OPEN_BRACE    "{"
%token CLOSE_BRACE   "}"
%token OPEN_BRACKET  "["
%token CLOSE_BRACKET "]"
%token OPEN_PARENS   "("
%token CLOSE_PARENS  ")"
%token COMMA         ","
%token COLON         ":"
%token DOUBLE_COLON  "::"
%token SEMICOLON     ";"
%token ASSIGN        "="
%token STAR          "*"
%token AMPERSAND     "&"
%token PLUS          "+"
%token SLASH         "/"
%token BANG          "!"
%token ELLIPSIS      "..."
%token DASH          "-"
%token OPEN_ANGLE_BRACKET   "<"
%token CLOSE_ANGLE_BRACKET  ">"



%token UNKNOWN


/* INSTR_* instruction types */
%token INSTR_NONE
%token INSTR_VAR
%token INSTR_I
%token INSTR_I8
%token INSTR_R
%token INSTR_BRTARGET
%token INSTR_METHOD
%token INSTR_NEWOBJ
%token INSTR_FIELD
%token INSTR_TYPE
%token INSTR_STRING
%token INSTR_SIG
%token INSTR_RVA
%token INSTR_TOK
%token INSTR_SWITCH
%token INSTR_PHI
%token INSTR_LOCAL
%token INSTR_PARAM





/* Mechanically generated  - DO NOT EDIT! */


/* Directives */
%token D_ADDON
%token D_ALGORITHM
%token D_ASSEMBLY
%token D_BACKING
%token D_BLOB
%token D_CAPABILITY
%token D_CCTOR
%token D_CLASS
%token D_COMTYPE
%token D_CONFIG
%token D_CONSTRAINT
%token D_IMAGEBASE
%token D_CORFLAGS
%token D_CTOR
%token D_CUSTOM
%token D_DATA
%token D_EMITBYTE
%token D_ENTRYPOINT
%token D_EVENT
%token D_EXELOC
%token D_EXPORT
%token D_FIELD
%token D_FILE
%token D_FIRE
%token D_GET
%token D_HASH
%token D_IMPLICITCOM
%token D_LANGUAGE
%token D_LINE
%token D_XLINE
%token D_LOCALE
%token D_LOCALS
%token D_MANIFESTRES
%token D_MAXSTACK
%token D_METHOD
%token D_MIME
%token D_MODULE
%token D_MRESOURCE
%token D_NAMESPACE
%token D_ORIGINATOR
%token D_OS
%token D_OTHER
%token D_OVERRIDE
%token D_PACK
%token D_PARAM
%token D_PERMISSION
%token D_PERMISSIONSET
%token D_PROCESSOR
%token D_PROPERTY
%token D_PUBLICKEY
%token D_PUBLICKEYTOKEN
%token D_REMOVEON
%token D_SET
%token D_SIZE
%token D_SUBSYSTEM
%token D_TITLE
%token D_TRY
%token D_VER
%token D_VTABLE
%token D_VTENTRY
%token D_VTFIXUP
%token D_ZEROINIT


/* Keywords */
%token K_AT
%token K_AS
%token K_IMPLICITCOM
%token K_IMPLICITRES
%token K_NOAPPDOMAIN
%token K_NOPROCESS
%token K_NOMACHINE
%token K_EXTERN
%token K_INSTANCE
%token K_EXPLICIT
%token K_DEFAULT
%token K_VARARG
%token K_UNMANAGED
%token K_CDECL
%token K_STDCALL
%token K_THISCALL
%token K_FASTCALL
%token K_MARSHAL
%token K_IN
%token K_OUT
%token K_OPT
%token K_LCID
%token K_RETVAL
%token K_STATIC
%token K_PUBLIC
%token K_PRIVATE
%token K_FAMILY
%token K_INITONLY
%token K_RTSPECIALNAME
%token K_SPECIALNAME
%token K_ASSEMBLY
%token K_FAMANDASSEM
%token K_FAMORASSEM
%token K_PRIVATESCOPE
%token K_LITERAL
%token K_NOTSERIALIZED
%token K_VALUE
%token K_NOT_IN_GC_HEAP
%token K_INTERFACE
%token K_SEALED
%token K_ABSTRACT
%token K_AUTO
%token K_SEQUENTIAL
%token K_ANSI
%token K_UNICODE
%token K_AUTOCHAR
%token K_IMPORT
%token K_SERIALIZABLE
%token K_NESTED
%token K_LATEINIT
%token K_EXTENDS
%token K_IMPLEMENTS
%token K_FINAL
%token K_VIRTUAL
%token K_HIDEBYSIG
%token K_NEWSLOT
%token K_UNMANAGEDEXP
%token K_PINVOKEIMPL
%token K_NOMANGLE
%token K_OLE
%token K_LASTERR
%token K_WINAPI
%token K_NATIVE
%token K_IL
%token K_CIL
%token K_OPTIL
%token K_MANAGED
%token K_FORWARDREF
%token K_RUNTIME
%token K_INTERNALCALL
%token K_SYNCHRONIZED
%token K_NOINLINING
%token K_CUSTOM
%token K_FIXED
%token K_SYSSTRING
%token K_ARRAY
%token K_VARIANT
%token K_CURRENCY
%token K_SYSCHAR
%token K_VOID
%token K_BOOL
%token K_INT8
%token K_INT16
%token K_INT32
%token K_INT64
%token K_FLOAT32
%token K_FLOAT64
%token K_ERROR
%token K_UNSIGNED
%token K_DECIMAL
%token K_DATE
%token K_BSTR
%token K_LPSTR
%token K_LPWSTR
%token K_LPTSTR
%token K_OBJECTREF
%token K_IUNKNOWN
%token K_IDISPATCH
%token K_STRUCT
%token K_SAFEARRAY
%token K_INT
%token K_BYVALSTR
%token K_TBSTR
%token K_LPVOID
%token K_ANY
%token K_FLOAT
%token K_LPSTRUCT
%token K_NULL
%token K_PTR
%token K_VECTOR
%token K_HRESULT
%token K_CARRAY
%token K_USERDEFINED
%token K_RECORD
%token K_FILETIME
%token K_BLOB
%token K_STREAM
%token K_STORAGE
%token K_STREAMED_OBJECT
%token K_STORED_OBJECT
%token K_BLOB_OBJECT
%token K_CF
%token K_CLSID
%token K_METHOD
%token K_CLASS
%token K_PINNED
%token K_MODREQ
%token K_MODOPT
%token K_TYPEDREF
%token K_WCHAR
%token K_CHAR
%token K_FROMUNMANAGED
%token K_CALLMOSTDERIVED
%token K_BYTEARRAY
%token K_WITH
%token K_INIT
%token K_TO
%token K_CATCH
%token K_FILTER
%token K_FINALLY
%token K_FAULT
%token K_HANDLER
%token K_TLS
%token K_FIELD
%token K_REQUEST
%token K_DEMAND
%token K_ASSERT
%token K_DENY
%token K_PERMITONLY
%token K_LINKCHECK
%token K_INHERITCHECK
%token K_REQMIN
%token K_REQOPT
%token K_REQREFUSE
%token K_PREJITGRANT
%token K_PREJITDENY
%token K_NONCASDEMAND
%token K_NONCASLINKDEMAND
%token K_NONCASINHERITANCE
%token K_READONLY
%token K_NOMETADATA
%token K_ALGORITHM
%token K_FULLORIGIN
// %token K_NAN
// %token K_INF
%token K_PUBLICKEY
%token K_ENABLEJITTRACKING
%token K_DISABLEJITOPTIMIZER
%token K_PRESERVESIG
%token K_BEFOREFIELDINIT
%token K_ALIGNMENT
%token K_NULLREF
%token K_VALUETYPE
%token K_COMPILERCONTROLLED
%token K_REQSECOBJ
%token K_ENUM
%token K_OBJECT
%token K_STRING
%token K_TRUE
%token K_FALSE
%token K_IS

/* end generated */





%start il_file

%%

il_file			: decls
			;

decls			: /* EMPTY */
			| decls decl
			;

decl			: class_all
			| namespace_all
			| method_all
			| field_decl
			| data_decl
			| vtfixup_decl
			| file_decl
			| assembly_all
			| assemblyref_all
			| exptype_all
			| manifestres_all
			| module_head
			| sec_decl
			| customattr_decl
			| D_SUBSYSTEM int32
                          {
                                codegen.SetSubSystem ((int) $2);
                          }
			| D_CORFLAGS int32
                          {
                                codegen.SetCorFlags ((int) $2);
                          }
			| D_FILE K_ALIGNMENT int32
			| D_IMAGEBASE int64
                          {
                                codegen.SetImageBase ((long) $2);
                          }
			| extsource_spec
			| language_decl
			;

extsource_spec		: D_LINE int32 SQSTRING
			| D_LINE int32
			| D_LINE int32 COLON int32 SQSTRING
			| D_LINE int32 COLON int32
			;

language_decl		: D_LANGUAGE SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING
			| D_LANGUAGE SQSTRING COMMA SQSTRING COMMA SQSTRING
			;

constraint_decl         : D_CONSTRAINT BANG int32 K_IS type
                          {
                                codegen.CurrentTypeDef.AddGenericConstraint ((int) $3, (ITypeRef) $5);
                          }
                        ;
                        
vtfixup_decl		: D_VTFIXUP OPEN_BRACKET int32 CLOSE_BRACKET 
			  vtfixup_attr K_AT id
			;

vtfixup_attr		: /* EMPTY */
			| vtfixup_attr K_INT32
			| vtfixup_attr K_INT64
			| vtfixup_attr K_FROMUNMANAGED
			| vtfixup_attr K_CALLMOSTDERIVED
			;

namespace_all		: namespace_head OPEN_BRACE decls CLOSE_BRACE
                          {
                                codegen.CurrentNameSpace = null;
                          }
			;

namespace_head		: D_NAMESPACE comp_name
                          {
                                codegen.CurrentNameSpace = (string) $2;
                          }
			;

class_all		: class_head OPEN_BRACE class_decls CLOSE_BRACE
                          {
                                codegen.EndTypeDef ();
                          }
			;

class_head 		: D_CLASS class_attr id formal_typars_clause extends_clause
                          impl_clause
                          {
                                codegen.BeginTypeDef ((TypeAttr) $2, (string) $3, 
						$5 as IClassRef, $6 as ArrayList, null);
				
				if (is_value_class)
					codegen.CurrentTypeDef.MakeValueClass ();
				if (is_enum_class)
					codegen.CurrentTypeDef.MakeEnumClass ();

                                if ($4 != null) {
                                        ArrayList typars_list = (ArrayList) $4;
                                        foreach (string id in typars_list)
                                                codegen.CurrentTypeDef.AddGenericParam (id);
                                }                                
                          }
			;

class_attrs		: class_attrs class_attr
			;

class_attr		: /* EMPTY */                           
			  { 
				// Reset some flags
				is_value_class = false;
				is_enum_class = false;
				$$ = new TypeAttr ();
			  }
			| class_attr K_PUBLIC                   { $$ = (TypeAttr)$1 | TypeAttr.Public; }        
			| class_attr K_PRIVATE                  { $$ = (TypeAttr)$1 | TypeAttr.Private; }
			| class_attr K_NESTED K_PRIVATE         { $$ = (TypeAttr)$1 | TypeAttr.NestedPrivate; }
			| class_attr K_NESTED K_PUBLIC          { $$ = (TypeAttr)$1 | TypeAttr.NestedPublic; }
			| class_attr K_NESTED K_FAMILY          { $$ = (TypeAttr)$1 | TypeAttr.NestedFamily; }
			| class_attr K_NESTED K_ASSEMBLY        { $$ = (TypeAttr)$1 | TypeAttr.NestedAssembly;}
			| class_attr K_NESTED K_FAMANDASSEM     { $$ = (TypeAttr)$1 | TypeAttr.NestedFamAndAssem; }
			| class_attr K_NESTED K_FAMORASSEM      { $$ = (TypeAttr)$1 | TypeAttr.NestedFamOrAssem; }
			| class_attr K_VALUE                    { is_value_class = true; }
			| class_attr K_ENUM                     { is_enum_class = true; is_value_class = true;
			  }
			| class_attr K_INTERFACE                { $$ = (TypeAttr)$1 | TypeAttr.Interface; }
			| class_attr K_SEALED                   { $$ = (TypeAttr)$1 | TypeAttr.Sealed; }
			| class_attr K_ABSTRACT                 { $$ = (TypeAttr)$1 | TypeAttr.Abstract; }
			| class_attr K_AUTO                     {  }
			| class_attr K_SEQUENTIAL               { $$ = (TypeAttr)$1 | TypeAttr.SequentialLayout; }
			| class_attr K_EXPLICIT                 { $$ = (TypeAttr)$1 | TypeAttr.ExplicitLayout; }
			| class_attr K_ANSI                     {  }
			| class_attr K_UNICODE                  { $$ = (TypeAttr)$1 | TypeAttr.UnicodeClass; }
			| class_attr K_AUTOCHAR                 { $$ = (TypeAttr)$1 | TypeAttr.AutoClass; }
			| class_attr K_IMPORT                   { $$ = (TypeAttr)$1 | TypeAttr.Import; }
			| class_attr K_SERIALIZABLE             { $$ = (TypeAttr)$1 | TypeAttr.Serializable; }
			| class_attr K_BEFOREFIELDINIT          { $$ = (TypeAttr)$1 | TypeAttr.BeforeFieldInit; }
			| class_attr K_SPECIALNAME              { $$ = (TypeAttr)$1 | TypeAttr.SpecialName; }
			| class_attr K_RTSPECIALNAME            { $$ = (TypeAttr)$1 | TypeAttr.RTSpecialName; }
			;

extends_clause		: /* EMPTY */
			| K_EXTENDS class_ref
                          {
                                $$ = $2;
                          }
			;

impl_clause		: /* EMPTY */
			| K_IMPLEMENTS class_refs
                          {
                                $$ = $2;
                          }
			;

formal_typars_clause           : /* EMPTY */
                        | OPEN_ANGLE_BRACKET formal_typars CLOSE_ANGLE_BRACKET
                          {
                                $$ = $2;
                          }
                        ;

typars_clause           : /* EMPTY */
                        | OPEN_ANGLE_BRACKET typars CLOSE_ANGLE_BRACKET
                          {
                                $$ = $2;
                          }
                        ;

typars                  : type
                          {
                                ArrayList typars_list = new ArrayList ();
                                typars_list.Add ($1);
                                $$ = typars_list;
                          }
                        | typars COMMA type
                          {
                                ArrayList typars_list = (ArrayList) $1;
                                typars_list.Add ($3);
                                $$ = typars_list;
                          }
                        ;

formal_typars           : formal_typar
                          {
                                ArrayList formal_list = new ArrayList ();
                                formal_list.Add ($1);
                                $$ = formal_list;
                          }
                        | formal_typars COMMA formal_typar
                          {
                                ArrayList formal_list = (ArrayList) $1;
                                formal_list.Add ($3);
                                $$ = formal_list;
                          }
                        ;


formal_typar            : id
                          {
                                $$ = $1;
                          }
                        ;
                        
class_refs		: class_ref
                          {
                                ArrayList class_list = new ArrayList ();
                                class_list.Add ($1);
                                $$ = class_list; 
                          }
			| class_refs COMMA class_ref
                          {
                                ArrayList class_list = (ArrayList) $1;
                                class_list.Add ($3);
                          }
			;

slashed_name		: comp_name
			| slashed_name SLASH comp_name
                          {
                                $$ = String.Format ("{0}/{1}", $1, $3);
                          }
			;

class_ref		: OPEN_BRACKET slashed_name CLOSE_BRACKET slashed_name
                          {
                                if (codegen.IsThisAssembly ((string) $2)) {
                                        $$ = new TypeRef ((string) $4, false, null);
                                } else {
                                        $$ = codegen.ExternTable.GetTypeRef ((string) $2, (string) $4, false);
                                }
                          }
			| OPEN_BRACKET D_MODULE slashed_name CLOSE_BRACKET slashed_name
                          {
                                if (codegen.IsThisModule ((string) $3)) {
                                        $$ = new TypeRef ((string) $5, false, null);
                                } else {
                                        $$ = codegen.ExternTable.GetModuleTypeRef ((string) $3, (string) $5, false);
                                }
                          }
			| slashed_name
                          {
                                PrimitiveTypeRef prim = PrimitiveTypeRef.GetPrimitiveType ((string) $1);

                                if (prim != null)
                                        $$ = prim;
                                else
                                        $$ = new TypeRef ((string) $1, false, null);
                          }
                      
			;

class_decls		: /* EMPTY */
			| class_decls class_decl
			;

class_decl		: method_all
			| class_all
			| event_all
			| prop_all
			| field_decl
			| data_decl
			| sec_decl
			| extsource_spec
			| customattr_decl
                          {
                                codegen.CurrentTypeDef.AddCustomAttribute ((CustomAttr) $1);
                          }
			| D_SIZE int32
                          {
                                codegen.CurrentTypeDef.SetSize ((int) $2);
                          }
			| D_PACK int32
                          {
                                codegen.CurrentTypeDef.SetPack ((int) $2);
                          }
			| D_OVERRIDE type_spec DOUBLE_COLON method_name K_WITH call_conv type
                          type_spec DOUBLE_COLON method_name type_list
                          {
                                //
                                // My copy of the spec didn't have a type_list but
                                // it seems pretty crucial
                                //
                                ITypeRef owner = (ITypeRef) $2;
                                ArrayList arg_list = (ArrayList) $11;
                                ITypeRef[] param_list;
                                IMethodRef decl;

                                if (arg_list != null)
                                        param_list = (ITypeRef[]) arg_list.ToArray (typeof (ITypeRef));
                                else
                                        param_list = new ITypeRef[0];

                                decl = owner.GetMethodRef ((ITypeRef) $7,
                                        (CallConv) $6, (string) $4, param_list);

                                string sig = MethodDef.CreateSignature ((string) $10,
                                                                        param_list);
                                codegen.CurrentTypeDef.AddOverride (sig, decl);                                        
                          }
			  OPEN_PARENS sig_args CLOSE_PARENS
			| language_decl
                        | constraint_decl
			;

type			: K_CLASS class_ref
                          {
                                $$ = $2;
                          }
			| K_OBJECT
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Object, "System.Object");
                          }
			| K_STRING
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.String, "System.String");
                          }
			| K_VALUE K_CLASS class_ref
                          {
				IClassRef class_ref = (IClassRef) $3;
				class_ref.MakeValueClass ();
                                $$ = class_ref;
                          }
			| K_VALUETYPE OPEN_BRACKET slashed_name CLOSE_BRACKET slashed_name
                          {
                                ExternTypeRef ext_ref = codegen.ExternTable.GetTypeRef ((string) $3, (string) $5, false);
                                ExternTypeRefInst inst = new ExternTypeRefInst (ext_ref, true);
                                $$ = inst;
                          }
                        | K_VALUETYPE slashed_name
                          {
                                TypeRef t_ref = new TypeRef ((string) $2, true, null);
                                t_ref.MakeValueClass ();
                                $$ = t_ref;
                          }
			| type OPEN_BRACKET CLOSE_BRACKET
                          {
                                ITypeRef base_type = GetTypeRef ((ITypeRef) $1);
                                base_type.MakeArray ();
                                $$ = base_type;
                          }
			| type OPEN_BRACKET bounds CLOSE_BRACKET
                          {
                                ITypeRef base_type = GetTypeRef ((ITypeRef) $1);
                                ArrayList bound_list = (ArrayList) $3;
                                base_type.MakeBoundArray (bound_list);
                                $$ = base_type;
                          }
			| type AMPERSAND
                          {
                                ITypeRef base_type = GetTypeRef ((ITypeRef) $1);
                                base_type.MakeManagedPointer ();
                                $$ = base_type;
                          }
			| type STAR
                          {
                                ITypeRef base_type = GetTypeRef ((ITypeRef) $1);
                                base_type.MakeUnmanagedPointer ();
                                $$ = base_type;
                          }
			| type K_PINNED
                          {
                                ITypeRef base_type = GetTypeRef ((ITypeRef) $1);
                                base_type.MakePinned ();
                                $$ = base_type;
                          }
			| type K_MODREQ OPEN_PARENS class_ref CLOSE_PARENS
                          {
                                ITypeRef base_type = GetTypeRef ((ITypeRef) $1);
                                IClassRef class_ref = (IClassRef) $4;
                                base_type.MakeCustomModified (codegen,
                                        CustomModifier.modopt, class_ref);
                                $$ = base_type;
                          }
			| type K_MODOPT OPEN_PARENS class_ref CLOSE_PARENS
                          {
                                ITypeRef base_type = GetTypeRef ((ITypeRef) $1);
                                IClassRef class_ref = (IClassRef) $4;
                                base_type.MakeCustomModified (codegen,
                                        CustomModifier.modopt, class_ref);
                                $$ = base_type;
                          }
			| K_METHOD call_conv type STAR OPEN_PARENS sig_args CLOSE_PARENS
                          {
                                $$ = new MethodPointerTypeRef ((CallConv) $2, (ITypeRef) $3, (ArrayList) $6);
                          }
			| K_TYPEDREF
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.TypedRef,
                                        "System.TypedReference");
                          }
			| K_CHAR
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Char, "System.Char");
                          }
			| K_WCHAR
			  {
				$$ = new PrimitiveTypeRef (PrimitiveType.Char, "System.Char");
			  }
			| K_VOID
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Void, "System.Void");
                          }
			| K_BOOL
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Boolean, "System.Bool");
                          }
			| K_INT8
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Int8, "System.Int8");
                          }
			| K_INT16
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Int16, "System.Int16");
                          }
			| K_INT32
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Int32, "System.Int32");
                          }
			| K_INT64
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Int64, "System.Int64");
                          }
			| K_FLOAT32
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Float32, "System.Float32");
                          }
			| K_FLOAT64
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.Float64, "System.Float64");
                          }
			| K_UNSIGNED K_INT8
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.UInt8, "System.UInt8");
                          }
			| K_UNSIGNED K_INT16
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.UInt16, "System.UInt16");     
                          }
			| K_UNSIGNED K_INT32
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.UInt32, "System.UInt32");
                          }
			| K_UNSIGNED K_INT64
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.UInt64, "System.UInt64");
                          }
			| K_NATIVE K_INT
                          {
                                // TODO: Is this the proper full name
                                $$ = new PrimitiveTypeRef (PrimitiveType.NativeInt, "System.IntPtr");
                          }
                        
			| K_NATIVE K_UNSIGNED K_INT
                          {
                                $$ = new PrimitiveTypeRef (PrimitiveType.NativeUInt, "System.UIntPtr");
                          }
                        | BANG int32
                          {
                                GenericTypeSpec spec = new GenericTypeSpec ((int) $2);
                                $$ = new GenericTypeRef (spec, $2.ToString ());
                          }
                        | BANG BANG int32
                          {
                                MVar mvar = new MVar ((int) $3);
                                $$ = new GenericTypeRef (mvar, $3.ToString ());
                          }
                        | K_CLASS slashed_name OPEN_ANGLE_BRACKET BANG int32 CLOSE_ANGLE_BRACKET
                          {
                                $$ = new TypeRef ((string) $2, false, null);
                          }
                        | K_CLASS slashed_name OPEN_ANGLE_BRACKET typars CLOSE_ANGLE_BRACKET
                          {
                                ArrayList typar_list = (ArrayList) $4;
                                ITypeRef[] typar_array = (ITypeRef[]) typar_list.ToArray (typeof (ITypeRef));
                                
                                $$ = new GenericTypeInst ((string)$2, typar_array);
                          }
			;

bounds			: bound
                          {
                                ArrayList bound_list = new ArrayList ();
                                bound_list.Add ($1);
                                $$ = bound_list;
                          }
			| bounds COMMA bound
                          {
                                ArrayList bound_list = (ArrayList) $1;
                                bound_list.Add ($3);
                          }
			;

bound			: /* EMPTY */
                          {
                                // This is shortref for no lowerbound or size
                                $$ = new DictionaryEntry (TypeRef.Ellipsis, TypeRef.Ellipsis);
                          }
			| ELLIPSIS
                          {
                                // No lower bound or size
                                $$ = new DictionaryEntry (TypeRef.Ellipsis, TypeRef.Ellipsis);
                          }
			| int32
                          {
                                // ******** Not sure what this is?
                                // For now I will say it is size because there
                                // is allready a way to set lower
                                $$ = new DictionaryEntry (TypeRef.Ellipsis, $1);
                          }
			| int32 ELLIPSIS int32
                          {
                                // lower bound and size
                                $$ = new DictionaryEntry ($1, $3);
                          }
			| int32 ELLIPSIS
                          {
                                // Just lower bound
                                $$ = new DictionaryEntry ($1, TypeRef.Ellipsis);
                          }
			;

call_conv		: K_INSTANCE call_conv
                          {
                                $$ = (CallConv) $2 | CallConv.Instance;
                          }
			| K_EXPLICIT call_conv
                          {
                                $$ = (CallConv) $2 | CallConv.InstanceExplicit;
                          }
			| call_kind
			;

call_kind		: /* EMPTY */
                          {
                                $$ = new CallConv ();
                          }
			| K_DEFAULT
                          {
                                $$ = CallConv.Default;
                          }
			| K_VARARG
                          {
                                $$ = CallConv.Vararg;
                          }
			| K_UNMANAGED K_CDECL
                          {
                                $$ = CallConv.Cdecl;
                          }
			| K_UNMANAGED K_STDCALL
                          {
                                $$ = CallConv.Stdcall;
                          }
			| K_UNMANAGED K_THISCALL
                          {
                                $$ = CallConv.Thiscall;
                          }
			| K_UNMANAGED K_FASTCALL
                          {
                                $$ = CallConv.Fastcall;
                          }
			;

native_type		: /* EMPTY */
			| K_CUSTOM OPEN_PARENS comp_qstring COMMA comp_qstring CLOSE_PARENS
			| K_FIXED K_SYSSTRING OPEN_BRACKET int32 CLOSE_BRACKET
                          {
                                $$ = NativeType.FixedSysString;
                          }
			| K_FIXED K_ARRAY OPEN_BRACKET int32 CLOSE_BRACKET
			| K_VARIANT
			| K_CURRENCY
                          {
                                $$ = NativeType.Currency;
                          }
			| K_SYSCHAR
			| K_VOID
                          {
                                $$ = NativeType.Void;
                          }
			| K_BOOL
                          {
                                $$ = NativeType.Boolean;
                          }
			| K_INT8
                          {
                                $$ = NativeType.Int8;
                          }
			| K_INT16
                          {
                                $$ = NativeType.Int16;
                          }
			| K_INT32
                          {
                                $$ = NativeType.Int32;
                          }
			| K_INT64
                          {
                                $$ = NativeType.Int64;
                          }
			| K_FLOAT32
                          {
                                $$ = NativeType.Float32;
                          }
			| K_FLOAT64
                          {
                                $$ = NativeType.Float64;
                          }
			| K_ERROR
			| K_UNSIGNED K_INT8
                          {
                                $$ = NativeType.UInt8;
                          }
			| K_UNSIGNED K_INT16
                          {
                                $$ = NativeType.UInt16;
                          }
			| K_UNSIGNED K_INT32
                          {
                                $$ = NativeType.UInt32;
                          }
			| K_UNSIGNED K_INT64
                          {
                                $$ = NativeType.UInt64;
                          }
			| native_type STAR
			| native_type OPEN_BRACKET CLOSE_BRACKET
			| native_type OPEN_BRACKET int32 CLOSE_BRACKET
			| native_type OPEN_BRACKET int32 PLUS int32 CLOSE_BRACKET
			| native_type OPEN_BRACKET PLUS int32 CLOSE_BRACKET
			| K_DECIMAL
			| K_DATE
			| K_BSTR
                          {
                                $$ = NativeType.BStr;
                          }
			| K_LPSTR
                          {
                                $$ = NativeType.LPStr;
                          }
			| K_LPWSTR
                          {
                                $$ = NativeType.LPWStr;
                          }
			| K_LPTSTR
                          {
                                $$ = NativeType.LPTStr;
                          }
			| K_OBJECTREF
			| K_IUNKNOWN
                          {
                                $$ = NativeType.IUnknown;
                          }
			| K_IDISPATCH
                          {
                                $$ = NativeType.IDispatch;
                          }
			| K_STRUCT
                          {
                                $$ = NativeType.Struct;
                          }
			| K_INTERFACE
                          {
                                $$ = NativeType.Interface;
                          }
			| K_SAFEARRAY variant_type
			| K_SAFEARRAY variant_type COMMA comp_qstring
			| K_INT
                          {
                                $$ = NativeType.Int;
                          }
			| K_UNSIGNED K_INT
                          {
                                $$ = NativeType.UInt;
                          }
			| K_NESTED K_STRUCT
			| K_BYVALSTR
                          {
                                $$ = NativeType.ByValStr;
                          }
			| K_ANSI K_BSTR
                          {
                                $$ = NativeType.AnsiBStr;
                          }
			| K_TBSTR
                          {
                                $$ = NativeType.TBstr;
                          }
			| K_VARIANT K_BOOL
                          {
                                $$ = NativeType.VariantBool;
                          }
			| K_METHOD
			| K_AS K_ANY
                          {
                                $$ = NativeType.AsAny;
                          }
			| K_LPSTRUCT
			;

variant_type		: /* EMPTY */
			| K_NULL
			| K_VARIANT
			| K_CURRENCY
			| K_VOID
			| K_BOOL
			| K_INT8
			| K_INT16
			| K_INT32
			| K_INT64
			| K_FLOAT32
			| K_FLOAT64
			| K_UNSIGNED K_INT8
			| K_UNSIGNED K_INT16
			| K_UNSIGNED K_INT32
			| K_UNSIGNED K_INT64
			| STAR
			| variant_type OPEN_BRACKET CLOSE_BRACKET
			| variant_type K_VECTOR
			| variant_type AMPERSAND
			| K_DECIMAL
			| K_DATE
			| K_BSTR
			| K_LPSTR
			| K_LPWSTR
			| K_IUNKNOWN
			| K_IDISPATCH
			| K_SAFEARRAY
			| K_INT
			| K_UNSIGNED K_INT
			| K_ERROR
			| K_HRESULT
			| K_CARRAY
			| K_USERDEFINED
			| K_RECORD
			| K_FILETIME
			| K_BLOB
			| K_STREAM
			| K_STORAGE
			| K_STREAMED_OBJECT
			| K_STORED_OBJECT
			| K_BLOB_OBJECT
			| K_CF
			| K_CLSID
			;

field_decl		: D_FIELD repeat_opt field_attr type id at_opt init_opt
                          {
                                FieldDef field_def = new FieldDef((FieldAttr) $3, 
					(string) $5, (ITypeRef) $4);
                                codegen.AddFieldDef (field_def);
                                
                                if ($2 != null) {
                                        field_def.SetOffset ((uint) $2);
                                }

                                if ($6 != null) {
                                        field_def.AddDataValue ((string) $6);
                                }

                                if ($7 != null) {
                                        field_def.SetValue ((Constant) $7);
                                }
                          }
			;

repeat_opt		: /* EMPTY */
			| OPEN_BRACKET int32 CLOSE_BRACKET
                          {
                                $$ = $2;
                          }
			;

field_attr		: /* EMPTY */
                          {
                                $$ = new FieldAttr ();
                          }
			| field_attr K_PUBLIC
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Public;
                          }
			| field_attr K_PRIVATE
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Private;
                          }
			| field_attr K_FAMILY
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Family;
                          }
			| field_attr K_ASSEMBLY
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Assembly;
                          }
			| field_attr K_FAMANDASSEM
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.FamAndAssem;
                          }
			| field_attr K_FAMORASSEM
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.FamOrAssem;
                          }
			| field_attr K_PRIVATESCOPE
                          {
                                // This is just 0x0000
                          }
			| field_attr K_STATIC
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Static;
                          }
			| field_attr K_INITONLY
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Initonly;
                          }
			| field_attr K_RTSPECIALNAME
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.RTSpecialName;
                          }
			| field_attr K_SPECIALNAME
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.SpecialName;
                          }
			| field_attr K_MARSHAL OPEN_PARENS native_type CLOSE_PARENS
                          {
                                
                          }
			| field_attr K_LITERAL
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Literal;
                          }
			| field_attr K_NOTSERIALIZED
                          {
                                $$ = (FieldAttr) $1 | FieldAttr.Notserialized;
                          }
			;

at_opt			: /* EMPTY */
			| K_AT id
                          {
                                $$ = $2;
                          }
			;

init_opt		: /* EMPTY */
			| ASSIGN field_init
                          {
                                $$ = $2;
                          }
			;

field_init		: K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS
                          {
                                $$ = new FloatConst (Convert.ToSingle ($3));
                          }
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS
                          {
                                $$ = new DoubleConst (Convert.ToDouble ($3));
                          }
			| K_FLOAT32 OPEN_PARENS int64 CLOSE_PARENS
                          {
                                $$ = new FloatConst (Convert.ToSingle ($3));
                          }
			| K_FLOAT64 OPEN_PARENS int64 CLOSE_PARENS
                          {
                                $$ = new DoubleConst (Convert.ToDouble ($3));
                          }
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS
                          {
                                $$ = new IntConst (Convert.ToInt64 ($3));
                          }
			| K_INT32 OPEN_PARENS int64 CLOSE_PARENS
                          {
                                $$ = new IntConst (Convert.ToInt32 ($3));
                          }
			| K_INT16 OPEN_PARENS int64 CLOSE_PARENS
                          {
                                $$ = new IntConst (Convert.ToInt16 ($3));
                          }
			| K_CHAR OPEN_PARENS int64 CLOSE_PARENS
                          {
                                $$ = new CharConst (Convert.ToChar ($3));
                          }
			| K_WCHAR OPEN_PARENS int64 CLOSE_PARENS
			  {
				$$ = new CharConst (Convert.ToChar ($3));
			  }
			| K_INT8 OPEN_PARENS int64 CLOSE_PARENS
                          {
                                $$ = new IntConst (Convert.ToByte ($3));
                          }
			| K_BOOL OPEN_PARENS truefalse CLOSE_PARENS
                          {
                                $$ = new BoolConst ((bool) $3);
                          }
			| K_BYTEARRAY bytes_list
                          {
                                $$ = new ByteArrConst ((byte[]) $2);
                          }
			| comp_qstring
                          {
                                // ******** THIS IS NOT IN THE DOCUMENTATION ******** //
                                $$ = new StringConst ((string) $1);
                          }
			| K_NULLREF
                          {
                                $$ = new NullConst ();
                          }
			;

data_decl		: data_head data_body
                          {
                                DataDef datadef = (DataDef) $1;
                                
                                if ($2 is ArrayList) {
                                        ArrayList const_list = (ArrayList) $2;
                                        DataConstant[] const_arr = new DataConstant[const_list.Count];
                                        
                                        for (int i=0; i<const_arr.Length; i++)
                                                const_arr[i] = (DataConstant) const_list[i];

                                        datadef.PeapiConstant = new ArrayConstant (const_arr);
                                } else {
                                        datadef.PeapiConstant = (PEAPI.Constant) $2;
                                }
                                codegen.AddDataDef (datadef);
                          }
			;

data_head		: D_DATA tls id ASSIGN
                          {
                                $$ = new DataDef ((string) $3, (bool) $2);    
                          } 
			| D_DATA tls
                          {
                                $$ = new DataDef (String.Empty, (bool) $2);
                          }
			;

tls			: /* EMPTY */   { $$ = false; }
			| K_TLS         { $$ = true; }
			;

data_body		: OPEN_BRACE dataitem_list CLOSE_BRACE
			| dataitem
			;

dataitem_list		: dataitem
                          {
                                ArrayList dataitem_list = new ArrayList ();
                                dataitem_list.Add ($1);
                                $$ = dataitem_list;
                          }
			| dataitem_list COMMA dataitem
                          {
                                ArrayList list = (ArrayList) $1;
                                list.Add ($3);
                          }
			;

dataitem		: K_CHAR STAR OPEN_PARENS comp_qstring CLOSE_PARENS
                          {
                                $$ = new StringConst ((string) $4);
                          }
			| K_WCHAR STAR OPEN_PARENS comp_qstring CLOSE_PARENS
			  {
				$$ = new StringConst ((string) $4);
			  }
			| AMPERSAND OPEN_PARENS id CLOSE_PARENS
                          {
                           //     DataDef def = codegen.CurrentTypeDef.GetDataDef ((string) $3);
                           //     $$ = new AddressConstant ((DataConstant) def.PeapiConstant);
                          }
			| K_BYTEARRAY ASSIGN bytes_list
                          {
                                $$ = new ByteArrConst ((byte[]) $3);
                          }
			| K_BYTEARRAY bytes_list
                          {
                                // ******** THIS IS NOT IN THE SPECIFICATION ******** //
                                $$ = new ByteArrConst ((byte[]) $2);
                          }
			| K_FLOAT32 OPEN_PARENS float64 CLOSE_PARENS repeat_opt
                          {
                                double d = (double) $3;
                                FloatConst float_const = new FloatConst ((float) d);

                                if ($5 != null)
                                        $$ = new RepeatedConstant (float_const, (int) $5);
                                else
                                        $$ = float_const;
                          }
			| K_FLOAT64 OPEN_PARENS float64 CLOSE_PARENS repeat_opt
                          {
                                DoubleConst double_const = new DoubleConst ((double) $3);

                                if ($5 != null)
                                        $$ = new RepeatedConstant (double_const, (int) $5);
                                else
                                        $$ = double_const;
                          }
			| K_INT64 OPEN_PARENS int64 CLOSE_PARENS repeat_opt
                          {
                                IntConst int_const = new IntConst ((long) $3);

                                if ($5 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $5);
                                else
                                        $$ = int_const;
                          }
			| K_INT32 OPEN_PARENS int32 CLOSE_PARENS repeat_opt
                          {
                                IntConst int_const = new IntConst ((int) $3);

                                if ($5 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $5);
                                else
                                        $$ = int_const;
                          }
			| K_INT16 OPEN_PARENS int32 CLOSE_PARENS repeat_opt
                          {
                                int i = (int) $3;
                                IntConst int_const = new IntConst ((short) i);

                                if ($5 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $5);
                                else
                                        $$ = int_const;
                          }
			| K_INT8 OPEN_PARENS int32 CLOSE_PARENS repeat_opt
                          {
                                int i = (int) $3;
                                IntConst int_const = new IntConst ((sbyte) i);

                                if ($5 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $5);
                                else
                                        $$ = int_const;
                          }
			| K_FLOAT32 repeat_opt
                          {
                                FloatConst float_const = new FloatConst (0F);

                                if ($2 != null)
                                        $$ = new RepeatedConstant (float_const, (int) $2);
                                else
                                        $$ = float_const;
                          }
			| K_FLOAT64 repeat_opt
                          {
                                DoubleConst double_const = new DoubleConst (0);

                                if ($2 != null)
                                        $$ = new RepeatedConstant (double_const, (int) $2);
                                else
                                        $$ = double_const;
                          }
			| K_INT64 repeat_opt
                          {
                                IntConst int_const = new IntConst ((long) 0);

                                if ($2 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $2);
                                else
                                        $$ = int_const;
                          }
			| K_INT32 repeat_opt
                          {
                                IntConst int_const = new IntConst ((int) 0);

                                if ($2 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $2);
                                else
                                        $$ = int_const;
                          }
			| K_INT16 repeat_opt
                          {
                                IntConst int_const = new IntConst ((short) 0);

                                if ($2 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $2);
                                else
                                        $$ = int_const;
                          }
			| K_INT8 repeat_opt
                          {
                                IntConst int_const = new IntConst ((sbyte) 0);

                                if ($2 != null)
                                        $$ = new RepeatedConstant (int_const, (int) $2);
                                else
                                        $$ = int_const;
                          }
			;

method_all		: method_head OPEN_BRACE method_decls CLOSE_BRACE
                          {
                                codegen.EndMethodDef ();
                          }
			;

method_head		: D_METHOD meth_attr call_conv param_attr type method_name
                          formal_typars_clause OPEN_PARENS sig_args CLOSE_PARENS impl_attr
                          {
                                MethodDef methdef = new MethodDef ((MethAttr) $2, (CallConv) $3,
                                        (ImplAttr) $11, (string) $6, (ITypeRef) $5,
                                        (ArrayList) $9);
                                codegen.BeginMethodDef (methdef);

                                if (pinvoke_info) {
                                        ExternModule mod = codegen.ExternTable.AddModule (pinvoke_mod);
                                        methdef.AddPInvokeInfo (pinvoke_attr, mod, pinvoke_meth);
                                        pinvoke_info = false;
                                }

                                if ($7 != null) {
                                        ArrayList typars_list = (ArrayList) $7;
                                        foreach (string id in typars_list)
                                                methdef.AddGenericParam (id);
                                }
                          }
			| D_METHOD meth_attr call_conv param_attr type 
			  K_MARSHAL OPEN_PARENS native_type CLOSE_PARENS method_name
			  OPEN_PARENS sig_args CLOSE_PARENS impl_attr
			;

meth_attr		: /* EMPTY */                   { $$ = new MethAttr (); }
			| meth_attr K_STATIC            { $$ = (MethAttr) $1 | MethAttr.Static; }
			| meth_attr K_PUBLIC            { $$ = (MethAttr) $1 | MethAttr.Public; }
			| meth_attr K_PRIVATE           { $$ = (MethAttr) $1 | MethAttr.Private; }
			| meth_attr K_FAMILY            { $$ = (MethAttr) $1 | MethAttr.Family; }
			| meth_attr K_ASSEMBLY          { $$ = (MethAttr) $1 | MethAttr.Assembly; }
			| meth_attr K_FAMANDASSEM       { $$ = (MethAttr) $1 | MethAttr.FamAndAssem; } 
			| meth_attr K_FAMORASSEM        { $$ = (MethAttr) $1 | MethAttr.FamOrAssem; } 
			| meth_attr K_PRIVATESCOPE      { /* CHECK HEADERS */ }
			| meth_attr K_FINAL             { $$ = (MethAttr) $1 | MethAttr.Final; } 
			| meth_attr K_VIRTUAL           { $$ = (MethAttr) $1 | MethAttr.Virtual; }
			| meth_attr K_ABSTRACT          { $$ = (MethAttr) $1 | MethAttr.Abstract; }
			| meth_attr K_HIDEBYSIG         { $$ = (MethAttr) $1 | MethAttr.HideBySig; }
			| meth_attr K_NEWSLOT           { $$ = (MethAttr) $1 | MethAttr.NewSlot; }
			| meth_attr K_REQSECOBJ         { $$ = (MethAttr) $1 | MethAttr.RequireSecObject; }
			| meth_attr K_SPECIALNAME       { $$ = (MethAttr) $1 | MethAttr.SpecialName; }
			| meth_attr K_RTSPECIALNAME     { $$ = (MethAttr) $1 | MethAttr.RTSpecialName; }
                        | meth_attr K_COMPILERCONTROLLED { /* Do nothing */ }
			| meth_attr K_UNMANAGEDEXP      
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring K_AS
				comp_qstring pinv_attr CLOSE_PARENS
                          {
                                pinvoke_info = true;
                                pinvoke_mod = (string) $4;
                                pinvoke_meth = (string) $6;
                                pinvoke_attr = (PInvokeAttr) $7;
                          }
			| meth_attr K_PINVOKEIMPL OPEN_PARENS comp_qstring pinv_attr CLOSE_PARENS
                          {
                                pinvoke_info = true;
                                pinvoke_mod = (string) $4;
                                pinvoke_meth = null;
                                pinvoke_attr = (PInvokeAttr) $5;
                          }
			| meth_attr K_PINVOKEIMPL OPEN_PARENS pinv_attr CLOSE_PARENS
                          {
                                pinvoke_info = true;
                                pinvoke_mod = null;
                                pinvoke_meth = null;
                                pinvoke_attr = (PInvokeAttr) $4;
                          }
			;

pinv_attr		: /* EMPTY */ { $$ = new PInvokeAttr (); }
			| pinv_attr K_NOMANGLE { $$ = (PInvokeAttr) $1 | PInvokeAttr.nomangle; }
			| pinv_attr K_ANSI { $$ = (PInvokeAttr) $1 | PInvokeAttr.ansi; }
			| pinv_attr K_UNICODE { $$ = (PInvokeAttr) $1 | PInvokeAttr.unicode; }
			| pinv_attr K_AUTOCHAR { $$ = (PInvokeAttr) $1 | PInvokeAttr.autochar; }
			| pinv_attr K_LASTERR { $$ = (PInvokeAttr) $1 | PInvokeAttr.lasterr; }
			| pinv_attr K_WINAPI { $$ = (PInvokeAttr) $1 | PInvokeAttr.winapi; }
			| pinv_attr K_CDECL { $$ = (PInvokeAttr) $1 | PInvokeAttr.cdecl; }
			| pinv_attr K_STDCALL { $$ = (PInvokeAttr) $1 | PInvokeAttr.stdcall; }
			| pinv_attr K_THISCALL { $$ = (PInvokeAttr) $1 | PInvokeAttr.thiscall; }
			| pinv_attr K_FASTCALL { $$ = (PInvokeAttr) $1 | PInvokeAttr.fastcall; }
			;

method_name		: D_CTOR
			| D_CCTOR
			| comp_name
			;

param_attr		: /* EMPTY */                                   { $$ = new ParamAttr (); }
			| param_attr OPEN_BRACKET K_IN CLOSE_BRACKET    { $$ = (ParamAttr) $1 | ParamAttr.In; }
			| param_attr OPEN_BRACKET K_OUT CLOSE_BRACKET   { $$ = (ParamAttr) $1 | ParamAttr.Out; }
			| param_attr OPEN_BRACKET K_OPT CLOSE_BRACKET   { $$ = (ParamAttr) $1 | ParamAttr.Opt; }
			;

impl_attr		: /* EMPTY */                   { $$ = new ImplAttr (); }
			| impl_attr K_NATIVE            { $$ = (ImplAttr) $1 | ImplAttr.Native; }
			| impl_attr K_CIL               { $$ = (ImplAttr) $1 | ImplAttr.IL; }
                        | impl_attr K_IL                { $$ = (ImplAttr) $1 | ImplAttr.IL; }
			| impl_attr K_OPTIL             { $$ = (ImplAttr) $1 | ImplAttr.Optil; }
			| impl_attr K_MANAGED           { /* should this reset? */ }
			| impl_attr K_UNMANAGED         { $$ = (ImplAttr) $1 | ImplAttr.Unmanaged; }
			| impl_attr K_FORWARDREF        { $$ = (ImplAttr) $1 | ImplAttr.ForwardRef; }
			| impl_attr K_PRESERVESIG       { $$ = (ImplAttr) $1 | ImplAttr.PreserveSig; }
			| impl_attr K_RUNTIME           { $$ = (ImplAttr) $1 | ImplAttr.Runtime; }
			| impl_attr K_INTERNALCALL      { $$ = (ImplAttr) $1 | ImplAttr.InternalCall; }
			| impl_attr K_SYNCHRONIZED      { $$ = (ImplAttr) $1 | ImplAttr.Synchronised; }
			| impl_attr K_NOINLINING        { $$ = (ImplAttr) $1 | ImplAttr.NoInLining; }
			;

sig_args		: /* EMPTY */
			| sig_arg_list
			;

sig_arg_list 		: sig_arg
                          {
                                ArrayList sig_list = new ArrayList ();
                                sig_list.Add ($1);
                                $$ = sig_list;
                          }
			| sig_arg_list COMMA sig_arg
                          {
                                ArrayList sig_list = (ArrayList) $1;
                                sig_list.Add ($3);
                                $$ = sig_list;
                          }
			;

sig_arg			: param_attr type
                          {
                                $$ = new ParamDef ((ParamAttr) $1, null, (ITypeRef) $2);
                          }
			| param_attr type id
                          {
                                $$ = new ParamDef ((ParamAttr) $1, (string) $3, (ITypeRef) $2);
                          }
                        | ELLIPSIS
                          {
				$$ = new ParamDef ((ParamAttr) 0, "...", new SentinelTypeRef ());
                                // $$ = ParamDef.Ellipsis;
                          }
			| param_attr type K_MARSHAL OPEN_PARENS native_type CLOSE_PARENS
			| param_attr type K_MARSHAL OPEN_PARENS native_type CLOSE_PARENS id
			;

type_list               : /* EMPTY */
                          {
                                $$ = new ArrayList (0);
                          }
                        | ELLIPSIS
                          {
                                ArrayList type_list = new ArrayList ();
                                // type_list.Add (TypeRef.Ellipsis);
				type_list.Add (new SentinelTypeRef ());
                                $$ = type_list;
                          }
                        | type_list COMMA ELLIPSIS
                          {
                                ArrayList type_list = (ArrayList) $1;
                                // type_list.Add (TypeRef.Ellipsis);
				type_list.Add (new SentinelTypeRef ());
				$$ = type_list;
                          }
                        | param_attr type opt_id
                          {
                                ArrayList type_list = new ArrayList ();
                                type_list.Add ($2);
                                $$ = type_list;
                          }
                        | type_list COMMA param_attr type opt_id
                          {
                                ArrayList type_list = (ArrayList) $1;
                                type_list.Add ($4);
                          }
                        ;

opt_id                  : /* EMPTY */
                        | id
                        ;

method_decls		: /* EMPTY */
			| method_decls method_decl
			;

method_decl		: D_EMITBYTE int32
			| D_MAXSTACK int32
                          {
                                codegen.CurrentMethodDef.SetMaxStack ((int) $2);
                          }
			| D_LOCALS OPEN_PARENS local_list CLOSE_PARENS
                          {
                                if ($3 != null) {
                                        codegen.CurrentMethodDef.AddLocals (
                                                (ArrayList) $3);
                                }
                          }
			| D_LOCALS K_INIT OPEN_PARENS local_list CLOSE_PARENS
                          {
                                if ($4 != null) {
                                        codegen.CurrentMethodDef.AddLocals (
                                                (ArrayList) $4);
                                        codegen.CurrentMethodDef.InitLocals ();
                                }
                          }
			| D_ENTRYPOINT
                          {
                                codegen.CurrentMethodDef.EntryPoint ();
                          }
			| D_ZEROINIT
                          {
                                codegen.CurrentMethodDef.ZeroInit ();
                          }
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET
			| D_EXPORT OPEN_BRACKET int32 CLOSE_BRACKET K_AS id
			| D_VTENTRY int32 COLON int32 
			| D_OVERRIDE type_spec DOUBLE_COLON method_name
                          {
                                codegen.CurrentTypeDef.AddOverride (codegen.CurrentMethodDef,
                                        (ITypeRef) $2, (string) $4);
                                
                          }
			| scope_block
			| D_PARAM OPEN_BRACKET int32 CLOSE_BRACKET init_opt
			| id COLON
                          {
                                codegen.CurrentMethodDef.AddLabel ((string) $1);
                          }
			| seh_block
			| instr
			| sec_decl
			| extsource_spec
			| language_decl
			| customattr_decl
                          {
                                codegen.CurrentMethodDef.AddCustomAttr ((CustomAttr) $1);
                          }
			| data_decl
			;

local_list              : /* EMPTY */
                        | local
                          {
                                ArrayList local_list = new ArrayList ();
                                local_list.Add ($1);
                                $$ = local_list;
                          }
                        | local_list COMMA local
                          {
                                ArrayList local_list = (ArrayList) $1;
                                local_list.Add ($3);
                          }
                        ;

local                   : type
                          {
                                $$ = new Local (-1, (ITypeRef) $1);
                          }
                        | type id
                          {
                                $$ = new Local (-1, (string) $2, (ITypeRef) $1);
                          }
                        | slot_num type
                          {
                                $$ = new Local ((int) $1, (ITypeRef) $2);
                          }
                        | slot_num type id
                          {
                                $$ = new Local ((int) $1, (string) $3, (ITypeRef) $2);
                          }
                        ;

slot_num                : OPEN_BRACKET int32 CLOSE_BRACKET
                          {
                                $$ = $2;
                          }
                        ;

type_spec		: class_ref
			| OPEN_BRACKET slashed_name CLOSE_BRACKET
                          {
                                // This is a reference to a global method in another
                                // assembly. This is not supported in the MS version of ilasm
                          }
			| OPEN_BRACKET D_MODULE slashed_name CLOSE_BRACKET
                          {
                                string module = (string) $3;

                                if (codegen.IsThisModule (module)) {
                                    // This is not handled yet.
                                } else {
                                    $$ = codegen.ExternTable.GetModuleTypeRef ((string) $3, "<Module>", false);
                                }

                          }
			| type
			;

scope_block		: scope_block_begin method_decls CLOSE_BRACE
                          {
                                $$ = new HandlerBlock ((LabelInfo) $1,
                                        codegen.CurrentMethodDef.AddLabel ());
                          }
			;

scope_block_begin       : OPEN_BRACE
                          {
                                $$ = codegen.CurrentMethodDef.AddLabel ();
                          }
                        ;
                        
                        
seh_block		: try_block seh_clauses
                          {
                                TryBlock try_block = (TryBlock) $1;

                                ArrayList clause_list = (ArrayList) $2;
                                foreach (object clause in clause_list)
                                        try_block.AddSehClause ((ISehClause) clause);

                                codegen.CurrentMethodDef.AddInstr (try_block);
                          }
			;

try_block		: D_TRY scope_block
                          {
                                $$ = new TryBlock ((HandlerBlock) $2);
                          }
			| D_TRY id K_TO id
                          {
				LabelInfo from = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabelRef ((string) $4);
				
                                $$ = new TryBlock (new HandlerBlock (from, to));
                          }
			| D_TRY int32 K_TO int32
			  {
				LabelInfo from = codegen.CurrentMethodDef.AddLabel ((int) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabel ((int) $4);
				
				$$ = new TryBlock (new HandlerBlock (from, to));
			  }
			;

seh_clauses		: seh_clause
                          {
                                ArrayList clause_list = new ArrayList ();
                                clause_list.Add ($1);
                                $$ = clause_list;
                          }
			| seh_clauses seh_clause
                          {
                                ArrayList clause_list = (ArrayList) $1;
                                clause_list.Add ($2);
                          }
			;

seh_clause		: K_CATCH class_ref handler_block
                          {
                                IClassRef type = (IClassRef) $2;
                                CatchBlock cb = new CatchBlock (type);
                                cb.SetHandlerBlock ((HandlerBlock) $3);
                                $$ = cb;
                          }
			| K_FINALLY handler_block
                          {
                                FinallyBlock fb = new FinallyBlock ();
                                fb.SetHandlerBlock ((HandlerBlock) $2);
                                $$ = fb;
                          }
			| K_FAULT handler_block
                          {
                                FaultBlock fb = new FaultBlock ();
                                fb.SetHandlerBlock ((HandlerBlock) $2);
                                $$ = fb;
                          }
			| filter_clause handler_block
                          {
                                FilterBlock fb = (FilterBlock) $1;
                                fb.SetHandlerBlock ((HandlerBlock) $2);
                          }
			;

filter_clause		: K_FILTER scope_block
                          {
                                HandlerBlock block = (HandlerBlock) $2;
                                FilterBlock fb = new FilterBlock (block);
                                $$ = fb;
                          }
			| K_FILTER id
                          {
				LabelInfo from = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
                                FilterBlock fb = new FilterBlock (new HandlerBlock (from, null));
                                $$ = fb;
                          }
			| K_FILTER int32
			  {
				LabelInfo from = codegen.CurrentMethodDef.AddLabel ((int) $2);
				FilterBlock fb = new FilterBlock (new HandlerBlock (from, null));
				$$ = fb;
			  }
			;

handler_block		: scope_block
                          {
                                
                          }
			| K_HANDLER id K_TO id
                          {	
				LabelInfo from = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabelRef ((string) $4);

                                $$ = new HandlerBlock (from, to);
                          }
			| K_HANDLER int32 K_TO int32
			  {
				LabelInfo from = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
				LabelInfo to = codegen.CurrentMethodDef.AddLabelRef ((string) $4);

				$$ = new HandlerBlock (from, to);
			  }
			;

instr			: INSTR_NONE
                          {
                                codegen.CurrentMethodDef.AddInstr (
                                        new SimpInstr ((Op) $1));
                          }
			| INSTR_LOCAL int32
                          {
                                codegen.CurrentMethodDef.AddInstr (
                                        new IntInstr ((IntOp) $1, (int) $2));        
                          }
                        | INSTR_LOCAL id
                          {
                                int slot = codegen.CurrentMethodDef.GetNamedLocalSlot ((string) $2);
                                codegen.CurrentMethodDef.AddInstr (
                                        new IntInstr ((IntOp) $1, slot));
                          }
                        | INSTR_PARAM int32
                          {
                                codegen.CurrentMethodDef.AddInstr (
                                        new IntInstr ((IntOp) $1, (int) $2));
                          }
                        | INSTR_PARAM id
                          {
                                int pos = codegen.CurrentMethodDef.GetNamedParamPos ((string) $2);
                                codegen.CurrentMethodDef.AddInstr (
                                        new IntInstr ((IntOp) $1, pos));
                          }
			| INSTR_I int32
                          {
                                codegen.CurrentMethodDef.AddInstr (new
                                        IntInstr ((IntOp) $1, (int) $2));
                          }
			| INSTR_I id
                          {
                                int slot = codegen.CurrentMethodDef.GetNamedLocalSlot ((string) $2);
                                codegen.CurrentMethodDef.AddInstr (new
                                        IntInstr ((IntOp) $1, slot));
                          }
			| INSTR_I8 int64
                          {
                                if ($1 is MiscInstr) {
                                        switch ((MiscInstr) $1) {
                                        case MiscInstr.ldc_i8:
                                        codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1,
                                                (long) $2));
                                        break;
                                        }
                                }
                          }
			| INSTR_R float64
                          {
                                switch ((MiscInstr) $1) {
                                case MiscInstr.ldc_r4:
                                case MiscInstr.ldc_r8:
                                         codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1, (double) $2));
                                         break;
                                }
                          }
			| INSTR_R int64
                          {
                                long l = (long) $2;
                                
                                switch ((MiscInstr) $1) {
                                        case MiscInstr.ldc_r4:
                                        case MiscInstr.ldc_r8:
                                        codegen.CurrentMethodDef.AddInstr (new LdcInstr ((MiscInstr) $1, (double) l));
                                        break;
                                }
                          }
			| INSTR_R bytes_list
			| INSTR_BRTARGET int32
                          {
				LabelInfo target = codegen.CurrentMethodDef.AddLabel ((int) $2);
                                codegen.CurrentMethodDef.AddInstr (new BranchInstr ((BranchOp) $1,
								   target));  
                          }
			| INSTR_BRTARGET id
                          {
				LabelInfo target = codegen.CurrentMethodDef.AddLabelRef ((string) $2);
                                codegen.CurrentMethodDef.AddInstr (new BranchInstr ((BranchOp) $1,
                                        			   target));
                          }
			| INSTR_METHOD method_ref
                          {
                                codegen.CurrentMethodDef.AddInstr (new MethodInstr ((MethodOp) $1,
                                        (IMethodRef) $2));
                          }
			| INSTR_FIELD type type_spec DOUBLE_COLON id
                          {
                                
                                ITypeRef owner = (ITypeRef) $3;
                                IFieldRef fieldref = owner.GetFieldRef (
                                        (ITypeRef) $2, (string) $5);

                                codegen.CurrentMethodDef.AddInstr (new FieldInstr ((FieldOp) $1, fieldref));
                          }
			| INSTR_FIELD type id
                          {
                                GlobalFieldRef fieldref = new GlobalFieldRef ((ITypeRef) $2, (string) $3);

                                codegen.CurrentMethodDef.AddInstr (new FieldInstr ((FieldOp) $1, fieldref));
                          }
			| INSTR_TYPE type_spec
                          {
                                codegen.CurrentMethodDef.AddInstr (new TypeInstr ((TypeOp) $1,
                                        (ITypeRef) $2));
                          }
			| INSTR_STRING comp_qstring
                          {
                                if ((MiscInstr) $1 == MiscInstr.ldstr)
                                        codegen.CurrentMethodDef.AddInstr (new LdstrInstr ((string) $2));
                          }
			| INSTR_STRING K_BYTEARRAY ASSIGN bytes_list
                          {
                                byte[] bs = (byte[]) $4;
                                if ((MiscInstr) $1 == MiscInstr.ldstr)
                                        codegen.CurrentMethodDef.AddInstr (new LdstrInstr (bs));
                          }
			| INSTR_STRING K_BYTEARRAY bytes_list
                          {
                                byte[] bs = (byte[]) $3;
                                if ((MiscInstr) $1 == MiscInstr.ldstr)
                                        codegen.CurrentMethodDef.AddInstr (new LdstrInstr (bs));
                          }
			| INSTR_SIG call_conv type OPEN_PARENS type_list CLOSE_PARENS
                          {
                                ArrayList arg_list = (ArrayList) $5;
                                ITypeRef[] arg_array = null;

                                if (arg_list != null)
                                        arg_array = (ITypeRef[]) arg_list.ToArray (typeof (ITypeRef));

                                codegen.CurrentMethodDef.AddInstr (new CalliInstr ((CallConv) $2,
                                        (ITypeRef) $3, arg_array));
                          }     
			| INSTR_TOK owner_type
                          {
                                if ((MiscInstr) $1 == MiscInstr.ldtoken) {
                                        if ($2 is IMethodRef)
                                                codegen.CurrentMethodDef.AddInstr (new LdtokenInstr ((IMethodRef) $2));
                                        else if ($2 is IFieldRef)
                                                codegen.CurrentMethodDef.AddInstr (new LdtokenInstr ((IFieldRef) $2));
                                        else
                                                codegen.CurrentMethodDef.AddInstr (new LdtokenInstr ((ITypeRef) $2));
                                                
                                }
                          }
			| INSTR_SWITCH OPEN_PARENS labels CLOSE_PARENS
                          {
                                codegen.CurrentMethodDef.AddInstr (new SwitchInstr ((ArrayList) $3));
                          }
			;

method_ref		: call_conv type type_spec DOUBLE_COLON method_name
                          OPEN_PARENS type_list CLOSE_PARENS 
                          {
                                ITypeRef owner = (ITypeRef) $3;
                                ArrayList arg_list = (ArrayList) $7;
                                ITypeRef[] param_list;
                                IMethodRef methref;

                                if (arg_list != null)
                                        param_list = (ITypeRef[]) arg_list.ToArray (typeof (ITypeRef));
                                else
                                        param_list = new ITypeRef[0];

                                if (owner.UseTypeSpec) {
                                        methref = new TypeSpecMethodRef (owner, (ITypeRef) $2,
                                                (CallConv) $1, (string) $5, param_list);
                                } else {
                                        methref = owner.GetMethodRef ((ITypeRef) $2,
                                                (CallConv) $1, (string) $5, param_list);
                                }

                                $$ = methref;
                          }
			| call_conv type method_name 
			  OPEN_PARENS type_list CLOSE_PARENS
                          {
                                ArrayList arg_list = (ArrayList) $5;
                                ITypeRef[] param_list;
  
                                if (arg_list != null)
                                        param_list = (ITypeRef[]) arg_list.ToArray (typeof (ITypeRef));
                                else
                                        param_list = new ITypeRef[0];

                                $$ = new GlobalMethodRef ((ITypeRef) $2, (CallConv) $1,
                                        (string) $3, param_list);
                          }
                        | call_conv type type_spec DOUBLE_COLON method_name
                          typars_clause OPEN_PARENS type_list CLOSE_PARENS 
                          {
                                ITypeRef owner = (ITypeRef) $3;
                                ArrayList arg_list = (ArrayList) $8;
                                ITypeRef[] param_list;
                                IMethodRef methref;

                                if (arg_list != null)
                                        param_list = (ITypeRef[]) arg_list.ToArray (typeof (ITypeRef));
                                else
                                        param_list = new ITypeRef[0];

                                if (owner.UseTypeSpec) {
                                        methref = new TypeSpecMethodRef (owner, (ITypeRef) $2,
                                                (CallConv) $1, (string) $5, param_list);
                                } else {
                                        methref = owner.GetMethodRef ((ITypeRef) $2,
                                                (CallConv) $1, (string) $5, param_list);
                                }

                                if ($6 != null) {
                                        ArrayList tp = (ArrayList) $6;
                                        ITypeRef[] ta = (ITypeRef[]) tp.ToArray (typeof (ITypeRef));
                                        
                                        methref = new GenericMethodRef (methref, new GenericMethodSig (ta));
                                }
                                
                                $$ = methref;
                          }
			;

labels			: /* EMPTY */
			| id
                          {
                                ArrayList label_list = new ArrayList ();
                                label_list.Add ($1);
                                $$ = label_list;
                          }
			| int32
                          {
                                ArrayList label_list = new ArrayList ();
                                label_list.Add ($1);
                                $$ = label_list;
                          }
			| labels COMMA id
                          {
                                ArrayList label_list = (ArrayList) $1;
                                label_list.Add ($3);
                          }
			| labels COMMA int32
                          {
                                ArrayList label_list = (ArrayList) $1;
                                label_list.Add ($3);
                          }
			;

owner_type		: type_spec
			| member_ref
			;

member_ref		: K_METHOD method_ref
                          {
                                $$ = $2;
                          }
			| K_FIELD type type_spec DOUBLE_COLON id
                          {
                                ITypeRef owner = (ITypeRef) $3;

                                $$ = owner.GetFieldRef (
                                        (ITypeRef) $2, (string) $5);
                          }
			| K_FIELD type id
                          {
                                $$ = new GlobalFieldRef ((ITypeRef) $2, (string) $3);
                          }
			;

event_all		: event_head OPEN_BRACE event_decls CLOSE_BRACE
                          {
                                codegen.CurrentTypeDef.EndEventDef ();
                          }
			;

event_head		: D_EVENT event_attr type_spec id
                          {
                                EventDef event_def = new EventDef ((FeatureAttr) $2,
                                        (ITypeRef) $3, (string) $4);
                                codegen.CurrentTypeDef.BeginEventDef (event_def);
                          }
			| D_EVENT event_attr id
			;

event_attr		: /* EMPTY */
                          {
                                $$ = new FeatureAttr ();
                          }
			| event_attr K_RTSPECIALNAME
                          {
                                $$ = (FeatureAttr) $1 & FeatureAttr.Rtspecialname;
                          }
			| event_attr K_SPECIALNAME
                          {
                                $$ = (FeatureAttr) $1 & FeatureAttr.Specialname;
                          }
			;

event_decls		: /* EMPTY */
			| event_decls event_decl
			;

event_decl		: D_ADDON method_ref
                          {
                                codegen.CurrentTypeDef.CurrentEvent.AddAddon (
                                        (MethodRef) $2);                                
                          }
			| D_REMOVEON method_ref
                          {
                                codegen.CurrentTypeDef.CurrentEvent.AddRemoveon (
                                        (MethodRef) $2);
                          }
			| D_FIRE method_ref
                          {
                                codegen.CurrentTypeDef.CurrentEvent.AddFire (
                                        (MethodRef) $2);
                          }
			| D_OTHER method_ref
                          {
                                codegen.CurrentTypeDef.CurrentEvent.AddOther (
                                        (MethodRef) $2);
                          }
			| customattr_decl
			| extsource_spec
			| language_decl
			;

prop_all		: prop_head OPEN_BRACE prop_decls CLOSE_BRACE
                          {
                                codegen.CurrentTypeDef.EndPropertyDef ();
                          }
			;

prop_head		: D_PROPERTY prop_attr type id OPEN_PARENS type_list CLOSE_PARENS init_opt
                          {
                                PropertyDef prop_def = new PropertyDef ((FeatureAttr) $2, (ITypeRef) $3,
                                        (string) $4, (ArrayList) $6);
                                codegen.CurrentTypeDef.BeginPropertyDef (prop_def);

                                if ($8 != null) {
                                        prop_def.AddInitValue ((Constant) $8);
                                }
                          }
			;

prop_attr 		: /* EMPTY */
                          {
                                $$ = new FeatureAttr ();
                          }
			| prop_attr K_RTSPECIALNAME
                          {
                                $$ = (FeatureAttr) $1 | FeatureAttr.Rtspecialname;
                          }
			| prop_attr K_SPECIALNAME
                          {
                                $$ = (FeatureAttr) $1 | FeatureAttr.Specialname;
                          }
                        | prop_attr K_INSTANCE
                          {
                          }
			;

prop_decls		: /* EMPTY */
			| prop_decls prop_decl
			;

prop_decl		: D_SET method_ref
                          {
                                codegen.CurrentTypeDef.CurrentProperty.AddSet ((MethodRef) $2);
                          }
			| D_GET method_ref
                          {
                                codegen.CurrentTypeDef.CurrentProperty.AddGet ((MethodRef) $2);
                          }
			| D_OTHER method_ref
                          {
                                codegen.CurrentTypeDef.CurrentProperty.AddOther ((MethodRef) $2);
                          }
			| customattr_decl
			| extsource_spec
			| language_decl
			;

customattr_decl		: D_CUSTOM custom_type
                          {
                                $$ = new CustomAttr ((IMethodRef) $2, null);
                          }
			| D_CUSTOM custom_type ASSIGN comp_qstring
			| D_CUSTOM custom_type ASSIGN bytes_list
                          {
                                $$ = new CustomAttr ((IMethodRef) $2,
                                        (byte[]) $4);
                          }
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS custom_type
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS custom_type ASSIGN comp_qstring
			| D_CUSTOM OPEN_PARENS owner_type CLOSE_PARENS custom_type ASSIGN
			  bytes_list
			;
			
custom_type		: call_conv type type_spec DOUBLE_COLON D_CTOR OPEN_PARENS type_list CLOSE_PARENS
                          {
                                ITypeRef owner = (ITypeRef) $3;
                                ArrayList arg_list = (ArrayList) $7;
                                ITypeRef[] param_list;
  
                                if (arg_list != null)
                                        param_list = (ITypeRef[]) arg_list.ToArray (typeof (ITypeRef));
                                else
                                        param_list = new ITypeRef[0];

                                $$ = owner.GetMethodRef ((ITypeRef) $2,
                                        (CallConv) $1, (string) $5, param_list);
                          }
			| call_conv type D_CTOR OPEN_PARENS type_list CLOSE_PARENS
                          {
                                ArrayList arg_list = (ArrayList) $5;
                                ITypeRef[] param_list;
  
                                if (arg_list != null)
                                        param_list = (ITypeRef[]) arg_list.ToArray (typeof (ITypeRef));
                                else
                                        param_list = new ITypeRef[0];

                                $$ = new GlobalMethodRef ((ITypeRef) $2, (CallConv) $1,
                                        (string) $3, param_list);
                          }
			;

sec_decl		: D_PERMISSION sec_action type_spec OPEN_PARENS nameval_pairs CLOSE_PARENS
			| D_PERMISSION sec_action type_spec
			| D_PERMISSIONSET sec_action ASSIGN bytes_list
			;

nameval_pairs		: nameval_pair 
			| nameval_pairs COMMA nameval_pair
			;

nameval_pair 		: comp_qstring ASSIGN cavalue
			;

cavalue 		: truefalse
			| int32
			| int32 OPEN_PARENS int32 CLOSE_PARENS
			| comp_qstring 
			| class_ref OPEN_PARENS K_INT8 COLON int32 CLOSE_PARENS
			| class_ref OPEN_PARENS K_INT16 COLON int32 CLOSE_PARENS
			| class_ref OPEN_PARENS K_INT32 COLON int32 CLOSE_PARENS
			| class_ref OPEN_PARENS int32 CLOSE_PARENS
			;

sec_action		: K_REQUEST
			| K_DEMAND
			| K_ASSERT
			| K_DENY
			| K_PERMITONLY
			| K_LINKCHECK
			| K_INHERITCHECK
			| K_REQMIN
			| K_REQOPT
			| K_REQREFUSE
			| K_PREJITGRANT
			| K_PREJITDENY
			| K_NONCASDEMAND
			| K_NONCASLINKDEMAND
			| K_NONCASINHERITANCE
			;

module_head		: D_MODULE
                          {
                          }
			| D_MODULE comp_name
                          {
                                codegen.SetModuleName ((string) $2);
                          }
			| D_MODULE K_EXTERN comp_name
                          {
                                codegen.ExternTable.AddModule ((string) $3);                         
                          }
			;

file_decl		: D_FILE file_attr comp_name file_entry D_HASH ASSIGN
			  bytes_list file_entry
                          {
                                codegen.SetFileRef (new FileRef ((string) $3, (byte []) $7, (bool) $2, (bool) $8)); 
                          }
			| D_FILE file_attr comp_name file_entry
                          {
                                // We need to compute the hash ourselves. :-(
                                // AssemblyName an = AssemblyName.GetName ((string) $3);
                          }
			;

file_attr 		: /* EMPTY */
                          {
                                $$ = true;
                          }
			| file_attr K_NOMETADATA
                          {
                                $$ = false;
                          }
			;

file_entry		: /* EMPTY */
                          {
                                $$ = false;
                          }
			| D_ENTRYPOINT
                          {
                                $$ = true;
                          }
			;

assembly_all		: assembly_head OPEN_BRACE assembly_decls CLOSE_BRACE
			;

assembly_head		: D_ASSEMBLY asm_attr slashed_name
                          {
                                codegen.SetAssemblyName ((string) $3);
                          }
			;

asm_attr		: /* EMPTY */
			| asm_attr K_NOAPPDOMAIN
			| asm_attr K_NOPROCESS
			| asm_attr K_NOMACHINE
			;

assembly_decls		: /* EMPTY */
			| assembly_decls assembly_decl
			;

assembly_decl		: D_PUBLICKEY ASSIGN bytes_list
			  {
				codegen.SetAssemblyPublicKey ((byte []) $3);
			  }
			| D_VER int32 COLON int32 COLON int32 COLON int32
			  {
				codegen.SetAssemblyVersion ((int) $2, (int) $4, (int) $6, (int) $8);
			  }
			| D_LOCALE comp_qstring
			  {
				codegen.SetAssemblyLocale ((string) $2);
			  }
			| D_LOCALE ASSIGN bytes_list
			| D_HASH K_ALGORITHM int32
			  {
				codegen.SetAssemblyHashAlgorithm ((int) $3);
			  }
			| customattr_decl
			  {
				codegen.AddAssemblyCustomAttribute ((CustomAttr) $1);
			  }
			| sec_decl
			;

asm_or_ref_decl		: D_PUBLICKEY ASSIGN bytes_list
			| D_VER int32 COLON int32 COLON int32 COLON int32 
			| D_LOCALE comp_qstring
			| D_LOCALE ASSIGN bytes_list
			| customattr_decl
			;

assemblyref_all		: assemblyref_head OPEN_BRACE assemblyref_decls CLOSE_BRACE
			;

assemblyref_head	: D_ASSEMBLY K_EXTERN slashed_name
                          {
                                System.Reflection.AssemblyName asmb_name = 
					new System.Reflection.AssemblyName ();
				asmb_name.Name = (string) $3;
				codegen.BeginAssemblyRef ((string) $3, asmb_name);
                          }
			| D_ASSEMBLY K_EXTERN slashed_name K_AS slashed_name
                          {
                                System.Reflection.AssemblyName asmb_name = 
					new System.Reflection.AssemblyName ();
				asmb_name.Name = (string) $3;
				codegen.BeginAssemblyRef ((string) $5, asmb_name);
                          }
			;

assemblyref_decls	: /* EMPTY */
			| assemblyref_decls assemblyref_decl
			;

assemblyref_decl	: D_VER int32 COLON int32 COLON int32 COLON int32
                          {
                                codegen.CurrentAssemblyRef.SetVersion ((int) $2, (int) $4, (int) $6, (int) $8);
                          }
                        | D_PUBLICKEY ASSIGN bytes_list
                          {
                                codegen.CurrentAssemblyRef.SetPublicKey ((byte []) $3);
                          }
                        | D_PUBLICKEYTOKEN ASSIGN bytes_list
                          {
                                codegen.CurrentAssemblyRef.SetPublicKeyToken ((byte []) $3);
                          }
			| D_LOCALE comp_qstring
                          {
                                codegen.CurrentAssemblyRef.SetLocale ((string) $2);
                          }
			| D_LOCALE ASSIGN bytes_list
			
                        | D_HASH ASSIGN bytes_list
                          {
                                codegen.CurrentAssemblyRef.SetHash ((byte []) $3);
                          }
                        | customattr_decl
                          {
                                codegen.CurrentAssemblyRef.AddCustomAttribute ((CustomAttr) $1);
                          }
			;

exptype_all		: exptype_head OPEN_BRACE exptype_decls CLOSE_BRACE
			;

exptype_head		: D_CLASS K_EXTERN expt_attr comp_name
			;

expt_attr 		: /* EMPTY */
			| expt_attr K_PRIVATE
			| expt_attr K_PUBLIC 
			| expt_attr K_NESTED K_PUBLIC
			| expt_attr K_NESTED K_PRIVATE
			| expt_attr K_NESTED K_FAMILY
			| expt_attr K_NESTED K_ASSEMBLY
			| expt_attr K_NESTED K_FAMANDASSEM
			| expt_attr K_NESTED K_FAMORASSEM
			;

exptype_decls		: /* EMPTY */
			| exptype_decls exptype_decl
			;

exptype_decl		: D_FILE comp_name
			| D_CLASS K_EXTERN comp_name
			| D_CLASS int32
			| customattr_decl
			;

manifestres_all		: manifestres_head OPEN_BRACE manifestres_decls CLOSE_BRACE
			;

manifestres_head	: D_MRESOURCE manres_attr comp_name	
			;

manres_attr		: /* EMPTY */
			| manres_attr K_PUBLIC
			| manres_attr K_PRIVATE
			;

manifestres_decls	: /* EMPTY */
			| manifestres_decls manifestres_decl
			;

manifestres_decl	: D_FILE comp_name K_AT int32
			| D_ASSEMBLY K_EXTERN slashed_name
			| customattr_decl
			;

comp_qstring		: QSTRING
			| comp_qstring PLUS QSTRING 	{ $$ = String.Format ("{0}{1}", $1, $3); }
			;

int32			: INT64
                          {
                                long l = (long) $1;
                                byte[] intb = BitConverter.GetBytes (l);
                                $$ = BitConverter.ToInt32 (intb, BitConverter.IsLittleEndian ? 0 : 4);
                          }
			;

int64		        : INT64
			;

float64			: FLOAT64
			| K_FLOAT32 OPEN_PARENS INT32 CLOSE_PARENS
                          {
                                int i = (int) $3;
                                byte[] intb = BitConverter.GetBytes (i);
                                $$ = (double) BitConverter.ToSingle (intb, BitConverter.IsLittleEndian ? 0 : 4);
                          }
                        | K_FLOAT32 OPEN_PARENS INT64 CLOSE_PARENS
                          {
                                long l = (long) $3;
                                byte[] intb = BitConverter.GetBytes (l);
                                $$ = (double) BitConverter.ToSingle (intb, BitConverter.IsLittleEndian ? 0 : 4);
                          }
			| K_FLOAT64 OPEN_PARENS INT64 CLOSE_PARENS
                          {
                                byte[] intb = BitConverter.GetBytes ((long) $3);
				$$ = BitConverter.ToDouble (intb, BitConverter.IsLittleEndian ? 0 : 4);
                          }
                        | K_FLOAT64 OPEN_PARENS INT32 CLOSE_PARENS
                          {
                                byte[] intb = BitConverter.GetBytes ((int) $3);
                                $$ = (double) BitConverter.ToSingle (intb, BitConverter.IsLittleEndian ? 0 : 4);
                          }
			;

hexbyte			: HEXBYTE       { }
			;

bytes_list              : OPEN_PARENS
                          {
                                tokenizer.InByteArray = true;
                          }
                          bytes CLOSE_PARENS
                          {
                                $$ = $3;
                                tokenizer.InByteArray = false;
                          }
                        ;

bytes 			: /* EMPTY */   { $$ = new byte[0]; }
			| hexbytes
                          {
                                ArrayList byte_list = (ArrayList) $1;
                                $$ = byte_list.ToArray (typeof (byte));
                          }
			;

hexbytes		: hexbyte
                          {
                                ArrayList byte_list = new ArrayList ();
                                byte_list.Add (Convert.ToByte ($1));
                                $$ = byte_list;
                          }
			| hexbytes hexbyte
                          {
                                ArrayList byte_list = (ArrayList) $1;
                                byte_list.Add (Convert.ToByte ($2));
                          }
			;

truefalse		: K_TRUE
                          {
                                $$ = true;
                          }
			| K_FALSE
                          {
                                $$ = false;
                          }
			;

id			: ID
			| SQSTRING
			;

comp_name		: id
			| comp_name DOT id
                          {
                                $$ = (string) $1 + '.' + (string) $3;
                          }
                        | COMP_NAME
			;

%%

}

