Index: generic.cs
===================================================================
--- generic.cs	(revision 62902)
+++ generic.cs	(working copy)
@@ -2622,7 +2622,7 @@
 
 				Argument a = (Argument) arguments [i];
 				if ((a.Expr is NullLiteral) || (a.Expr is MethodGroupExpr) ||
-				    (a.Expr is AnonymousMethod))
+				    (a.Expr is AnonymousMethodExpression))
 					continue;
 
 				arg_types [i] = a.Type;
Index: rootcontext.cs
===================================================================
--- rootcontext.cs	(revision 62902)
+++ rootcontext.cs	(working copy)
@@ -523,6 +523,14 @@
 		{
 			TypeContainer root = Tree.Types;
 
+			ArrayList delegates = root.Delegates;
+			if (delegates != null){
+				foreach (Delegate d in delegates)
+					d.DefineMembers ();
+				foreach (Delegate d in delegates)
+					d.Define ();
+			}
+
 			if (type_container_resolve_order != null){
 				foreach (TypeContainer tc in type_container_resolve_order)
 					tc.ResolveType ();
@@ -530,12 +538,6 @@
 					tc.DefineMembers ();
 			}
 
-			ArrayList delegates = root.Delegates;
-			if (delegates != null){
-				foreach (Delegate d in delegates)
-					d.DefineMembers ();
-			}
-
 			ArrayList enums = root.Enums;
 			if (enums != null){
 				foreach (Enum en in enums)
@@ -569,12 +571,6 @@
 		{
 			TypeContainer root = Tree.Types;
 
-			ArrayList delegates = root.Delegates;
-			if (delegates != null){
-				foreach (Delegate d in delegates)
-					d.Define ();
-			}
-
 			if (type_container_resolve_order != null){
 				foreach (TypeContainer tc in type_container_resolve_order) {
 					// When compiling corlib, these types have already been
Index: class.cs
===================================================================
--- class.cs	(revision 62902)
+++ class.cs	(working copy)
@@ -429,8 +429,8 @@
 		// Holds the operators
 		MemberCoreArrayList operators;
 
-		// Holds the iterators
-		ArrayList iterators;
+		// Holds the compiler generated classes
+		ArrayList compiler_generated;
 
 		//
 		// Pointers to the default constructor and the default static constructor
@@ -774,12 +774,12 @@
 			operators.Add (op);
 		}
 
-		public void AddIterator (Iterator i)
+		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
-			if (iterators == null)
-				iterators = new ArrayList ();
+			if (compiler_generated == null)
+				compiler_generated = new ArrayList ();
 
-			iterators.Add (i);
+			compiler_generated.Add (c);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, CustomAttributeBuilder cb)
@@ -824,9 +824,9 @@
 			}
 		}
 
-		public ArrayList Iterators {
+		public ArrayList CompilerGeneratedClasses {
 			get {
-				return iterators;
+				return compiler_generated;
 			}
 		}
 
@@ -1204,7 +1204,7 @@
 			// Let's do it as soon as possible, since code below can call DefineType() on classes
 			// that depend on us to be populated before they are.
 			//
-			if (!(this is Iterator))
+			if (!(this is Iterator) && !(this is AnonymousContainer))
 				RootContext.RegisterOrder (this); 
 
 			if (base_type != null) {
@@ -1264,6 +1264,8 @@
 		//
 		public override TypeBuilder DefineType ()
 		{
+			Report.Debug (64, "TC DEFINE TYPE", this, Name, TypeBuilder, error);
+
 			if (TypeBuilder != null)
 				return TypeBuilder;
 
@@ -1282,6 +1284,8 @@
 
 			DefineNestedTypes ();
 
+			Report.Debug (64, "TC DEFINE TYPE #1", this, Name, TypeBuilder, error);
+
 			return TypeBuilder;
 		}
 
@@ -1361,6 +1365,8 @@
 				}
 			}
 
+			Report.Debug (64, "CLASS DEFINE TYPE", this, TypeBuilder, TypeParameters, Location);
+
 			foreach (TypeParameter type_param in TypeParameters) {
 				if (!type_param.DefineType (this)) {
 					error = true;
@@ -1543,14 +1549,15 @@
 					part.member_cache = member_cache;
 			}
 #endif
-			if (iterators != null) {
-				foreach (Iterator iterator in iterators) {
-					if (iterator.DefineType () == null)
+
+			if (compiler_generated != null) {
+				foreach (CompilerGeneratedClass c in compiler_generated) {
+					if (c.DefineType () == null)
 						return false;
 				}
 
-				foreach (Iterator iterator in iterators) {
-					if (!iterator.DefineMembers ())
+				foreach (CompilerGeneratedClass c in compiler_generated) {
+					if (!c.DefineMembers ())
 						return false;
 				}
 			}
@@ -1566,9 +1573,9 @@
 
 		public override bool Define ()
 		{
-			if (iterators != null) {
-				foreach (Iterator iterator in iterators) {
-					if (!iterator.Define ())
+			if (compiler_generated != null) {
+				foreach (CompilerGeneratedClass c in compiler_generated) {
+					if (!c.Define ())
 						return false;
 				}
 			}
@@ -2284,9 +2291,9 @@
 				if (pending.VerifyPendingMethods ())
 					return;
 
-			if (iterators != null)
-				foreach (Iterator iterator in iterators)
-					iterator.EmitType ();
+			if (compiler_generated != null)
+				foreach (CompilerGeneratedClass c in compiler_generated)
+					c.EmitType ();
 		}
 		
 		public override void CloseType ()
@@ -2326,9 +2333,9 @@
 				foreach (Delegate d in Delegates)
 					d.CloseType ();
 
-			if (Iterators != null)
-				foreach (Iterator i in Iterators)
-					i.CloseType ();
+			if (CompilerGeneratedClasses != null)
+				foreach (CompilerGeneratedClass c in CompilerGeneratedClasses)
+					c.CloseType ();
 			
 			types = null;
 			properties = null;
@@ -2343,7 +2350,7 @@
 			events = null;
 			indexers = null;
 			operators = null;
-			iterators = null;
+			compiler_generated = null;
 			default_constructor = null;
 			default_static_constructor = null;
 			type_bases = null;
@@ -3151,6 +3158,12 @@
 		}
 	}
 
+	public abstract class CompilerGeneratedClass : Class {
+		public CompilerGeneratedClass (DeclSpace parent, MemberName name, int mod)
+			: base (parent.NamespaceEntry, parent, name, mod, null)
+		{ }
+	}
+
 	public abstract class MethodCore : MemberBase {
 		public readonly Parameters Parameters;
 		protected ToplevelBlock block;
Index: delegate.cs
===================================================================
--- delegate.cs	(revision 62902)
+++ delegate.cs	(working copy)
@@ -816,8 +816,8 @@
 			
 			Expression e = a.Expr;
 
-			if (e is AnonymousMethod && RootContext.Version != LanguageVersion.ISO_1)
-				return ((AnonymousMethod) e).Compatible (ec, type);
+			if (e is AnonymousMethodExpression && RootContext.Version != LanguageVersion.ISO_1)
+				return ((AnonymousMethodExpression) e).Anonymous.Compatible (ec, type);
 
 			MethodGroupExpr mg = e as MethodGroupExpr;
 			if (mg != null)
Index: iterators.cs
===================================================================
--- iterators.cs	(revision 62902)
+++ iterators.cs	(working copy)
@@ -119,7 +119,7 @@
 		}
 	}
 
-	public class Iterator : Class {
+	public class Iterator : CompilerGeneratedClass {
 		protected ToplevelBlock original_block;
 		protected ToplevelBlock block;
 
@@ -358,9 +358,9 @@
 		//
 		public Iterator (IMethodData m_container, DeclSpace parent, GenericMethod generic,
 				 int modifiers)
-			: base (parent.NamespaceEntry, parent,
+			: base (parent,
 				MakeProxyName (m_container.MethodName.Name, generic, m_container.Location),
-				(modifiers & Modifiers.UNSAFE) | Modifiers.PRIVATE, null)
+				(modifiers & Modifiers.UNSAFE) | Modifiers.PRIVATE)
 		{
 			this.orig_method = m_container;
 
@@ -423,7 +423,7 @@
 			else
 				this_type = container.TypeBuilder;
 
-			container.AddIterator (this);
+			container.AddCompilerGeneratedClass (this);
 
 			orig_method.Block = block;
 			return true;
@@ -1001,11 +1001,16 @@
 			Iterator iterator;
 
 			public MoveNextMethod (Iterator iterator, Location loc)
-				: base (iterator.parameters, iterator.original_block, loc)
+				: base (iterator, iterator.parameters, iterator.original_block, loc)
 			{
 				this.iterator = iterator;
 			}
 
+			public override bool Resolve (EmitContext ec)
+			{
+				return true;
+			}
+
 			protected override bool CreateMethodHost (EmitContext ec)
 			{
 				method = new Method (
@@ -1044,11 +1049,6 @@
 				scope.ScopeTypeBuilder = iterator.TypeBuilder;
 				scope.ScopeConstructor = iterator.ctor.ConstructorBuilder;
 			}
-
-			public override void Emit (EmitContext ec)
-			{
-				throw new InternalErrorException ();
-			}
 		}
 
 		protected class MoveNextStatement : Statement {
Index: cs-parser.jay
===================================================================
--- cs-parser.jay	(revision 62902)
+++ cs-parser.jay	(working copy)
@@ -45,6 +45,8 @@
 
 		Delegate   current_delegate;
 
+		GenericMethod current_generic_method;
+
 		/// <summary>
 		///   This is used by the unary_expression code to resolve
 		///   a name against a parameter.  
@@ -1074,6 +1076,7 @@
 		method.Block = (ToplevelBlock) $3;
 		current_container.AddMethod (method);
 
+		current_generic_method = null;
 		current_local_parameters = null;
 		iterator_container = null;
 
@@ -1133,6 +1136,7 @@
 				     name, (Parameters) $6, (Attributes) $1);
 
 		current_local_parameters = (Parameters) $6;
+		current_generic_method = generic;
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
@@ -1169,6 +1173,7 @@
 				     (int) $2, false, name, (Parameters) $6, (Attributes) $1);
 
 		current_local_parameters = (Parameters) $6;
+		current_generic_method = generic;
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
@@ -3419,11 +3424,15 @@
 			ToplevelBlock anon_block = (ToplevelBlock) $4;
 
 			anon_block.Parent = current_block;
-			$$ = new AnonymousMethod (current_container, (Parameters) $2, (ToplevelBlock) top_current_block, 
+			AnonymousMethod am = new AnonymousMethod (
+				current_container, (Parameters) $2, (ToplevelBlock) top_current_block,
 				anon_block, loc);
-		}
+
+			// current_container.AddCompilerGeneratedClass (am);
+			$$ = new AnonymousMethodExpression (am);
 			current_local_parameters = (Parameters) oob_stack.Pop ();
 		}
+	}
 	;
 
 opt_anonymous_method_signature
@@ -4003,7 +4012,8 @@
 	: OPEN_BRACE 
 	  {
 		if (current_block == null){
-			current_block = new ToplevelBlock ((ToplevelBlock) top_current_block, current_local_parameters, (Location) $1);
+			current_block = new ToplevelBlock ((ToplevelBlock) top_current_block, current_local_parameters,
+							   current_generic_method, (Location) $1);
 			top_current_block = current_block;
 		} else {
 			current_block = new Block (current_block, (Location) $1, Location.Null);
Index: convert.cs
===================================================================
--- convert.cs	(revision 62902)
+++ convert.cs	(working copy)
@@ -838,8 +838,8 @@
 				if (!TypeManager.IsDelegateType (target_type))
 					return false;
 
-				AnonymousMethod am = (AnonymousMethod) expr;
-				return am.ImplicitStandardConversionExists (target_type);
+				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
+				return ame.Anonymous.ImplicitStandardConversionExists (target_type);
 			}
 
 			return false;
@@ -1325,10 +1325,11 @@
 					return null;
 				}
 
-				AnonymousMethod am = (AnonymousMethod) expr;
+				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
+
 				int errors = Report.Errors;
 
-				Expression conv = am.Compatible (ec, target_type);
+				Expression conv = ame.Anonymous.Compatible (ec, target_type);
 				if (conv != null)
 					return conv;
 				
Index: anonymous.cs
===================================================================
--- anonymous.cs	(revision 62902)
+++ anonymous.cs	(working copy)
@@ -20,8 +20,52 @@
 
 namespace Mono.CSharp {
 
-	public abstract class AnonymousContainer : Expression
+	public class AnonymousMethodExpression : Expression
 	{
+		public readonly AnonymousMethod Anonymous;
+
+		public AnonymousMethodExpression (AnonymousMethod anon)
+		{
+			this.Anonymous = anon;
+			loc = anon.loc;
+		}
+
+		public override string ExprClassName {
+			get {
+				return "anonymous method";
+			}
+		}
+
+		public override Expression DoResolve (EmitContext ec)
+		{
+			//
+			// Set class type, set type
+			//
+
+			eclass = ExprClass.Value;
+
+			//
+			// This hack means `The type is not accessible
+			// anywhere', we depend on special conversion
+			// rules.
+			// 
+			type = TypeManager.anonymous_method_type;
+
+			if (!Anonymous.Resolve (ec))
+				return null;
+
+			return this;
+		}
+
+		public override void Emit (EmitContext ec)
+		{
+			// nothing, as we only exist to not do anything.
+			throw new InternalErrorException ();
+		}
+	}
+
+	public abstract class AnonymousContainer : CompilerGeneratedClass
+	{
 		// Used to generate unique method names.
 		protected static int anonymous_method_count;
 		    
@@ -47,8 +91,9 @@
 		
 		// The emit context for the anonymous method
 		public EmitContext aec;
-		public string[] TypeParameters;
 		public Type[] TypeArguments;
+		new public string[] TypeParameters;
+		public readonly Location loc;
 		protected bool unreachable;
 
 		// The method scope
@@ -72,13 +117,28 @@
 		//
 		public AnonymousContainer ContainerAnonymousMethod;	
 
-		protected AnonymousContainer (Parameters parameters, ToplevelBlock container,
-					      ToplevelBlock block, Location l)
+		private static MemberName MakeProxyName (ToplevelBlock container, Location loc)
 		{
+			string proxy_name = String.Format ("<>AnonHelp_<{0}>", anonymous_method_count++);
+			if (container.GenericMethod != null) {
+				TypeArguments args = new TypeArguments (loc);
+				foreach (TypeParameter tparam in container.GenericMethod.TypeParameters)
+					args.Add (new SimpleName ("_" + tparam.Name, loc));
+				return new MemberName (proxy_name, args, loc);
+			}
+			return new MemberName (proxy_name, loc);
+		}
+
+		protected AnonymousContainer (TypeContainer host, Parameters parameters,
+					      ToplevelBlock container, ToplevelBlock block, Location l)
+			: base (host, MakeProxyName (container, l), 0)
+		{
 			Parameters = parameters;
 			Block = block;
 			loc = l;
 
+			SetParameterInfo (null);
+
 			//
 			// The order is important: this setups the CaptureContext tree hierarchy.
 			//
@@ -89,30 +149,12 @@
 			block.SetHaveAnonymousMethods (l, this);
 		}
 
-		protected AnonymousContainer (Parameters parameters, ToplevelBlock container,
-					      Location l):
-			this (parameters, container, new ToplevelBlock (container, parameters, l), l)
+		protected AnonymousContainer (TypeContainer host, Parameters parameters, ToplevelBlock container,
+					      Location l)
+			: this (host, parameters, container, new ToplevelBlock (container, parameters, l), l)
 		{
 		}
 
-		public override Expression DoResolve (EmitContext ec)
-		{
-			//
-			// Set class type, set type
-			//
-
-			eclass = ExprClass.Value;
-
-			//
-			// This hack means `The type is not accessible
-			// anywhere', we depend on special conversion
-			// rules.
-			// 
-			type = TypeManager.anonymous_method_type;
-
-			return this;
-		}
-
 		public void RegisterScope (ScopeInfo scope)
 		{
 			if (scopes_used.Contains (scope))
@@ -194,8 +236,9 @@
 				throw new Exception ("Internal error, AnonymousContainer.Scope is being used before its container is computed");
 			}
 		}
+
+		public abstract bool Resolve (EmitContext ec);
 		
-		
 		protected abstract bool CreateMethodHost (EmitContext ec);
 
 		public abstract void CreateScopeType (EmitContext ec, ScopeInfo scope);
@@ -207,6 +250,12 @@
 		public abstract bool IsIterator {
 			get;
 		}
+
+		public override void EmitType ()
+		{
+			TypeBuilder.SetCustomAttribute (TypeManager.compiler_generated_attr);
+			base.EmitType ();
+		}
 	}
 
 	public class AnonymousMethod : AnonymousContainer
@@ -222,7 +271,7 @@
 
 		public AnonymousMethod (TypeContainer host, Parameters parameters, ToplevelBlock container,
 					ToplevelBlock block, Location l)
-			: base (parameters, container, block, l)
+			: base (host, parameters, container, block, l)
 		{
 			this.host = host;
 		}
@@ -235,9 +284,10 @@
 			get { return false; }
 		}
 
-		public override void Emit (EmitContext ec)
+		protected override bool DefineNestedTypes ()
 		{
-			// nothing, as we only exist to not do anything.
+			Report.Debug (64, "ANONYMOUS DEFINE NESTED TYPES");
+			return base.DefineNestedTypes ();
 		}
 
 		//
@@ -247,26 +297,13 @@
 		{
 			ComputeMethodHost ();
 
+			Report.Debug (64, "CREATE METHOD HOST", this, ec.TypeContainer, method,
+				      TypeBuilder, CurrentType, IsGeneric);
+
 			//
-			// Crude hack follows: we replace the TypeBuilder during the
-			// definition to get the method hosted in the right class
-			//
-			TypeBuilder current_type = ec.TypeContainer.TypeBuilder;
-			TypeBuilder type_host = (Scope == null ) ? current_type : Scope.ScopeTypeBuilder;
-
-			if (current_type == null)
-				throw new Exception ("The current_type is null");
-			
-			if (type_host == null)
-				throw new Exception (String.Format ("Type host is null, method_host is {0}", Scope == null ? "null" : "Not null"));
-
-			if (current_type != type_host)
-				method_modifiers = Modifiers.INTERNAL;
-
-			if (current_type == type_host && ec.IsStatic){
+			method_modifiers = Modifiers.INTERNAL;
+			if (ec.IsStatic)
 				method_modifiers |= Modifiers.STATIC;
-				current_type = null;
-			} 
 
 			string name = "<#AnonymousMethod>" + anonymous_method_count++;
 			MemberName member_name;
@@ -280,8 +317,7 @@
 				member_name = new MemberName (name, args, loc);
 
 				generic_method = new GenericMethod (
-					ec.DeclContainer.NamespaceEntry,
-					(TypeContainer) ec.TypeContainer, member_name,
+					ec.DeclContainer.NamespaceEntry, this, member_name,
 					new TypeExpression (invoke_mb.ReturnType, loc),
 					Parameters);
 
@@ -290,21 +326,34 @@
 				member_name = new MemberName (name, loc);
 
 			method = new Method (
-				(TypeContainer) ec.TypeContainer, generic_method,
+				this, generic_method,
 				new TypeExpression (invoke_mb.ReturnType, loc),
 				method_modifiers, false, member_name, Parameters, null);
 			method.Block = Block;
 
+			return method.Define ();
+		}
+
+		public bool EmitMethod ()
+		{
+			MethodBuilder builder = method.MethodBuilder;
+			ILGenerator ig = builder.GetILGenerator ();
+			aec.ig = ig;
+
+			Parameters.ApplyAttributes (builder);
+
 			//
-			// Swap the TypeBuilder while we define the method, then restore
-			//
-			if (current_type != null)
-				ec.TypeContainer.TypeBuilder = type_host;
-			bool res = method.Define ();
-			if (current_type != null)
-				ec.TypeContainer.TypeBuilder = current_type;
+			// Adjust based on the computed state of the
+			// method from CreateMethodHost
+			
+			aec.MethodIsStatic = (method_modifiers & Modifiers.STATIC) != 0;
 
-			return res;
+			ig.Emit (OpCodes.Ret);
+			return true;
+			
+			aec.EmitMeta (Block);
+			aec.EmitResolvedTopBlock (Block, unreachable);
+			return true;
 		}
 
 		void Error_ParameterMismatch (Type t)
@@ -338,6 +387,9 @@
 		//
 		public Expression Compatible (EmitContext ec, Type delegate_type)
 		{
+			Report.Debug (64, "COMPATIBLE", this, delegate_type, anonymous_delegate,
+				      ec.ContainerType, loc);
+
 			if (anonymous_delegate != null)
 				return anonymous_delegate;
 			
@@ -348,6 +400,7 @@
 
 			MethodGroupExpr invoke_mg = Delegate.GetInvokeMethod (ec.ContainerType, delegate_type, loc);
 			invoke_mb = (MethodInfo) invoke_mg.Methods [0];
+			Report.Debug (64, "COMPATIBLE #1", invoke_mb);
 			ParameterData invoke_pd = TypeManager.GetParameterData (invoke_mb);
 
 			if (delegate_type.IsGenericType) {
@@ -431,35 +484,55 @@
 			ContainerAnonymousMethod = ec.CurrentAnonymousMethod;
 			ContainingBlock = ec.CurrentBlock;
 
-			if (aec.ResolveTopBlock (ec, Block, Parameters, null, out unreachable)){
-				anonymous_delegate = new AnonymousDelegate (
-					this, delegate_type, loc).Resolve (ec);
-				return anonymous_delegate;
-			}
-			return null;
+			if (!aec.ResolveTopBlock (ec, Block, Parameters, null, out unreachable))
+				return null;
+
+			anonymous_delegate = new AnonymousDelegate (this, delegate_type, loc).Resolve (ec);
+			if (anonymous_delegate == null)
+				return null;
+
+			Report.Debug (64, "COMPATIBLE #2", anonymous_delegate);
+
+			if (DefineType () == null)
+				return null;
+
+			if (!CreateMethodHost (ec))
+				return null;
+
+			if (!ResolveType ())
+				return null;
+
+			Report.Debug (64, "COMPATIBLE #3", anonymous_delegate, TypeBuilder,
+				      CurrentType, Scope);
+
+#if FIXME
+			host.AddCompilerGeneratedClass (this);
+
+			ResolveType ();
+			DefineMembers ();
+
+			EmitType ();
+#endif
+
+			return anonymous_delegate;
 		}
 
-		public override Expression DoResolve (EmitContext ec)
+		public override bool Resolve (EmitContext ec)
 		{
 			if (!ec.IsAnonymousMethodAllowed) {
-				Report.Error (1706, loc, "Anonymous methods are not allowed in the attribute declaration");
-				return null;
+				Report.Error (1706, loc,
+					      "Anonymous methods are not allowed in the attribute declaration");
+				return false;
 			}
 
 			if (Parameters != null && !Parameters.Resolve (ec)) {
-				return null;
+				return false;
 			}
 
-			return base.DoResolve (ec);
+			return true;
 		}
 
 
-		public override string ExprClassName {
-			get {
-				return "anonymous method";
-			}
-		}
-
 		public MethodInfo GetMethodBuilder ()
 		{
 			MethodInfo builder = method.MethodBuilder;
@@ -477,8 +550,10 @@
 		
 		public bool EmitMethod (EmitContext ec)
 		{
+#if FIXME
 			if (!CreateMethodHost (ec))
 				return false;
+#endif
 
 			MethodBuilder builder = method.MethodBuilder;
 			ILGenerator ig = builder.GetILGenerator ();
@@ -486,6 +561,9 @@
 
 			Parameters.ApplyAttributes (builder);
 
+			ig.Emit (OpCodes.Ret);
+			return true;
+
 			//
 			// Adjust based on the computed state of the
 			// method from CreateMethodHost
@@ -499,50 +577,132 @@
 
 		public override void CreateScopeType (EmitContext ec, ScopeInfo scope)
 		{
-			TypeBuilder container = ec.TypeContainer.TypeBuilder;
-			string name = String.Format ("<>AnonHelp<{0}>", scope.id);
+			TypeExpression parent;
+			if (ec.TypeContainer.CurrentType != null)
+				parent = new TypeExpression (ec.TypeContainer.CurrentType, loc);
+			else
+				parent = new TypeExpression (ec.TypeContainer.TypeBuilder, loc);
 
-			scope.ScopeTypeBuilder = container.DefineNestedType (name,
-				TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit | TypeAttributes.NestedPrivate,
-					 TypeManager.object_type);
+			Report.Debug (64, "CREATE SCOPE TYPE", this, ec.TypeContainer,
+				      parent.Type, TypeBuilder, scope.NeedThis);
 
-			Type [] constructor_types = Type.EmptyTypes;
-			ConstructorBuilder ctor = scope.ScopeTypeBuilder.DefineConstructor (
-				MethodAttributes.Public | MethodAttributes.HideBySig |
-				MethodAttributes.SpecialName | MethodAttributes.RTSpecialName,
-				CallingConventions.HasThis, constructor_types);
-			TypeManager.RegisterMethod (ctor, Parameters.EmptyReadOnlyParameters);
+			TypeParameter[] tparam = null;
+			if (ec.TypeContainer.IsGeneric)
+				tparam = ec.TypeContainer.TypeParameters;
+			else if (ContainingBlock.Toplevel.GenericMethod != null)
+				tparam = ContainingBlock.Toplevel.GenericMethod.TypeParameters;
 
-			ILGenerator cig = ctor.GetILGenerator ();
-			cig.Emit (OpCodes.Ldarg_0);
-			cig.Emit (OpCodes.Call, TypeManager.object_ctor);
-			cig.Emit (OpCodes.Ret);
+			Field this_field = null;
+			if (scope.NeedThis) {
+				this_field = new Field (
+					this, parent, Modifiers.INTERNAL, "<>THIS", null, loc);
+				AddField (this_field);
+			}
 
-			if (ec.TypeContainer.IsGeneric) {
-				TypeParameter[] tparam = ec.TypeContainer.TypeParameters;
-				string[] names = new string [tparam.Length];
-				Type[] types = new Type [tparam.Length];
+			if (scope.HostsParameters){
+				Hashtable captured_parameters = scope.CaptureContext.captured_parameters;
+				foreach (DictionaryEntry de in captured_parameters){
+					string name = (string) de.Key;
+					CapturedParameter cp = (CapturedParameter) de.Value;
 
-				for (int i = 0; i < names.Length; i++) {
-					names [i] = tparam [i].Name;
-					types [i] = tparam [i].Type;
+					Field field = new Field (
+						this, InflateType (ec, cp.Type), Modifiers.INTERNAL,
+						"<p:" + name + ">", null, loc);
+					AddField (field);
 				}
+			}
 
-				scope.ScopeTypeBuilder.DefineGenericParameters (names);
-				scope.ScopeTypeBuilder.GetGenericTypeDefinition ();
+			ResolveType ();
+			DefineMembers ();
 
-				scope.ScopeType = scope.ScopeTypeBuilder.MakeGenericType (types);
-			} else
-				scope.ScopeType = scope.ScopeTypeBuilder;
+			EmitType ();
+			// CloseType ();
 
+			Report.Debug (64, "CREATE SCOPE TYPE #1", this, TypeBuilder, CurrentType,
+				      instance_constructors [0], tparam);
 
-			if (ec.TypeContainer.IsGeneric)
-				scope.ScopeConstructor = TypeBuilder.GetConstructor (
-					scope.ScopeType, ctor);
-			else
-				scope.ScopeConstructor = ctor;
+			if (tparam != null) {
+				ConstructedType ctype = new ConstructedType (TypeBuilder, tparam, loc);
+				TypeExpr te = ctype.ResolveAsTypeTerminal (ec, false);
+				scope.ScopeTypeExpr = te;
+				scope.ScopeType = te.Type;
+			} else {
+				scope.ScopeType = CurrentType != null ? CurrentType : TypeBuilder;
+				scope.ScopeTypeExpr = new TypeExpression (scope.ScopeType, loc);
+			}
+
+			Report.Debug (64, "CREATE SCOPE TYPE #2", this, TypeBuilder, CurrentType,
+				      scope.ScopeType, scope.NeedThis, scope.HostsParameters);
+
+			{
+				MemberInfo[] mi = TypeManager.MemberLookup (
+					ec.ContainerType, scope.ScopeType, scope.ScopeType,
+					MemberTypes.Constructor,
+					BindingFlags.Instance | BindingFlags.Public,
+					".ctor", null);
+
+				Report.Debug (64, "CREATE SCOPE TYPE #3", mi);
+
+				scope.ScopeConstructor = (ConstructorInfo) mi [0];
+			}
+
+			if (scope.NeedThis) {
+				MemberInfo[] mi = TypeManager.MemberLookup (
+					ec.ContainerType, scope.ScopeType, scope.ScopeType,
+					MemberTypes.Field,
+					BindingFlags.Instance | BindingFlags.NonPublic,
+					"<>THIS", null);
+
+				Report.Debug (64, "CREATE SCOPE TYPE #4", mi);
+				scope.THIS = (FieldInfo) mi [0];
+			}
+
+			if (scope.HostsParameters){
+				Hashtable captured_parameters = scope.CaptureContext.captured_parameters;
+				foreach (DictionaryEntry de in captured_parameters){
+					string name = (string) de.Key;
+					CapturedParameter cp = (CapturedParameter) de.Value;
+
+					MemberInfo[] mi = TypeManager.MemberLookup (
+						ec.ContainerType, scope.ScopeType, scope.ScopeType,
+						MemberTypes.Field,
+						BindingFlags.Instance | BindingFlags.NonPublic,
+						"<p:" + name + ">", null);
+
+					Report.Debug (64, "CREATE SCOPE TYPE #5", name, mi);
+
+					cp.Field = (FieldInfo) mi [0];
+				}
+			}
+
+
+			scope.ScopeTypeBuilder = TypeBuilder;
 		}
 
+		TypeExpr InflateType (EmitContext ec, Type it)
+		{
+			if (it.IsGenericParameter && (it.DeclaringMethod != null)) {
+				int pos = it.GenericParameterPosition;
+				it = CurrentTypeParameters [pos].Type;
+			} else if (it.IsGenericType) {
+				Type[] args = it.GetGenericArguments ();
+
+				TypeArguments inflated = new TypeArguments (Location);
+				foreach (Type t in args)
+					inflated.Add (InflateType (ec, t));
+
+				return new ConstructedType (it, inflated, Location);
+			} else if (it.IsArray) {
+				TypeExpr et_expr = InflateType (ec, it.GetElementType ());
+				int rank = it.GetArrayRank ();
+
+				Type et = et_expr.ResolveAsTypeTerminal (ec, false).Type;
+				it = et.MakeArrayType (rank);
+			}
+
+			return new TypeExpression (it, Location);
+		}
+
 		public static void Error_AddressOfCapturedVar (string name, Location loc)
 		{
 			Report.Error (1686, loc,
@@ -611,7 +771,7 @@
 
 	class CapturedParameter {
 		public Type Type;
-		public FieldBuilder FieldBuilder;
+		public FieldInfo Field;
 		public int Idx;
 
 		public CapturedParameter (Type type, int idx)
@@ -644,9 +804,10 @@
 		// The types and fields generated
 		//
 		public TypeBuilder ScopeTypeBuilder;
+		public TypeExpr ScopeTypeExpr;
 		public Type ScopeType;
 		public ConstructorInfo ScopeConstructor;
-		public FieldBuilder THIS;
+		public FieldInfo THIS;
 		public FieldBuilder ParentLink;
 
 		//
@@ -752,6 +913,8 @@
 				container = ec.TypeContainer.TypeBuilder;
 
 			CaptureContext.Host.CreateScopeType (ec, this);
+
+#if FIXME
 			
 			if (NeedThis)
 				THIS = ScopeTypeBuilder.DefineField ("<>THIS", container, FieldAttributes.Assembly);
@@ -789,6 +952,7 @@
 			foreach (ScopeInfo si in children){
 				si.EmitScopeType (ec);
 			}
+#endif
 		}
 
 		public void CloseTypes ()
@@ -842,10 +1006,14 @@
 
 					EmitScopeInstance (ig);
 					ParameterReference.EmitLdArg (ig, cp.Idx + extra);
-					ig.Emit (OpCodes.Stfld, cp.FieldBuilder);
+					ig.Emit (OpCodes.Stfld, cp.Field);
 				}
 			}
 
+			inited = true;
+			return;
+
+
 			if (ParentScope != null){
 				if (!ParentScope.inited)
 					ParentScope.EmitInitScope (ec);
@@ -1328,11 +1496,11 @@
 				// FIXME: implementing this.
 				//
 			}
-			ec.ig.Emit (OpCodes.Ldfld, par_info.FieldBuilder);
+			ec.ig.Emit (OpCodes.Ldfld, par_info.Field);
 
 			if (leave_copy){
 				ec.ig.Emit (OpCodes.Dup);
-				temp = new LocalTemporary (par_info.FieldBuilder.FieldType);
+				temp = new LocalTemporary (par_info.Field.FieldType);
 				temp.Store (ec);
 			}
 		}
@@ -1357,10 +1525,10 @@
 			source.Emit (ec);
 			if (leave_copy){
 				ig.Emit (OpCodes.Dup);
-				temp = new LocalTemporary (par_info.FieldBuilder.FieldType);
+				temp = new LocalTemporary (par_info.Field.FieldType);
 				temp.Store (ec);
 			}
-			ig.Emit (OpCodes.Stfld, par_info.FieldBuilder);
+			ig.Emit (OpCodes.Stfld, par_info.Field);
 			if (temp != null)
 				temp.Emit (ec);
 		}
@@ -1378,7 +1546,7 @@
 			}
 			EmitParameterInstance (ec, name);
 			CapturedParameter par_info = (CapturedParameter) captured_parameters [name];
-			ec.ig.Emit (OpCodes.Ldflda, par_info.FieldBuilder);
+			ec.ig.Emit (OpCodes.Ldflda, par_info.Field);
 		}
 
 		//
Index: statement.cs
===================================================================
--- statement.cs	(revision 62902)
+++ statement.cs	(working copy)
@@ -2083,6 +2083,7 @@
 		// Pointer to the host of this anonymous method, or null
 		// if we are the topmost block
 		//
+		GenericMethod generic;
 		ToplevelBlock container;
 		CaptureContext capture_context;
 		FlowBranchingToplevel top_level_branching;
@@ -2120,6 +2121,10 @@
 			}
 		}
 
+		public GenericMethod GenericMethod {
+			get { return generic; }
+		}
+
 		public CaptureContext ToplevelBlockCaptureContext {
 			get { return capture_context; }
 		}
@@ -2144,6 +2149,13 @@
 			this (container, (Flags) 0, parameters, start)
 		{
 		}
+
+		public ToplevelBlock (ToplevelBlock container, Parameters parameters, GenericMethod generic,
+				      Location start) :
+			this (container, parameters, start)
+		{
+			this.generic = generic;
+		}
 		
 		public ToplevelBlock (Parameters parameters, Location start) :
 			this (null, (Flags) 0, parameters, start)
@@ -4164,7 +4176,7 @@
 
 			Type var_type = texpr.Type;
 
-			if (expr.eclass == ExprClass.MethodGroup || expr is AnonymousMethod) {
+			if (expr.eclass == ExprClass.MethodGroup || expr is AnonymousMethodExpression) {
 				Report.Error (446, expr.Location, "Foreach statement cannot operate on a `{0}'",
 					expr.ExprClassName);
 				return false;
