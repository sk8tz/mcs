Hi Miguel,

today, I was at my parent's place watching the dog - offline, without
any internet connection - so I had a lot of time to look at this
anonymous method problem.

The situation I'm trying to fix:
================================

What I'm trying to fix are situations like the following:

	delegate void Foo ();

	class X
	{
		static void Hello<U> (U u)
		{ }

		static void Test<T> (T t)
		{
			Foo foo = delegate {
				Hello (t);
			};
		}
	}

Here, we have an anonymous method inside a generic method and we need
to capture one of the generic method parameters.

To do this, we have to create a generic helper class like this:

	.class nested private auto ansi sealed beforefieldinit '<>AnonHelp<0>'<T>
		extends [mscorlib]System.Object
	{
		.field  assembly  !0 '<p:t>'
	}

Note that the method type parameter becomes a class type parameter.

Trouble with S.R/S.R.E:
=======================

This becomes problematic when accessing the field - using S.R/S.R.E
the correct way of doing it is this:

* You create the helper class - container.DefineNestedType (....)
* You add the type parameters - TypeBuilder.DefineGenericParameters (....)
* You define all fields, methods etc.
* Once you're done, you call
  TypeBuilder.GetGenericTypeDefinition().MakeGenericType (...)
* You call Type.GetField() on the returned type to get a FieldInfo for
  field; this'll give you a correctly instantiated field.

You must not, under any circumstances, attempt to access the
FieldBuilder directly - especially not from outside the class.

The reason for this is simple: if you're inside the host method,
ie. outside the helper class, you actually need to access the field in
the instantiated generic type `<>AnonHelp<0>'<!!0> and not in the
generic type definition `<>AnonHelp<0>'<!0>; this'd be invalid IL.

The big problem here is that with reflection you can't do certain
things until the type has been fully created - but if I see this
correctly, the current code is creating the TypeBuilder and then
adding stuff to it later on "on-the-fly".

That's why I had this idea of making `AnonymousMethod' a
`TypeContainer' or something like a `CompilerGeneratedClass' which
derives from `TypeContainer'.

Problems with using TypeContainer:
==================================

Unfortunately, things are not as easy as I expected them to be.

One problem with anonymous methods is their "late binding"; I mean,
with our current code, the actual type of an anonymous method can't be
determinted until the host method is being emitted.

At the moment, this is done in Block.Resolved() - which is called via
Method.Emit() / MethodData.Emit ().  So we can't fully integrate them
in the TypeContainer framework like we're currently doing with iterators.

Iterators, on the other hand, are easier - they can be fully resolved
in Method.Define().

However, I think my current patch already adresses these issues.

The biggest challenge, however, are all these zillion uses of
EmitScopeInstance() / EmitScopeType() and passing around of
ILGenerator's.

At the moment, I'm really stuck and don't know how to continue and
there are also a few things I don't fully understand:

* Why is the ScopeTypeBuilder created in the ScopeInfo and not in the
  AnonymousMethod and can there ever be more than one ScopeTypeBuilder
  in one single AnonymousMethod ?

Attached is the current version of my patch.

Martin
