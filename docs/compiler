		       The Internals of the Mono C# Compiler
	
				Miguel de Icaza
			      (miguel@ximian.com)
				      2002

* Abstract

	The Mono C# compiler is a C# compiler written in C# itself.
	Its goals are to provide a free and alternate implementation
	of the C# language.  The Mono C# compiler generates ECMA CIL
	images through the use of the System.Reflection.Emit API which
	enable the compiler to be platform independent. 
	
* How the compiler fits together

	The driver, the tokenizer, the parser, the internal
	representation, the resolution process, the code generation
	step. 

* The parsing process

	All the input files that make up a program need to be read in
	advance, because C# allows declarations to happen after an
	entity is used, for example, the following is a valid program:

	class X : Y {
		static void Main ()
		{
			a = "hello"; b = "world";
		}
		string a;
	}
	
	class Y {
		public string b;
	}

	At the time the assignment expression `a = "hello"' is parsed,
	it is not know whether a is a class field from this class, or
	its parents, or whether it is a property access or a variable
	reference.

	Hence, the compiler driver has to parse all the input files.
	Once all the input files have been parsed, and an internal
	representation of the input program exists, the following
	steps are taken:

		* The interface hierarchy is resolved first.
	 	  As the interface hierarchy is constructed,
		  TypeBuilder objects are created for each one of
		  them. 

		* Classes and structure hierarchy is resolved next,
		  TypeBuilder objects are created for them.

		* Constants and enumerations are resolved.

		* Method, indexer, properties, delegates and event
		  definitions are now entered into the TypeBuilders. 

		* Elements that contain code are now invoked to
		  perform semantic analysis and code generation.

** The Tokenizer and the pre-processor

	The tokenizer is contained in the file `cs-tokenizer.cs', and
	the main entry point is the `token ()' method.  The tokenizer
	implements the `yyParser.yyInput' interface, which is what the
	Yacc/Jay parser will use when fetching tokens.  

	Token definitions are generated by jay during the compilation
	process, and those can be references from the tokenizer class
	with the `Token.' prefix. 

	Each time a token is returned, the location for the token is
	recorded into the `Location' property, that can be accessed by
	the parser.  The parser retrieves the Location properties as
	it builds its internal representation to allow the semantic
	analysis phase to produce error messages that can pin point
	the location of the problem. 

	C# has a limited pre-processor that allows conditional
	compilation, but it is not as fully featured as the C
	pre-processor, and most notable, macros are missing.  This
	makes it simple to implement in very few lines and mesh it
	with the tokenizer.

	The `handle_preprocessing_directive' method in the tokenizer
	handles all the pre-processing, and it is invoked when the '#'
	symbol is found as the first token in a line.  The state of
	the pre-processor is contained in a Stack called `ifstack',
	this state is used to track the if/elif/else/endif states.
	The state is encoded in the top of the stack as a number of
	values `TAKING', `TAKEN_BEFORE', `ELSE_SEEN',
	`PARENT_TAKING'.

** Locations

	Locations are encoded as a 32-bit number (the Location
	struct) that map each input source line to a linear number.
	As new files are parsed, the Location manager is informed of
	the new file, to allow it to map back from an int constant to
	a file + line number. 

	The tokenizer also tracks the column number for a token, but
	this is currently not being used or encoded.  It could
	probably be encoded in the low 9 bits, allowing for columns
	from 1 to 512 to be encoded.
	
* The Parser

* Internal Representatio

** Expressions

*** The Expression Class

	The utility functions that can be called by all children of
	Expression. 

** Constants

	Constants in the Mono C# compiler are reprensented by the
	abstract class `Constant'.  Constant is in turn derived from
	Expression.  The base constructor for `Constant' just sets the
	expression class to be an `ExprClass.Value', Constants are
	born in a fully resolved state, so the `DoResolve' method
	only returns a reference to itself.

	Each Constant should implement the `GetValue' method which
	returns an object with the actual contents of this constant, a
	utility virtual method called `AsString' is used to render a
	diagnostic message.  The output of AsString is shown to the
	developer when an error or a warning is triggered.

	Constant classes also participate in the constant folding
	process.  Constant folding is invoked by those expressions
	that can be constant folded invoking the functionality
	provided by the ConstantFold class (cfold.cs).   

	Each Constant has to implement a number of methods to convert
	itself into a Constant of a different type.  These methods are
	called `ConvertToXXXX' and they are invoked by the wrapper
	functions `ToXXXX'.  These methods only perform implicit
	numeric conversions.  Explicit conversions are handled by the
	`Cast' expression class.

	The `ToXXXX' methods are the entry point, and provide error
	reporting in case a conversion can not be performed.

** Statements

* Code Generation