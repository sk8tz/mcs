//
// Tuples.cs
//
// Authors:
//  Zoltan Varga (vargaz@gmail.com)
//
// Copyright (C) 2009 Novell
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#if NET_4_0

using System;
using System.Collections;

namespace System
{
	public class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;
		T2 item2;
		T3 item3;
		T4 item4;
		T5 item5;
		T6 item6;
		T7 item7;
		TRest rest;

		public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest) {
			this.item1 = item1;
			this.item2 = item2;
			this.item3 = item3;
			this.item4 = item4;
			this.item5 = item5;
			this.item6 = item6;
			this.item7 = item7;
			this.rest = rest;

			bool ok = true;
			if (!typeof (TRest).IsGenericType)
				ok = false;
			if (ok) {
				Type t = typeof (TRest).GetGenericTypeDefinition ();
				if (!(t == typeof (Tuple<>) || t == typeof (Tuple<,>) || t == typeof (Tuple<,,>) || t == typeof (Tuple<,,,>) || t == typeof (Tuple<,,,,>) || t == typeof (Tuple <,,,,,>) || t == typeof (Tuple<,,,,,,>) || t == typeof (Tuple<,,,,,,,>)))
					ok = false;
			}
			if (!ok)
				throw new ArgumentException ("The last element of an eight element tuple must be a Tuple.");
		}

		public T1 Item1 {
			get {
				return item1;
			}
		}

		public T2 Item2 {
			get {
				return item2;
			}
		}

		public T3 Item3 {
			get {
				return item3;
			}
		}

		public T4 Item4 {
			get {
				return item4;
			}
		}

		public T5 Item5 {
			get {
				return item5;
			}
		}

		public T6 Item6 {
			get {
				return item6;
			}
		}

		public T7 Item7 {
			get {
				return item7;
			}
		}

		public TRest Rest {
			get {
				return rest;
			}
		}

		int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }

		[MonoTODO]
		public override string ToString () {
			// FIXME: Merge the items from rest into the parent
			return String.Format ("({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})", Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest);
		}
	}

	/* The rest is generated by the script at the bottom */

	public class Tuple<T1> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;

		public Tuple (T1 item1) {
			 this.item1 = item1;
		}
		public T1 Item1 {
			get {
				return item1;
			}
		}
		[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }
		public override string ToString () {
			return String.Format ("({0})", Item1);
		}
	}

	public class Tuple<T1, T2> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;
		T2 item2;

		public Tuple (T1 item1, T2 item2) {
			 this.item1 = item1;
			 this.item2 = item2;
		}
		public T1 Item1 {
			get {
				return item1;
			}
		}
		public T2 Item2 {
			get {
				return item2;
			}
		}
		[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }
		public override string ToString () {
			return String.Format ("({0}, {1})", Item1, Item2);
		}
	}

	public class Tuple<T1, T2, T3> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;
		T2 item2;
		T3 item3;

		public Tuple (T1 item1, T2 item2, T3 item3) {
			 this.item1 = item1;
			 this.item2 = item2;
			 this.item3 = item3;
		}
		public T1 Item1 {
			get {
				return item1;
			}
		}
		public T2 Item2 {
			get {
				return item2;
			}
		}
		public T3 Item3 {
			get {
				return item3;
			}
		}
		[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }
		public override string ToString () {
			return String.Format ("({0}, {1}, {2})", Item1, Item2, Item3);
		}
	}

	public class Tuple<T1, T2, T3, T4> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;
		T2 item2;
		T3 item3;
		T4 item4;

		public Tuple (T1 item1, T2 item2, T3 item3, T4 item4) {
			 this.item1 = item1;
			 this.item2 = item2;
			 this.item3 = item3;
			 this.item4 = item4;
		}
		public T1 Item1 {
			get {
				return item1;
			}
		}
		public T2 Item2 {
			get {
				return item2;
			}
		}
		public T3 Item3 {
			get {
				return item3;
			}
		}
		public T4 Item4 {
			get {
				return item4;
			}
		}
		[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }
		public override string ToString () {
			return String.Format ("({0}, {1}, {2}, {3})", Item1, Item2, Item3, Item4);
		}
	}

	public class Tuple<T1, T2, T3, T4, T5> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;
		T2 item2;
		T3 item3;
		T4 item4;
		T5 item5;

		public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) {
			 this.item1 = item1;
			 this.item2 = item2;
			 this.item3 = item3;
			 this.item4 = item4;
			 this.item5 = item5;
		}
		public T1 Item1 {
			get {
				return item1;
			}
		}
		public T2 Item2 {
			get {
				return item2;
			}
		}
		public T3 Item3 {
			get {
				return item3;
			}
		}
		public T4 Item4 {
			get {
				return item4;
			}
		}
		public T5 Item5 {
			get {
				return item5;
			}
		}
		[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }
		public override string ToString () {
			return String.Format ("({0}, {1}, {2}, {3}, {4})", Item1, Item2, Item3, Item4, Item5);
		}
	}

	public class Tuple<T1, T2, T3, T4, T5, T6> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;
		T2 item2;
		T3 item3;
		T4 item4;
		T5 item5;
		T6 item6;

		public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) {
			 this.item1 = item1;
			 this.item2 = item2;
			 this.item3 = item3;
			 this.item4 = item4;
			 this.item5 = item5;
			 this.item6 = item6;
		}
		public T1 Item1 {
			get {
				return item1;
			}
		}
		public T2 Item2 {
			get {
				return item2;
			}
		}
		public T3 Item3 {
			get {
				return item3;
			}
		}
		public T4 Item4 {
			get {
				return item4;
			}
		}
		public T5 Item5 {
			get {
				return item5;
			}
		}
		public T6 Item6 {
			get {
				return item6;
			}
		}
		[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }
		public override string ToString () {
			return String.Format ("({0}, {1}, {2}, {3}, {4}, {5})", Item1, Item2, Item3, Item4, Item5, Item6);
		}
	}

	public class Tuple<T1, T2, T3, T4, T5, T6, T7> : IStructuralEquatable, IStructuralComparable, IComparable
	{
		T1 item1;
		T2 item2;
		T3 item3;
		T4 item4;
		T5 item5;
		T6 item6;
		T7 item7;

		public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) {
			 this.item1 = item1;
			 this.item2 = item2;
			 this.item3 = item3;
			 this.item4 = item4;
			 this.item5 = item5;
			 this.item6 = item6;
			 this.item7 = item7;
		}
		public T1 Item1 {
			get {
				return item1;
			}
		}
		public T2 Item2 {
			get {
				return item2;
			}
		}
		public T3 Item3 {
			get {
				return item3;
			}
		}
		public T4 Item4 {
			get {
				return item4;
			}
		}
		public T5 Item5 {
			get {
				return item5;
			}
		}
		public T6 Item6 {
			get {
				return item6;
			}
		}
		public T7 Item7 {
			get {
				return item7;
			}
		}
		[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }
		[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }
		public override string ToString () {
			return String.Format ("({0}, {1}, {2}, {3}, {4}, {5}, {6})", Item1, Item2, Item3, Item4, Item5, Item6, Item7);
		}
	}


}
	
#endif

#if FALSE

//
// generator script
//

using System;

public class TupleGen
{
	public static void Main () {
		for (int arity = 1; arity < 8; ++arity) {
			Console.Write ("\tpublic class Tuple<");
			for (int i = 1; i <= arity; ++i) {
				Console.Write (String.Format ("T{0}", i));
				if (i < arity)
					Console.Write (", ");
			}
			Console.WriteLine ("> : IStructuralEquatable, IStructuralComparable, IComparable");
			Console.WriteLine ("\t{");
			for (int i = 1; i <= arity; ++i)
				Console.WriteLine (String.Format ("\t\tT{0} item{0};", i));
			Console.WriteLine ();
			Console.Write ("\t\tpublic Tuple (");
			for (int i = 1; i <= arity; ++i) {
				Console.Write (String.Format ("T{0} item{0}", i));
				if (i < arity)
					Console.Write (", ");
			}
			Console.WriteLine (") {");
			for (int i = 1; i <= arity; ++i)
				Console.WriteLine (String.Format ("\t\t\t this.item{0} = item{0};", i));
			Console.WriteLine ("\t\t}");

			for (int i = 1; i <= arity; ++i) {
				Console.WriteLine (String.Format ("\t\tpublic T{0} Item{0} {{", i));
				Console.WriteLine ("\t\t\tget {");
				Console.WriteLine (String.Format ("\t\t\t\treturn item{0};", i));
				Console.WriteLine ("\t\t\t}");
				Console.WriteLine ("\t\t}");
			}

			Console.WriteLine ("\t\t[MonoTODO] int IComparable.CompareTo (object other) { throw new NotImplementedException (); }");
			Console.WriteLine ("\t\t[MonoTODO] int IStructuralComparable.CompareTo (object other, IComparer comparer) { throw new NotImplementedException (); }");
			Console.WriteLine ("\t\t[MonoTODO] bool IStructuralEquatable.Equals (object other, IEqualityComparer comparer) { throw new NotImplementedException (); }");
			Console.WriteLine ("\t\t[MonoTODO] int IStructuralEquatable.GetHashCode (IEqualityComparer comparer) { throw new NotImplementedException (); }");

			Console.WriteLine ("\t\tpublic override string ToString () {");
			Console.Write ("\t\t\treturn String.Format (\"(");
			for (int i = 1; i <= arity; ++i) {
				Console.Write ("{" + (i - 1) + "}");
				if (i < arity)
					Console.Write (", ");
			}
			Console.Write (")\", ");
			for (int i = 1; i <= arity; ++i) {
				Console.Write ("Item" + i);
				if (i < arity)
					Console.Write (", ");
			}
			Console.WriteLine (");");
			Console.WriteLine ("\t\t}");

			Console.WriteLine ("\t}\n");
		}
	}
}

#endif