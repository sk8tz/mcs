* String collation

** Summary

	We are going to implement Windows-like collation, apart from ICU which
	is conformant to Unicode specifications.

** How to implement CompareInfo members

	GetSortKey()
		Compute sort key for every characters into byte[].
		Use collation element table, but Windows specific ones.
	Compare()
		Find first difference and compare it. "Larger/smaller" matters.
	IsPrefix()
		For each character in the target, examine if it matches from 
		the head of the searchee and immediately return false if it 
		didn't match.
	IsSuffix()
		For each character in the target, examine if it matches from 
		the tail of the searchee. If it didn't match, continue to 
		the start of the target if it really does not match in the next
		character (hopefully limited to max size n).
	IndexOf()
		Find first match and process comparison to the end of the 
		string to find

** How to support CompareOptions

	There are two kind of "ignorance" : ignorance which acts as stripper,
	and ignorance acts as normalizer.

	The strippers will "filter characters out" and there will be no
	corresponding character elements in SortKey binaries.

	Normalizers, on the other hand, will result in certain characters 
	that is still in effect between irrelevant character and itself.
	For example, with IgnoreKanaType Hiragana "A" and Katakana "A" are
	not distinguished, but Hiragana "A" and Hiragana "I" are.

	Actually, even without any IgnoreXXX flags (i.e. "None"), there are 
	many characters that are ignored ("completely ignorable").

	For LCID 101/1125(div), '\ufdf2' is completely ignorable.
	This rule even applies to CompareOptions.None.

*** Normalizers

	IgnoreCase
		Maybe culture-dependent TextInfo.ToLower() could be used.

		Unlike ICU (specialCaseToLower()), even with tr-TR(LCID 31)
		and IgnoreCase, I\u0307 is not regarded as equal to i.

	IgnoreKanaType
		ToKanaTypeInsensitive(). See also "Notes".

	IgnoreWidth
		ToWidthInsensitive(), which is likely to be culture
		independent. See also "Notes".

*** Strippers

	I already wrote all the required strippers which should be MS
	compatible (at least with .NET 1.1 invariant culture).

	IgnoreNonSpace
		IsIgnorableNonSpacing().
		Some Diacritic characters are covered by this flag.

		There are some culture *dependent* characters:
			LCID 90/1114(syr) : 64b, 652, 670

	IgnoreSymbols
		IsIgnorableSymbol().
		UnicodeCategory does not work here.

		There are some culture *dependent* characters:
			LCID 17/1041(ja) : 2015
			LCID 90/1114(syr) : 64b, 652

*** StringSort

	Maybe use additional tailoring rule which says that non-alphabetic
	characters does not take precedence.

** ICU and UCA

	First to note: we won't use collation element table from unicode.org.

*** Collation element table tailoring

	To understand why we don't use collation element table from UCA, you
	can try to compare "A" and "a" in the invariant culture.)

** Notes

	Since UCA Level 3 handles both casing and width, it is impossible to
	use UCA variables for IgnoreWidth, at least with the default element
	table. And IgnoreKanaType cannot be handled without case and width
	insensitivity.

	IgnoreWidth/IgnoreSymbols is processed after Kana voice mark
	decomposition (NFD).
	This means, if there is a combined Kana characters, it will be first 
	decomposed and then compared.

	Microsoft implementation seems to have a serious problem that many,
	many characters that are used in for each specific culture, such as
	Myanmar, Mongolian, Cherokee, Etiopic, Tagalog, Khmer, are regarded as
	"completely ignorable".

** MS collation design inference

** sort key format

	00 means the end of sort key.
	01 means the end of the level.
	02-FF means the value.
	If less than or equal to 2 in followings in a level, then the sequence
	of the level is terminated (1). 2 is the default.

	There are 5 levels.

	- level 1: primary difference
	  The first byte of level 1 means the category of the character.
	- level 2: case sensitivity
	- level 3: diacritic difference
	- level 4: kana type (mostly at primary category 22)
	- level 5: control characters etc.

** sort key table

	Here is the simple sortkey dumper:

	public static void Main (string [] args)
	{
		CultureInfo culture = args.Length > 0 ?
			new CultureInfo (args [0]) :
			CultureInfo.InvariantCulture;
		CompareInfo ci = culture.CompareInfo;
		for (int i = 0; i < char.MaxValue; i++) {
			string s = new string ((char) i, 1);
			if (ci.Compare (s, "") == 0)
				continue; // ignored
			byte [] data = ci.GetSortKey (s).KeyData;
			foreach (byte b in data) {
				Console.Write ("{0:X02}", b);
				Console.Write (' ');
			}
			Console.WriteLine (" : {0:X}, {1} {2}",
				i,
				Char.GetUnicodeCategory ((char) i),
				data [2] != 1 ? '!' : ' ');
		}
	}

*** Combined characters

	Some latin+diaeresis sequences are regarded as a single character for
	each.

	Maybe they are combined similarly to what is specified in UCA.

*** Expanded characters

	Some characters are expanded to two or more characters:

	C6 (AE), E6 (ae), 1F1-1F3 (dz), 1C4-1C6 (Dz), FB00-FB06 (ff, fi),
	132-133 (IJ), 1C7-1C9 (LJ), 1CA-1CC (NJ), 152-153 (OE),
	DF (ss), FB06 (st), FB05 (\u017Ft), FE, DE, 5F0-5F2,
	1113-115F (hangul)
	(CJK extension is not really expanded)

	They don't match with any of Unicode normalization.

	Some alphabetic cultures have different mappings, but mostly small
	(at least da-DK, lt-LT, fr-FR, es-ES have tiny differences).

	Invariant culture also puts Czech unique character \u0161 between s
	and t, unlike described here:
	http://www.microsoft.com/globaldev/dis_v1/disv1.asp?DID=dis33d&File=S24C0.asp

	zh-CHS, ko-KR and ja-JP have very different CJK mapping for each
	(but might be just a matter of computation formula differences).

*** sort order categories

	1 (0) specially ignored ones (Japanese, Tamil, Thai)

	3099-309C, BCD, E47, E4C, FF9E, FF9F

	2 (1) maybe nonspacing marks

	2.1 control characters (specified as such in Unicode), except for
	whitespaces (0009-000D).

	2.2 0027,FF07 (')

	2.3  minus sign, hyphen, dash
	  minus signs: FE63, 207B (super), 208B (sub), 002D, 00FD (full-width)
	  hyphens: 00AD (soft), 2010, 2011 (nonbreaking) ... Unicode HYPHEN?
	  dashes, horizontal bars: FE58 ... Unicode DASH?

	2.4 Arabic spacing and equivalents (64B-651, FE70-FE7F)
	  They are part of nonspacing mark, but not equal.

	3 (1) Nonspacing marks mixed
	  30D, 591-5C2, Mn:981-A3C, A4D, A70, A71, ABC, ABD ...

	4 (7) space separators and some kind of marks

	4.1 whitespaces, paragraph separator etc.
	  (White_Space in PropList.txt)

	4.2 other marks ('!', '^', ...)

	5 (8) mathmatical symbols

	6 (9) some other symbols

	7 (A) punctuations

	8 (C) numbers

	9 (E) latin letters (alphabets)
	  upper is 18, lower is 2 (default), diacritics are 19 or more.

	10 (F) greek letters

	...

	   (21) georgian letters

	11 (22) japanese kana letters and symbols

	12 (23) bopomofo letters

	13 (24) syriac/thaana letters

	14 (41-45) surrogate Pt.1

	15 (52-7E) hangul, mixing combined ones
	   52 02 .. 7E C8

	16 (9E-FE) CJK (kangxi etc.), PrivateUse mixed, surrogate Pt.2
	   9E 02 .. FE C1

	17 (FE) CJK extensions (3400-)
	   FE FF 10 02 .. FE FF 29 E9

	18 (FF) Some supplemental Japanese/Arabic marks


** Mono implementation plans

*** sort key element table

	We will contain our own collation element table which will be closer
	to the one from Windows.

	Culture-dependent rules are always "evaluated"; no physical expansion
	is done to the table loaded in memory (it's waste of memory).

*** CharacterIterator

	The match evaluation could not be done char by char - the longest
	possible sequence of characters in the tailored table (e.g. "ch" 
	in Spanish) should be examined. It will be like non-NFD detection.


*** Reference materials

	Developing International Software for Windows 95 and Windows NT
	Appendix D Sort Order for Selected Languages
	http://www.microsoft.com/globaldev/dis_v1/disv1.asp?DID=dis33d&File=S24BF.asp

