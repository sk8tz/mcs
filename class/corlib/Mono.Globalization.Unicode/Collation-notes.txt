* String collation

** Summary

	We are going to implement Windows-like collation, apart from ICU which
	is conformant to Unicode specifications.

** How to implement CompareInfo members

	GetSortKey()
		Compute sort key for every characters into byte[].
		Use collation element table, but Windows specific ones.
	Compare()
		Find first difference and compare it. "Larger/smaller" matters.
	IsPrefix()
		For each character in the target, examine if it matches from 
		the head of the searchee and immediately return false if it 
		didn't match.
	IsSuffix()
		For each character in the target, examine if it matches from 
		the tail of the searchee. If it didn't match, continue to 
		the start of the target if it really does not match in the next
		character (hopefully limited to max size n).
	IndexOf()
		Find head match and process comparison to the end of the 
		string to find.
	LastIndexOf()
		Find tail match and process comparison to the start of the 
		string to find.


** How to support CompareOptions

	There are two kind of "ignorance" : ignorance which acts as stripper,
	and ignorance acts as normalizer.

	The strippers will "filter characters out" and there will be no
	corresponding character elements in SortKey binaries.

	Normalizers, on the other hand, will result in certain characters 
	that is still in effect between irrelevant character and itself.
	For example, with IgnoreKanaType Hiragana "A" and Katakana "A" are
	not distinguished, but Hiragana "A" and Hiragana "I" are.

	Actually, even without any IgnoreXXX flags (i.e. "None"), there are 
	many characters that are ignored ("completely ignorable").

	For LCID 101/1125(div), '\ufdf2' is completely ignorable.
	This rule even applies to CompareOptions.None.

*** Normalizers

	IgnoreCase
		Maybe culture-dependent TextInfo.ToLower() could be used.

		Unlike ICU (specialCaseToLower()), even with tr-TR(LCID 31)
		and IgnoreCase, I\u0307 is not regarded as equal to i.

	IgnoreKanaType
		ToKanaTypeInsensitive(). See also "Notes".

	IgnoreWidth
		ToWidthInsensitive(), which is likely to be culture
		independent. See also "Notes".

*** Strippers

	I already wrote all the required strippers which should be MS
	compatible (at least with .NET 1.1 invariant culture).

	IgnoreNonSpace
		IsIgnorableNonSpacing().
		Some Diacritic characters are covered by this flag.

		There are some culture *dependent* characters:
			LCID 90/1114(syr) : 64b, 652, 670

	IgnoreSymbols
		IsIgnorableSymbol().
		UnicodeCategory does not work here.

		There are some culture *dependent* characters:
			LCID 17/1041(ja) : 2015
			LCID 90/1114(syr) : 64b, 652

*** StringSort

	Maybe use additional tailoring rule which says that non-alphabetic
	characters does not take precedence.

** ICU and UCA

	First to note: we won't use collation element table from unicode.org.

	To understand why we don't use collation element table from UCA, you
	can try to compare "A" and "a" in the invariant culture. Also try some
	characters like C0 that are already combined. They are COMPLETELY
	different form UCA default element table.

	So, the data is completely different, but how about resolution rules?

	Since UCA Level 3 handles both casing and width, it is impossible to
	use UCA variables for IgnoreWidth, at least with the default element
	table. And IgnoreKanaType cannot be handled without case and width
	insensitivity.

	IgnoreWidth/IgnoreSymbols is processed after Kana voice mark
	decomposition (something like NFD, but not equivalent. Example: \u304C
	is completely equivalent to \u304B\u309B, which is not part of NFKD).
	This means, if there is a combined Kana characters, it will be first 
	decomposed and then compared.

*** Microsoft design problem

	Microsoft implementation seems to have a serious problem that many,
	many characters that are used in for each specific culture, such as
	Myanmar, Mongolian, Cherokee, Etiopic, Tagalog, Khmer, are regarded as
	"completely ignorable".


** MS collation design inference

*** sort key format

	00 means the end of sort key.
	01 means the end of the level.
	02-FF means the value.
	If less than 2 in the value at each level, then the sequence of the 
	level is terminated (i.e. the sort key won't contain extraneous '2').

	There are 5 levels:

	- level 1: primary difference
	  The first byte of level 1 means the category of the character.
	- level 2: diacritic difference
	- level 3: case sensitivity
	- level 4: kana type (mostly at primary category 22)
	- level 5: identitcal difference (control characters etc.)

*** sort key table

	Here is the simple sortkey dumper:

	public static void Main (string [] args)
	{
		CultureInfo culture = args.Length > 0 ?
			new CultureInfo (args [0]) :
			CultureInfo.InvariantCulture;
		CompareInfo ci = culture.CompareInfo;
		for (int i = 0; i < char.MaxValue; i++) {
			string s = new string ((char) i, 1);
			if (ci.Compare (s, "") == 0)
				continue; // ignored
			byte [] data = ci.GetSortKey (s).KeyData;
			foreach (byte b in data) {
				Console.Write ("{0:X02}", b);
				Console.Write (' ');
			}
			Console.WriteLine (" : {0:X}, {1} {2}",
				i,
				Char.GetUnicodeCategory ((char) i),
				data [2] != 1 ? '!' : ' ');
		}
	}

*** Composite character processing

	Diacritics are not regarded as a base character when placed after 
	(maybe some kind of) letters.

	The behavior is diacritic character dependent. For example, Japanese
	combination of a Kana character and a voice mark is compulsory (the
	resulting sort key is regarded as identical to the corresponding
	single character. Try \u304B\u309B with \u304C. It is invariant).

	In French cultures, diacritic orderings are checked from right to left.

	<del>
	By default, there is no composite form.
	http://www.microsoft.com/globaldev/dis_v1/disv1.asp?DID=dis33d&File=S24C2.asp
	</del>
	This is not true. \u00E6 is regarded as equivalent to "ae".

	The correspoinding implementation will be namely "CharacterIterator".

*** Expanded character processing

	Some characters are expanded to two or more characters:

	C6 (AE), E6 (ae), 1F1-1F3 (dz), 1C4-1C6 (Dz), FB00-FB06 (ff, fi),
	132-133 (IJ), 1C7-1C9 (LJ), 1CA-1CC (NJ), 152-153 (OE),
	DF (ss), FB06 (st), FB05 (\u017Ft), FE, DE, 5F0-5F2,
	1113-115F (hangul)
	(CJK extension is not really expanded)

	They don't match with any of Unicode normalization.

	Some alphabetic cultures have different mappings, but mostly small
	(at least da-DK, lt-LT, fr-FR, es-ES have tiny differences).

	Invariant culture also puts Czech unique character \u0161 between s
	and t, unlike described here:
	http://www.microsoft.com/globaldev/dis_v1/disv1.asp?DID=dis33d&File=S24C0.asp

	zh-CHS, ko-KR and ja-JP have very different CJK mapping for each
	(but might be just a matter of computation formula differences).

*** sort order categories

	1 (0) specially ignored ones (Japanese, Tamil, Thai)

	3099-309C, BCD, E47, E4C, FF9E, FF9F

	2 (1) maybe nonspacing marks

	2.1 control characters (specified as such in Unicode), except for
	whitespaces (0009-000D).

	2.2 0027,FF07 (')

	2.3  minus sign, hyphen, dash
	  minus signs: FE63, 207B (super), 208B (sub), 002D, 00FD (full-width)
	  hyphens: 00AD (soft), 2010, 2011 (nonbreaking) ... Unicode HYPHEN?
	  dashes, horizontal bars: FE58 ... UnicodeCategory.DashPunctuation

	2.4 Arabic spacing and equivalents (64B-651, FE70-FE7F)
	  They are part of nonspacing mark, but not equal.

	3 (1) Nonspacing marks mixed.
	  ModifierSymbol except for < 128
	  NonSpacingMark which is ignorable (IsIgnorableNonSpacing())
	  30D, CD5-CD6, ABD, 2B9-2C1, 2C8, 2CB-2CD, 591-5C2, Mn:981-A3C,
	  A4D, A70, A71, ABC ...

	  This part of MS table is buggy: \u0592 should not be equal to \u09BC
	  Harmless solution: We should not mix those code (make sequential).

	4 (7) space separators and some kind of marks

	4.1 whitespaces, paragraph separator etc.
	  UnicodeCategory.SpaceSeparator : 20, 3000, A0, 9-D, 2000-200B

	4.2 some OtherSymbols: 2422-2423

	4.3 other marks ('!', '^', ...)
	  Non-alpha-numeric < 0x7F except for '+' (math) and '-' (math/hyphen)
	  some Punctuations: InitialQuote/FinalQuote/Open/Close/Connector
	  some OtherSymbols: 2400-2424
	  3003, 3006, 2D0, 10FB
	  remaining Puncuations: 9xx, 7xx
	  70F (Format)

	5 (8) mathmatical symbols
	  InitialQuotePunctuation and FinalQuotePunctuation in ASCII
	  (not Quotation_Mark property in PropList.txt ; 22, 27)

	  byte area MathSymbol: 2B,3C,3D,3E,AB,B1,BB,D7,F7 except for AC
	  MathSymbol (2044, 208A, 208C, 207A, 207C)
	  OtherLetter (1C0-1C2)
	  2200-22FF MathSymbol except for 221E (INF.)

	6 (9) Arrows and Box drawings
	  09 02 .. 09 7C : 2300-237A
	  09 BC 01 03 .. : 25A0-AB, 25E7-EB, 25AC-B5, 25EC-EF, 25B6-B9,
	  		   25BC-C3, 25BA-25BB, 25C4-25D8, 25E6, 25DA-25E5
			   21*,25*,26*,27*
	  2190- (non-codepoint order)
	  	note that there are many compatibility equivalents
	  2500- except for 266F (#)

	7 (A) currency sumbols and some punctuations
	  byte CurrencySymbols except for 24 ($)
	  byte OtherSymbols (A7-B6) 
	  ConnectorPunctuation - 2040 (i.e. FF65, 30FB)
	  OtherPunct/ConnectorPunct/CurrencyCymbol 2020-20AC - 20AC
	  OtherSymbol 3012-303F,3004,327F
	  MathSymbol/OtherSymbol 2600-2767 (math = 266F)
	  OtherSymbol 2440-244A, 2117
	  20AC (CurrencySymbol)

	8 (C) numbers
	  all DecimalDigitNumber, LetterNumber, non-CJK OtherNumber
	  9F8
	  digits, in numeric order. We can use NET_2_0 CharUnicodeInfo.
	  221E (INF.)

	9 (E) latin letters (alphabets)
	  upper is 18, lower is 2 (default), diacritics are 19 or more.
	  F8-2B8 - (1BB-1BD, 1C0-1C3) but not sequential
	  2E0-2E3

	10 (F) greek letters
	  0F: 386-3F2
	  10: 400-4E9 exc. 482-486
	  11: 531-586 exc. 559-55F
	  12: 5D0-5F2
	  13: 621-64A, 670-6D3, 6D5
	  14: 901-963 exc. 93C-93D 950-954
	  15: 982-9FA exc. NonSpacingMark DecimalDigitNumber OtherNumber
	  16: A05-A74 exc. A3C A4D A66-A71
	  17: A81-AE0 exc. ABC-ABD
	  18: 

	...

	   (21) georgian letters

	11 (22) japanese kana letters and symbols

	12 (23) bopomofo letters

	13 (24) syriac/thaana letters
	  710-72C exc. 711, 780-7A5

	14 (41-45) surrogate Pt.1

	15 (52-7E) hangul, mixing combined ones
	   52 02 .. 7E C8

	16 (9E-FE) CJK (kangxi etc.), PrivateUse mixed, surrogate Pt.2
	   9E 02 .. FE C1

	17 (FE) CJK extensions (3400-)
	   FE FF 10 02 .. FE FF 29 E9

	18 (FF) Some supplemental Japanese/Arabic marks


	- by UnicodeCategory -
	DashPunctuation		1 1 1 1 (no exception)
	DecimalDigitNumber	C (no exception)
	EnclosingMark		1 E (no exception)
	Format			7 (only 70F)
	LetterNumber		C (no exception)
	LineSeparator		7 (only 2028)
	ParagraphSeparator	7 (only 2029)
	PrivateUse
	SpaceSeparator		7 (no exception)
	Surrogate

	OtherNumber		C(<3192), 9E-A7 (3124<)

	Control			1 1 1 1 except for 9-D (7)
	FinalQuotePunctuation	7 except for BB (8)
	InitialQuotePunctuation	7 except for AB (8)
	ClosePunctuation	7 except for 232A (9)
	OpenPunctuation		7 except for 2329 (9)
	ConnectorPunctuation	7 except for FF65, 30FB, 2040 (A)

	OtherLetter		1, 7, 8 (1C0-1C2), C, 12-FF
	MathSymbol		8, 9, 1 1 1 1, 7, A, C
	OtherSymbol		7, 9, A, C, E, F, <22, 52<
	CurrencySymbol		A except for FF69,24,FF04 (7) and 9F2,9F3 (15)

	LowercaseLetter		E-11 except for B5 (A) and 1BD (C)
	TitlecaseLetter		E (no exception)
	UppercaseLetter		E,F,10,11,21 except for 1BC (C)
	ModifierLetter		1, 7, E, 1F, FF
	ModifierSymbol		1 1 1 1, 1, 7
	NonSpacingMark		1 1 1 1, 1, 13-1F
	OtherPunctuation	1, 7, A, 1F
	SpacingCombiningMark	1, 14-22

*** Culture dependent design

	(To assure this section, run the simple dumper code shown above,
	with all the supported cultures.)

	For each sub culture (that has a parent culture), its collation
	mapping is identical to that of its parent.

	Additionally,

	- zh-CHS = zh-CN = zh-SG = zh-MO
	- zh-TW = zh-HK = zh-CHT
	- da = no
	- fi = sv
	- hr = sr

	(UCA implies that there are some cultures that sorts alphabets from
	large to small, but as long as I see there is no such CultureInfo.)

**** Latin characters and NonSpacingMark order tailorings

	div : FDF2 is 24 83 01 01 01 01 00 (only 1 difference)
	syr : some NonSpacingMarks are totally ignorable.
	tt,kk,mk,az-AZ-Cyrl,uk : cyrillic difference
	az,et,lt,lv,sl,tr,sv,ro,pl,no,is,hu,fi,es,da : latin difference
	fr : 1C4-1C6.
	sk,hr,cs : latin and NonSpacingMark differences

	ja,ko : 5C

**** CJK character order tailorings

	There are five different CJK orderings:
	default, ko(-KR), ja(-JP), zh-CHS and zh-TW

	ko : CJK layout difference (52 -> 80)
	ja,zh-CHS,zh-TW : dash (5C), CJK layout difference.

	Target characters are : CJK misc (3190-), Parenthesized CJK
	(3200-), CJK compat (3300-), CJK ideographs (4E00-),
	CJK compat ideograph (F900-), Half/Full width compat (FF00-)

	Additionally for Korean: Jamo (1100-), Hangle syllables (AC00)

	Since they are mostly computational differences, we are not likely to
	extend those character weights into constant tables.

**** Accent evaluation order

	With French cultures, diacritical marks must be put *in front of the
	character being decorated (aka French ordering).
	French ordering does not affect only on some diacritics (Japanese
	voice mark is not affected).

	Some other cultures might also have different ones, but not obvious.


** Mono implementation plans

*** CultureInfoImpl

	CultureInfo contains many overloaded methods that are just for 
	convenience. This class contains only required members.

*** CharacterIterator

	The match evaluation could not be done char by char - the longest
	possible sequence of characters in the tailored table (e.g. "ch" 
	in Spanish) should be examined.

	(Some examples can be seen in UTR#10).

	It should work like TextElementEnumerator but should not result in a
	bunch of string instances. The simple set of below is enough:

	- MoveNext(),
	- Index,
	- ElementLength, and
	- Reset()

	They could be implemented as an internal virtual method of CompareInfo.

	This resolves combined characters and expanded characters, including
	French accent orderings.

*** sort key element table

	We will contain our own collation element table which is closer
	to the one from Windows than UCA default element table.

	Culture-dependent rules are always "evaluated"; no physical expansion
	is done to the table loaded in memory (it's waste of memory).


** Reference materials

	Developing International Software for Windows 95 and Windows NT
	Appendix D Sort Order for Selected Languages
	http://www.microsoft.com/globaldev/dis_v1/disv1.asp?DID=dis33d&File=S24BF.asp

	UTR#10 Unicode Collation Algorithm (It is still informative)
	http://www.unicode.org/reports/tr10/

	UAX#15 Unicode Normalization
	http://www.unicode.org/reports/tr15/
	especially its canonical/compatibility equivalent characters might
	be informative to get those equivalent characters.
	
	To know which character can be expanded, Unicode Character Database
	(UCD) is informative (it's informative but not normative to us)
	http://www.unicode.org/Public/UNIDATA/UCD.html

	Wine uses UCA default element table, but has windows-like character
	filterings support in their LCMapString implementation:
	http://cvs.winehq.com/cvsweb/wine/dlls/kernel/locale.c
	http://cvs.winehq.com/cvsweb/wine/libs/unicode/sortkey.c
