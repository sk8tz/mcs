//
// MACTripleDES.cs: Handles MAC with TripleDES
//
// Author:
//	Sebastien Pouliot (spouliot@motus.com)
//
// (C) 2002, 2003 Motus Technologies Inc. (http://www.motus.com)
//

using System;

namespace System.Security.Cryptography {

// References:
// a.	FIPS PUB 81: DES MODES OF OPERATION 
//	MAC: Appendix F (MACDES not MACTripleDES but close enough ;-)
//	http://www.itl.nist.gov/fipspubs/fip81.htm

// Generic MAC mechanims - most of the work is done in here
// It should work with any symmetric algorithm function e.g. DES for MACDES (fips81)
internal class MACAlgorithm {
	private SymmetricAlgorithm algo;
	private ICryptoTransform enc;
	private byte[] block;
	private int blockSize;	// in bytes (not in bits)
	private int blockCount;

	public MACAlgorithm (SymmetricAlgorithm algorithm) 
	{
		algo = (SymmetricAlgorithm) algorithm;
		algo.Mode = CipherMode.CBC;
		algo.Padding = PaddingMode.Zeros;
		blockSize = (algo.BlockSize >> 3);
		algo.IV = new byte [blockSize];
		block = new byte [blockSize];
	}

	public void Initialize (byte[] key) 
	{
		algo.Key = key;
		Array.Clear (block, 0, blockSize);
		blockCount = 0;
		// note: the encryptor transform amy be reused - see Final
		if (enc == null)
			enc = algo.CreateEncryptor ();
	}
	
	public void Core (byte[] rgb, int ib, int cb) 
	{
		// 1. fill the rest of the "block"
		int n = Math.Min (blockSize - blockCount, cb);
		Array.Copy (rgb, ib, block, blockCount, n); 
		blockCount += n;

		// 2. if block is full then transform it
		if (blockCount == blockSize) {
			enc.TransformBlock (block, 0, blockSize, block, 0);

			// 3. transform any other full block in specified buffer
			int b = (int) ((cb - n) / blockSize);
			for (int i=0; i < b; i++) {
				enc.TransformBlock (rgb, n, blockSize, block, 0);
				n += blockSize;
			}

			// 4. if data is still present fill the "block" with the remainder
			blockCount = cb - n;
			if (blockCount > 0)
				Array.Copy (rgb, n, block, 0, blockCount);
		}
	}

	public byte[] Final () 
	{
		byte[] mac = enc.TransformFinalBlock (block, 0, blockCount);
		if (!enc.CanReuseTransform) {
			enc.Dispose();
			enc = null;
		}
		return mac;
	}
}

// LAMESPEC: MACTripleDES == MAC-CBC using TripleDES (not MAC-CFB).
public class MACTripleDES: KeyedHashAlgorithm {

	private TripleDES tdes;
	private MACAlgorithm mac;
	private bool m_disposed;

	public MACTripleDES () 
	{
		tdes = TripleDES.Create ();
		// this will use the key generated by TripleDES
		Setup ();
	}

	public MACTripleDES (byte[] rgbKey)
	{
		tdes = TripleDES.Create ();
		// this way we get the TripleDES key validation (like weak
		// and semi-weak keys)
		tdes.Key = rgbKey;
		Setup ();
	}

	public MACTripleDES (string strTripleDES, byte[] rgbKey)
	{
		tdes = TripleDES.Create (strTripleDES);
		// this way we get the TripleDES key validation (like weak
		// and semi-weak keys)
		tdes.Key = rgbKey;
		Setup ();
	}

	private void Setup () 
	{
		HashSizeValue = tdes.BlockSize;
		// we use Key property to get the additional validations 
		// (from KeyedHashAlgorithm ancestor)
		Key = tdes.Key;
		mac = new MACAlgorithm (tdes);
		m_disposed = false;
	}

	~MACTripleDES () 
	{
		Dispose (false);
	}

	protected override void Dispose (bool disposing) 
	{
		if (!m_disposed) {
			// note: we ALWAYS zeroize keys (disposing or not)

			// clear our copy of the secret key
			if (KeyValue != null)
				Array.Clear (KeyValue, 0, KeyValue.Length);
			// clear the secret key (inside TripleDES)
			if (tdes != null)
				tdes.Clear ();

			if (disposing) {
				// disposed managed stuff
				KeyValue = null;
				tdes = null;
			}
			// ancestor
			base.Dispose (disposing);
			m_disposed = true;
		}
	}

	public override void Initialize () 
	{
		if (m_disposed)
			throw new ObjectDisposedException ("MACTripleDES");
		State = 0;
		mac.Initialize (KeyValue);
	}

	protected override void HashCore (byte[] rgb, int ib, int cb) 
	{
		if (m_disposed)
			throw new ObjectDisposedException ("MACTripleDES");
		if (State == 0)
			Initialize ();
		State = 1;
		mac.Core (rgb, ib, cb);
	}

	protected override byte[] HashFinal () 
	{
		if (m_disposed)
			throw new ObjectDisposedException ("MACTripleDES");
		State = 0;
		return mac.Final ();
	}
}

}