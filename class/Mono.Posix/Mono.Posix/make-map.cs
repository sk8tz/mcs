//
// MakeMap.cs: Builds a C map of constants defined on C# land
//
// Authors:
//  Miguel de Icaza (miguel@novell.com)
//  Jonathan Pryor (jonpryor@vt.edu)
//
// (C) 2003 Novell, Inc.
// (C) 2004 Jonathan Pryor
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.IO;
using System.Reflection;

delegate void CreateFileHandler (string assembly_name, string file_prefix);
delegate void AssemblyAttributesHandler (Assembly assembly);
delegate void TypeHandler (Type t, string ns, string fn, string etype, bool bits);
delegate void CloseFileHandler (string file_prefix);

class MakeMap {

	public static int Main (string [] args)
	{
		FileGenerator[] generators = new FileGenerator[]{
			new HeaderFileGenerator (),
			new SourceFileGenerator (),
			new WrapperFileGenerator ()
		};

		MakeMap composite = new MakeMap ();
		foreach (FileGenerator g in generators) {
			composite.FileCreators += new CreateFileHandler (g.CreateFile);
			composite.AssemblyAttributesHandler += 
				new AssemblyAttributesHandler (g.WriteAssemblyAttributes);
			composite.TypeHandler += new TypeHandler (g.WriteType);
			composite.FileClosers += new CloseFileHandler (g.CloseFile);
		}

		return composite.Run (args);
	}

	event CreateFileHandler FileCreators;
	event AssemblyAttributesHandler AssemblyAttributesHandler;
	event TypeHandler TypeHandler;
	event CloseFileHandler FileClosers;

	int Run (string[] args)
	{
		if (args.Length != 2){
			Console.WriteLine ("Usage is: make-map assembly output");
			return 1;
		}
		
		string assembly_name = args[0];
		string output = args[1];

		FileCreators (assembly_name, output);

		Assembly assembly = Assembly.LoadFrom (assembly_name);
		AssemblyAttributesHandler (assembly);
		
		Type [] exported_types = assembly.GetTypes ();
			
		foreach (Type t in exported_types) {
			bool bits;
			if (!CanMapType (t, out bits))
				continue;

			string fn = t.FullName.Replace (".", "_");
			string ns = t.Namespace.Replace (".", "_");
      string etype = GetNativeType (t);

			TypeHandler (t, ns, fn, etype, bits);
		}
		FileClosers (output);

		return 0;
	}

	static bool CanMapType (Type t, out bool bits)
	{
		object [] attributes = t.GetCustomAttributes (false);
		bool map = false;
		bits = false;
		
		foreach (object attr in attributes) {
			if (attr.GetType ().Name == "MapAttribute")
				map = true;
			if (attr.GetType ().Name == "FlagsAttribute")
				bits = true;
		}
		return map;
	}

	static string GetNativeType (Type t)
	{
		string ut = Enum.GetUnderlyingType (t).Name;
		switch (ut) {
			case "Byte":   return "unsigned char";
			case "SByte":  return "signed char";
			case "Int16":  return "short";
			case "UInt16": return "unsigned short";
			case "Int32":  return "int";
			case "UInt32": return "unsigned int";
			case "Int64":  return "gint64";
			case "UInt64": return "guint64";
		}
		return "int /* **unknown** " + ut + " */";
	}
}

abstract class FileGenerator {
	public abstract void CreateFile (string assembly_name, string file_prefix);

	public virtual void WriteAssemblyAttributes (Assembly assembly)
	{
	}

	public abstract void WriteType (Type t, string ns, string fn, string etype, bool bits);
	public abstract void CloseFile (string file_prefix);

	protected static void WriteHeader (StreamWriter s, string assembly)
	{
		s.WriteLine (
			"/*\n" +
			" * This file was automatically generated by make-map from {0}.\n" +
			" *\n" +
			" * DO NOT MODIFY.\n" +
			" */\n", assembly);
	}
}

class HeaderFileGenerator : FileGenerator {
	StreamWriter sh;

	public override void CreateFile (string assembly_name, string file_prefix)
	{
		sh = File.CreateText (file_prefix + ".h");
		WriteHeader (sh, assembly_name);
		sh.WriteLine ("#ifndef INC_Mono_Posix_" + file_prefix + "_H");
		sh.WriteLine ("#define INC_Mono_Posix_" + file_prefix + "_H\n");
		sh.WriteLine ("#include <glib/gtypes.h>\n");
		sh.WriteLine ("G_BEGIN_DECLS\n");
	}

	public override void WriteType (Type t, string ns, string fn, string etype, bool bits)
	{
		WriteLiteralValues (sh, t, fn);
		sh.WriteLine ("int {1}_From{2} ({0} x, {0} *r);", etype, ns, t.Name);
		sh.WriteLine ("int {1}_To{2} ({0} x, {0} *r);", etype, ns, t.Name);
		sh.WriteLine ();
	}

	static void WriteLiteralValues (StreamWriter sh, Type t, string n)
	{
		object inst = Activator.CreateInstance (t);
		foreach (FieldInfo fi in t.GetFields ()){
			if (!fi.IsLiteral)
				continue;
			sh.WriteLine ("#define {0}_{1} 0x{2:x}", n, fi.Name, fi.GetValue (inst));
		}
	}

	public override void CloseFile (string file_prefix)
	{
		sh.WriteLine ("G_END_DECLS\n");
		sh.WriteLine ("#endif /* ndef INC_Mono_Posix_" + file_prefix + "_H */\n");
		sh.Close ();
	}
}

class SourceFileGenerator : FileGenerator {
	StreamWriter sc;

	public override void CreateFile (string assembly_name, string file_prefix)
	{
		sc = File.CreateText (file_prefix + ".c");
		WriteHeader (sc, assembly_name);

		if (file_prefix.IndexOf ("/") != -1)
			file_prefix = file_prefix.Substring (file_prefix.IndexOf ("/") + 1);
		sc.WriteLine ("#include \"{0}.h\"", file_prefix);
		sc.WriteLine ();
	}

	public override void WriteAssemblyAttributes (Assembly assembly)
	{
		object [] x = assembly.GetCustomAttributes (false);
		Console.WriteLine ("Got: " + x.Length);
		foreach (object aattr in assembly.GetCustomAttributes (false)) {
			Console.WriteLine ("Got: " + aattr.GetType ().Name);
			if (aattr.GetType ().Name == "IncludeAttribute"){
				WriteDefines (sc, aattr);
				WriteIncludes (sc, aattr);
			}
		}
	}

	static void WriteDefines (TextWriter writer, object o)
	{
		PropertyInfo prop = o.GetType ().GetProperty ("Defines");
		if (prop == null)
			throw new Exception ("Cannot find 'Defines' property");

		MethodInfo method = prop.GetGetMethod ();
		string [] defines = (string []) method.Invoke (o, null);
		foreach (string def in defines) {
			writer.WriteLine ("#ifndef {0}", def);
			writer.WriteLine ("#define {0}", def);
			writer.WriteLine ("#endif /* ndef {0} */", def);
		}
	}

	static void WriteIncludes (TextWriter writer, object o)
	{
		PropertyInfo prop = o.GetType ().GetProperty ("Includes");
		if (prop == null)
			throw new Exception ("Cannot find 'Includes' property");

		MethodInfo method = prop.GetGetMethod ();
		string [] includes = (string []) method.Invoke (o, null);
		foreach (string inc in includes)
			writer.WriteLine ("#include <{0}>", inc);
		writer.WriteLine ();
	}

	public override void WriteType (Type t, string ns, string fn, string etype, bool bits)
	{
		WriteFromManagedType (t, ns, fn, etype, bits);
		WriteToManagedType (t, ns, fn, etype, bits);
	}

	private void WriteFromManagedType (Type t, string ns, string fn, string etype, bool bits)
	{
		sc.WriteLine ("int {1}_From{2} ({0} x, {0} *r)", etype, ns, t.Name);
		sc.WriteLine ("{");
		sc.WriteLine ("\t*r = 0;");
		// For many values, 0 is a valid value, but doesn't have it's own symbol.
		// Examples: Error (0 means "no error"), WaitOptions (0 means "no options").
		// Make 0 valid for all conversions.
		sc.WriteLine ("\tif (x == 0)\n\t\treturn 0;");
		foreach (FieldInfo fi in t.GetFields ()) {
			if (!fi.IsLiteral)
				continue;
			if (bits)
				// properly handle case where [Flags] enumeration has helper
				// synonyms.  e.g. DEFFILEMODE and ACCESSPERMS for mode_t.
				sc.WriteLine ("\tif ((x & {0}_{1}) == {0}_{1})", fn, fi.Name);
			else
				sc.WriteLine ("\tif (x == {0}_{1})", fn, fi.Name);
			sc.WriteLine ("#ifdef {0}", fi.Name);
			if (bits)
				sc.WriteLine ("\t\t*r |= {1};", fn, fi.Name);
			else
				sc.WriteLine ("\t\t{{*r = {1}; return 0;}}", fn, fi.Name);
			sc.WriteLine ("#else /* def {0} */\n\t\t{{errno = EINVAL; return -1;}}", fi.Name);
			sc.WriteLine ("#endif /* ndef {0} */", fi.Name);
		}
		if (bits)
			sc.WriteLine ("\treturn 0;");
		else
			sc.WriteLine ("\terrno = EINVAL; return -1;"); // return error if not matched
		sc.WriteLine ("}\n");
	}

	private void WriteToManagedType (Type t, string ns, string fn, string etype, bool bits)
	{
		sc.WriteLine ("int {1}_To{2} ({0} x, {0} *r)", etype, ns, t.Name);
		sc.WriteLine ("{");
		sc.WriteLine ("\t*r = 0;", etype);
		// For many values, 0 is a valid value, but doesn't have it's own symbol.
		// Examples: Error (0 means "no error"), WaitOptions (0 means "no options").
		// Make 0 valid for all conversions.
		sc.WriteLine ("\tif (x == 0)\n\t\treturn 0;");
		foreach (FieldInfo fi in t.GetFields ()) {
			if (!fi.IsLiteral)
				continue;
			sc.WriteLine ("#ifdef {0}", fi.Name);
			if (bits)
				// properly handle case where [Flags] enumeration has helper
				// synonyms.  e.g. DEFFILEMODE and ACCESSPERMS for mode_t.
				sc.WriteLine ("\tif ((x & {1}) == {1})\n\t\t*r |= {0}_{1};", fn, fi.Name);
			else
				sc.WriteLine ("\tif (x == {1})\n\t\t{{*r = {0}_{1}; return 0;}}", fn, fi.Name);
			sc.WriteLine ("#endif /* ndef {0} */", fi.Name);
		}
		if (bits)
			sc.WriteLine ("\treturn 0;");
		else
			sc.WriteLine ("\terrno = EINVAL; return -1;");
		sc.WriteLine ("}\n");
	}

	public override void CloseFile (string file_prefix)
	{
		sc.Close ();
	}
}

class WrapperFileGenerator : FileGenerator {
	StreamWriter scs;

	public override void CreateFile (string assembly_name, string file_prefix)
	{
		scs = File.CreateText (file_prefix + ".cs");
		WriteHeader (scs, assembly_name);
		scs.WriteLine ("using System;");
		scs.WriteLine ("using System.Runtime.InteropServices;");
		scs.WriteLine ("using Mono.Posix;\n");
		scs.WriteLine ("namespace Mono.Posix {\n");
		scs.WriteLine ("\tpublic sealed /* static */ class PosixConvert");
		scs.WriteLine ("\t{");
		scs.WriteLine ("\t\tprivate PosixConvert () {}\n");
		scs.WriteLine ("\t\tprivate const string LIB = \"MonoPosixHelper\";\n");
		scs.WriteLine ("\t\tprivate static void ThrowArgumentException (object value)");
		scs.WriteLine ("\t\t{");
		scs.WriteLine ("\t\t\tthrow new ArgumentOutOfRangeException (\"value\", value,");
		scs.WriteLine ("\t\t\t\tLocale.GetText (\"Current platform doesn't support this value.\"));");
		scs.WriteLine ("\t\t}\n");
	}

	public override void WriteType (Type t, string ns, string fn, string etype, bool bits)
	{
		string mtype = Enum.GetUnderlyingType(t).Name;
		scs.WriteLine ("\t\t[DllImport (LIB, " + 
			"EntryPoint=\"{0}_From{1}\")]\n" +
			"\t\tprivate static extern int From{1} ({1} value, out {2} rval);\n",
			ns, t.Name, mtype);
		scs.WriteLine ("\t\tpublic static bool TryFrom{1} ({1} value, out {2} rval)\n" +
			"\t\t{{\n" +
			"\t\t\treturn From{1} (value, out rval) == 0;\n" +
			"\t\t}}\n", ns, t.Name, mtype);
		scs.WriteLine ("\t\tpublic static {0} From{1} ({1} value)", mtype, t.Name);
		scs.WriteLine ("\t\t{");
		scs.WriteLine ("\t\t\t{0} rval;", mtype);
		scs.WriteLine ("\t\t\tif (From{0} (value, out rval) == -1)\n" + 
				"\t\t\t\tThrowArgumentException (value);", t.Name);
		scs.WriteLine ("\t\t\treturn rval;");
		scs.WriteLine ("\t\t}\n");
		scs.WriteLine ("\t\t[DllImport (LIB, " + 
			"EntryPoint=\"{0}_To{1}\")]\n" +
			"\t\tprivate static extern int To{1} ({2} value, out {1} rval);\n",
			ns, t.Name, mtype);
		scs.WriteLine ("\t\tpublic static bool TryTo{1} ({0} value, out {1} rval)\n" +
			"\t\t{{\n" +
			"\t\t\treturn To{1} (value, out rval) == 0;\n" +
			"\t\t}}\n", mtype, t.Name);
		scs.WriteLine ("\t\tpublic static {1} To{1} ({0} value)", mtype, t.Name);
		scs.WriteLine ("\t\t{");
		scs.WriteLine ("\t\t\t{0} rval;", t.Name);
		scs.WriteLine ("\t\t\tif (To{0} (value, out rval) == -1)\n" + 
				"\t\t\t\tThrowArgumentException (value);", t.Name);
		scs.WriteLine ("\t\t\treturn rval;");
		scs.WriteLine ("\t\t}\n");
	}

	public override void CloseFile (string file_prefix)
	{
		scs.WriteLine ("\t}");
		scs.WriteLine ("}\n");
		scs.Close ();
	}
}

// vim: noexpandtab
