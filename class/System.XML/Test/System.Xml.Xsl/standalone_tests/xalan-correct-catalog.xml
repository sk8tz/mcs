<?xml version="1.0" encoding="UTF-8"?>
<test-suite>
<test-catalog submitter="Lotus">
<creator>Lotus/IBM</creator>
<date>2001-11-16</date>
	<test-case category="XSLT-Result-Tree" id="attribset_attribset01">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set attribute of a LRE from single attribute set.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset01.xml</input-file>
<input-file role="principal-stylesheet">attribset01.xsl</input-file>
<output-file role="principal" compare="XML">attribset01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset02">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set attributes of a LRE from multiple attribute sets.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset02.xml</input-file>
<input-file role="principal-stylesheet">attribset02.xsl</input-file>
<output-file role="principal" compare="XML">attribset02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset03">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with multiple attribute sets.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset03.xml</input-file>
<input-file role="principal-stylesheet">attribset03.xsl</input-file>
<output-file role="principal" compare="XML">attribset03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset04">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:copy with multiple attribute sets, no conflicts.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset04.xml</input-file>
<input-file role="principal-stylesheet">attribset04.xsl</input-file>
<output-file role="principal" compare="XML">attribset04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset05">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set attributes of a LRE using attribute sets that inherit.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset05.xml</input-file>
<input-file role="principal-stylesheet">attribset05.xsl</input-file>
<output-file role="principal" compare="XML">attribset05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset06">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set attributes of a LRE using attribute sets that inherit, plus add overlapping attribute with xsl:attribute.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset06.xml</input-file>
<input-file role="principal-stylesheet">attribset06.xsl</input-file>
<output-file role="principal" compare="XML">attribset06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset07">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set attributes of a LRE using attribute sets that inherit, but have overlapping attributes.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset07.xml</input-file>
<input-file role="principal-stylesheet">attribset07.xsl</input-file>
<output-file role="principal" compare="XML">attribset07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset08">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with attribute sets that inherit, plus add overlapping attribute with xsl:attribute.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset08.xml</input-file>
<input-file role="principal-stylesheet">attribset08.xsl</input-file>
<output-file role="principal" compare="XML">attribset08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset09">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:copy with attribute sets that inherit, plus add overlapping attribute with xsl:attribute.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset09.xml</input-file>
<input-file role="principal-stylesheet">attribset09.xsl</input-file>
<output-file role="principal" compare="XML">attribset09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset10">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set attributes of an LRE, using attribute sets whose names overlap, plus add overlapping attribute with xsl:attribute.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset10.xml</input-file>
<input-file role="principal-stylesheet">attribset10.xsl</input-file>
<output-file role="principal" compare="XML">attribset10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset11">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<spec-citation place="" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset11.xml</input-file>
<input-file role="principal-stylesheet">attribset11.xsl</input-file>
<output-file role="principal" compare="XML">attribset11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset12">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set attributes of an LRE, using one attribute set with multiple attributes, and one overriding LRE attribute, and one overriding xsl:attribute attribute.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset12.xml</input-file>
<input-file role="principal-stylesheet">attribset12.xsl</input-file>
<output-file role="principal" compare="XML">attribset12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset13">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Creating attribute for Literal Result Element. The expanded-name of the attribute to be created is specified by a required name attribute and an optional namespace attribute</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset13.xml</input-file>
<input-file role="principal-stylesheet">attribset13.xsl</input-file>
<output-file role="principal" compare="XML">attribset13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset14">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with attribute having a namespace. The expanded-name of the attribute to be created is specified by a required name attribute and an optional namespace attribute</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset14.xml</input-file>
<input-file role="principal-stylesheet">attribset14.xsl</input-file>
<output-file role="principal" compare="XML">attribset14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset15">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>The name attribute is interpreted as an attribute value template. It is an error if the value of the AVT is not a QNAME or the string "xmlns". (Last two xsl:attributes test this)</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="attribute-name-not-QName"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">attribset15.xml</input-file>
<input-file role="principal-stylesheet">attribset15.xsl</input-file>
<output-file role="principal" compare="XML">attribset15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset16">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>The namespace attribute is interpreted as an attribute value template.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset16.xml</input-file>
<input-file role="principal-stylesheet">attribset16.xsl</input-file>
<output-file role="principal" compare="XML">attribset16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset17">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Verify that 'checked' attribute of HTML element input is correctly set.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset17.xml</input-file>
<input-file role="principal-stylesheet">attribset17.xsl</input-file>
<output-file role="principal" compare="XML">attribset17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset18">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Verify adding an attribute to an element replaces any existing attribute of that element with the same expanded name.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset18.xml</input-file>
<input-file role="principal-stylesheet">attribset18.xsl</input-file>
<output-file role="principal" compare="XML">attribset18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset19">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Verify adding an attribute to an element after children have been added to it is an error. The attributes can be ignored.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset19.xml</input-file>
<input-file role="principal-stylesheet">attribset19.xsl</input-file>
<output-file role="principal" compare="XML">attribset19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset20">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for selecting attributes with xml namespace prefix.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">attribset20.xml</input-file>
<input-file role="principal-stylesheet">attribset20.xsl</input-file>
<output-file role="principal" compare="XML">attribset20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset21">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Use xsl:copy with a single attribute set.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset21.xml</input-file>
<input-file role="principal-stylesheet">attribset21.xsl</input-file>
<output-file role="principal" compare="XML">attribset21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset22">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Verify that attributes that contain text nodes with a newline, the output must contain a character reference.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset22.xml</input-file>
<input-file role="principal-stylesheet">attribset22.xsl</input-file>
<output-file role="principal" compare="XML">attribset22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset23">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>XSLT processors may make use of the prefix of the QNAME specified in the name attribute ... however they are not required to do so and, if the prefix is xmlns, they must not do so ... this will not result in a namespace declaration being output.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset23.xml</input-file>
<input-file role="principal-stylesheet">attribset23.xsl</input-file>
<output-file role="principal" compare="XML">attribset23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset24">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>The attribute must be in the designated namespace, even if the prefix has to be reset or ignored.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset24.xml</input-file>
<input-file role="principal-stylesheet">attribset24.xsl</input-file>
<output-file role="principal" compare="XML">attribset24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset25">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with for-each inside xsl:attribute</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset25.xml</input-file>
<input-file role="principal-stylesheet">attribset25.xsl</input-file>
<output-file role="principal" compare="XML">attribset25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset26">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Use xsl:copy with multiple attribute sets that inherit, but have conflicts.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset26.xml</input-file>
<input-file role="principal-stylesheet">attribset26.xsl</input-file>
<output-file role="principal" compare="XML">attribset26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset27">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Use xsl:copy with multiple attribute sets with conflicting set name, then reset one attribute with xsl:attribute.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset27.xml</input-file>
<input-file role="principal-stylesheet">attribset27.xsl</input-file>
<output-file role="principal" compare="XML">attribset27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset28">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use xsl:copy with multiple attribute sets in a list that have conflicts.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset28.xml</input-file>
<input-file role="principal-stylesheet">attribset28.xsl</input-file>
<output-file role="principal" compare="XML">attribset28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset29">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Use xsl:copy with multiple attribute sets in "merge" scenario.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset29.xml</input-file>
<input-file role="principal-stylesheet">attribset29.xsl</input-file>
<output-file role="principal" compare="XML">attribset29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset30">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Set attributes of an element created with xsl:element from single attribute set.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset30.xml</input-file>
<input-file role="principal-stylesheet">attribset30.xsl</input-file>
<output-file role="principal" compare="XML">attribset30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset31">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with multiple attribute sets with conflicting names (merge scenario), plus local override with xsl:attribute.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset31.xml</input-file>
<input-file role="principal-stylesheet">attribset31.xsl</input-file>
<output-file role="principal" compare="XML">attribset31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset32">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with multiple attribute sets with conflicting set names.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset32.xml</input-file>
<input-file role="principal-stylesheet">attribset32.xsl</input-file>
<output-file role="principal" compare="XML">attribset32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset33">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with multiple attribute sets that inherit.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset33.xml</input-file>
<input-file role="principal-stylesheet">attribset33.xsl</input-file>
<output-file role="principal" compare="XML">attribset33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset34">
<file-path>attribset</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with multiple attribute sets that inherit, but have overlapping attributes.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset34.xml</input-file>
<input-file role="principal-stylesheet">attribset34.xsl</input-file>
<output-file role="principal" compare="XML">attribset34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset35">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Verify adding an attribute to an element after a PI has been added to it is an error. The attributes can be ignored. The spec doesn't explicitly say this is disallowed, as it does for child elements, but it makes sense to have the same treatment.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset35.xml</input-file>
<input-file role="principal-stylesheet">attribset35.xsl</input-file>
<output-file role="principal" compare="XML">attribset35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset36">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Verify adding an attribute to an element after a comment has been added to it is an error. The attributes can be ignored. The spec doesn't explicitly say this is disallowed, as it does for child elements, but it makes sense to have the same treatment.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset36.xml</input-file>
<input-file role="principal-stylesheet">attribset36.xsl</input-file>
<output-file role="principal" compare="XML">attribset36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset37">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set some attributes from an imported definition.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset37.xml</input-file>
<input-file role="principal-stylesheet">attribset37.xsl</input-file>
<output-file role="principal" compare="XML">attribset37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset38">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set some attributes from an imported definition.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset38.xml</input-file>
<input-file role="principal-stylesheet">attribset38.xsl</input-file>
<output-file role="principal" compare="XML">attribset38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset39">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test use of leading underscore in names.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset39.xml</input-file>
<input-file role="principal-stylesheet">attribset39.xsl</input-file>
<output-file role="principal" compare="XML">attribset39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset40">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>The attribute must be in the designated namespace, even if the prefix has to be reset or ignored.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset40.xml</input-file>
<input-file role="principal-stylesheet">attribset40.xsl</input-file>
<output-file role="principal" compare="XML">attribset40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset41">
<file-path>attribset</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test inheritance of attribute sets. A literal result element is referring an attribute set that is defined by two separate &lt;xsl:attribute-set.../&gt; elements with the same name. Both these elements have a use-attribute-sets attribute, which means that we have a single attribute set that inherits from two other attribute sets.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset41.xml</input-file>
<input-file role="principal-stylesheet">attribset41.xsl</input-file>
<output-file role="principal" compare="XML">attribset41.out</output-file>
</scenario>
</test-case>
<!-- 
Skipped attribset42: It confuses against grouping of same-named attribute sets and use-attribute-sets overriding.

<test-case category="XSLT-Result-Tree" id="attribset_attribset42">
<file-path>attribset</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test inheritance of attribute sets. A literal result element is referring an attribute set that is defined by two separate &lt;xsl:attribute-set.../&gt; elements with the same name. Both these elements have a use-attribute-sets attribute, which means that we have a single attribute set that inherits from two other attribute sets. Both parents attribute sets have attributes that are overridden by the child.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset42.xml</input-file>
<input-file role="principal-stylesheet">attribset42.xsl</input-file>
<output-file role="principal" compare="XML">attribset42.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="attribset_attribset43">
<file-path>attribset</file-path>
<creator>David Marston, based on a test by Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test inheritance of attribute sets. A xsl:element instruction is referring an attribute set that is defined by two separate xsl:attribute-set elements with the same name.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset43.xml</input-file>
<input-file role="principal-stylesheet">attribset43.xsl</input-file>
<output-file role="principal" compare="XML">attribset43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset44">
<file-path>attribset</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Only top-level variables and params are visible within the declaration of an attribute set.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset44.xml</input-file>
<input-file role="principal-stylesheet">attribset44.xsl</input-file>
<output-file role="principal" compare="XML">attribset44.out</output-file>
</scenario>
</test-case>
<!-- 
Skipped attribset45 and attribset46: It confuses against grouping of same-named attribute sets and use-attribute-sets overriding.
<test-case category="XSLT-Result-Tree" id="attribset_attribset45">
<file-path>attribset</file-path>
<creator>Richard Titmuss (richard@rockingfrog.com)</creator>
<date>2001-11-08</date>
<purpose>Basic test of import precedence with attribute sets</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset45.xml</input-file>
<input-file role="principal-stylesheet">attribset45.xsl</input-file>
<output-file role="principal" compare="XML">attribset45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset46">
<file-path>attribset</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Basic test of import precedence based on Richard Titmuss's test with attribute sets. Here the imported attribute sets have additional non- conflicting attributes as well.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset46.xml</input-file>
<input-file role="principal-stylesheet">attribset46.xsl</input-file>
<output-file role="principal" compare="XML">attribset46.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="attribset_attribset47">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test attribute set with a qualified name.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset47.xml</input-file>
<input-file role="principal-stylesheet">attribset47.xsl</input-file>
<output-file role="principal" compare="XML">attribset47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset48">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test attribute set with a qualified name, different prefix.</purpose>
<spec-citation place="7.1.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset48.xml</input-file>
<input-file role="principal-stylesheet">attribset48.xsl</input-file>
<output-file role="principal" compare="XML">attribset48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribset_attribset49">
<file-path>attribset</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Attempt to set an empty or null attribute in various ways.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribset49.xml</input-file>
<input-file role="principal-stylesheet">attribset49.xsl</input-file>
<output-file role="principal" compare="XML">attribset49.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate01">
<file-path>attribvaltemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of single attribute value template (AVT).</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate01.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate01.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate02">
<file-path>attribvaltemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test two AVTs with literal element between them (based on example in the spec).</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate02.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate02.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate03">
<file-path>attribvaltemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of left curly brace escape.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate03.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate03.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate04">
<file-path>attribvaltemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of right curly brace escape.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate04.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate04.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate05">
<file-path>attribvaltemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use of Curly brace to set value of HTML attribute.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate05.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate05.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate06">
<file-path>attribvaltemplate</file-path>
<creator>fginestrini@3di.it</creator>
<date>2001-11-08</date>
<purpose>Evaluation of numeric expression in AVT, surrounded by strings.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate06.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate06.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate08">
<file-path>attribvaltemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Compare the results of attribute value generated by AVT vs. xsl:value-of, with the output specified to be HTML.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate08.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate08.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate09">
<file-path>attribvaltemplate</file-path>
<creator>Geoff Crowther</creator>
<date>2001-11-08</date>
<purpose>Testing generation of null attribute. Bug: if $From was null, it was not outputting the attribute.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate09.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate09.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate10">
<file-path>attribvaltemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Evaluation of string expression in AVT, surrounded by fixed strings.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate10.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate10.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate11">
<file-path>attribvaltemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Evaluation of boolean expression in AVT, surrounded by fixed strings.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate11.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate11.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate12">
<file-path>attribvaltemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Double braces to neutralize AVT processing, including colon.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate12.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate12.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="attribvaltemplate_attribvaltemplate13">
<file-path>attribvaltemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use of colon in AVT expression to signify namespaced element.</purpose>
<spec-citation place="7.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">attribvaltemplate13.xml</input-file>
<input-file role="principal-stylesheet">attribvaltemplate13.xsl</input-file>
<output-file role="principal" compare="XML">attribvaltemplate13.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree-Testing" id="axes_axes01">
<file-path>axes</file-path>
<purpose>Traverse the ancestor::* axis</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes01.xml</input-file>
<input-file role="principal-stylesheet">axes01.xsl</input-file>
<output-file role="principal" compare="XML">axes01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes02">
<file-path>axes</file-path>
<purpose>Test for 'ancestor-or-self::*' Axis Identifier</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes02.xml</input-file>
<input-file role="principal-stylesheet">axes02.xsl</input-file>
<output-file role="principal" compare="XML">axes02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes03">
<file-path>axes</file-path>
<purpose>Test for 'attribute::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes03.xml</input-file>
<input-file role="principal-stylesheet">axes03.xsl</input-file>
<output-file role="principal" compare="XML">axes03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes04">
<file-path>axes</file-path>
<purpose>Test for 'child::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes04.xml</input-file>
<input-file role="principal-stylesheet">axes04.xsl</input-file>
<output-file role="principal" compare="XML">axes04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes05">
<file-path>axes</file-path>
<purpose>Test for 'descendant::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes05.xml</input-file>
<input-file role="principal-stylesheet">axes05.xsl</input-file>
<output-file role="principal" compare="XML">axes05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes06">
<file-path>axes</file-path>
<purpose>Test for 'descendant-or-self::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes06.xml</input-file>
<input-file role="principal-stylesheet">axes06.xsl</input-file>
<output-file role="principal" compare="XML">axes06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes07">
<file-path>axes</file-path>
<purpose>Test for 'following::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes07.xml</input-file>
<input-file role="principal-stylesheet">axes07.xsl</input-file>
<output-file role="principal" compare="XML">axes07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes08">
<file-path>axes</file-path>
<purpose>Test for 'preceding::*' Axis Identifier with wildcard.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes08.xml</input-file>
<input-file role="principal-stylesheet">axes08.xsl</input-file>
<output-file role="principal" compare="XML">axes08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes09">
<file-path>axes</file-path>
<purpose>Test for 'following-sibling::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes09.xml</input-file>
<input-file role="principal-stylesheet">axes09.xsl</input-file>
<output-file role="principal" compare="XML">axes09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes10">
<file-path>axes</file-path>
<purpose>Test for 'preceding-sibling::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes10.xml</input-file>
<input-file role="principal-stylesheet">axes10.xsl</input-file>
<output-file role="principal" compare="XML">axes10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes11">
<file-path>axes</file-path>
<purpose>Test for 'parent::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes11.xml</input-file>
<input-file role="principal-stylesheet">axes11.xsl</input-file>
<output-file role="principal" compare="XML">axes11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes12">
<file-path>axes</file-path>
<purpose>Test for 'self::*' Axis Identifier.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes12.xml</input-file>
<input-file role="principal-stylesheet">axes12.xsl</input-file>
<output-file role="principal" compare="XML">axes12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes13">
<file-path>axes</file-path>
<purpose>Test for ancestor::*[...][...] and index of ancestors.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes13.xml</input-file>
<input-file role="principal-stylesheet">axes13.xsl</input-file>
<output-file role="principal" compare="XML">axes13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes14">
<file-path>axes</file-path>
<purpose>Test for ancestor-or-self::*[@att1][1]/@att1 vs. (ancestor-or-self::*)[@att1][1]/@att1.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes14.xml</input-file>
<input-file role="principal-stylesheet">axes14.xsl</input-file>
<output-file role="principal" compare="XML">axes14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes15">
<file-path>axes</file-path>
<purpose>Test for completion of tree using all axes.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes15.xml</input-file>
<input-file role="principal-stylesheet">axes15.xsl</input-file>
<output-file role="principal" compare="XML">axes15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes16">
<file-path>axes</file-path>
<purpose>Test for 'ancestor::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes16.xml</input-file>
<input-file role="principal-stylesheet">axes16.xsl</input-file>
<output-file role="principal" compare="XML">axes16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes17">
<file-path>axes</file-path>
<purpose>Test for 'ancestor-or-self::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes17.xml</input-file>
<input-file role="principal-stylesheet">axes17.xsl</input-file>
<output-file role="principal" compare="XML">axes17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes18">
<file-path>axes</file-path>
<purpose>Test for 'attribute::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes18.xml</input-file>
<input-file role="principal-stylesheet">axes18.xsl</input-file>
<output-file role="principal" compare="XML">axes18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes19">
<file-path>axes</file-path>
<purpose>Test for '@*' abbreviated syntax.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes19.xml</input-file>
<input-file role="principal-stylesheet">axes19.xsl</input-file>
<output-file role="principal" compare="XML">axes19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes20">
<file-path>axes</file-path>
<purpose>Test for '@*' abbreviated syntax with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes20.xml</input-file>
<input-file role="principal-stylesheet">axes20.xsl</input-file>
<output-file role="principal" compare="XML">axes20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes21">
<file-path>axes</file-path>
<purpose>Test for 'child::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes21.xml</input-file>
<input-file role="principal-stylesheet">axes21.xsl</input-file>
<output-file role="principal" compare="XML">axes21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes22">
<file-path>axes</file-path>
<purpose>Test for 'child::' Axis Identifier with element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes22.xml</input-file>
<input-file role="principal-stylesheet">axes22.xsl</input-file>
<output-file role="principal" compare="XML">axes22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes23">
<file-path>axes</file-path>
<purpose>Test for 'descendant::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes23.xml</input-file>
<input-file role="principal-stylesheet">axes23.xsl</input-file>
<output-file role="principal" compare="XML">axes23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes24">
<file-path>axes</file-path>
<purpose>Test for 'descendant::' Axis Identifier with specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes24.xml</input-file>
<input-file role="principal-stylesheet">axes24.xsl</input-file>
<output-file role="principal" compare="XML">axes24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes25">
<file-path>axes</file-path>
<purpose>Test for 'descendant-or-self::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes25.xml</input-file>
<input-file role="principal-stylesheet">axes25.xsl</input-file>
<output-file role="principal" compare="XML">axes25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes26">
<file-path>axes</file-path>
<purpose>Test for 'descendant-or-self::' Axis Identifier with specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes26.xml</input-file>
<input-file role="principal-stylesheet">axes26.xsl</input-file>
<output-file role="principal" compare="XML">axes26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes27">
<file-path>axes</file-path>
<purpose>Test for 'descendant-or-self::' Axis Identifier with self specified.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes27.xml</input-file>
<input-file role="principal-stylesheet">axes27.xsl</input-file>
<output-file role="principal" compare="XML">axes27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes28">
<file-path>axes</file-path>
<purpose>Test for 'following::' Axis Identifier with wildcard and index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes28.xml</input-file>
<input-file role="principal-stylesheet">axes28.xsl</input-file>
<output-file role="principal" compare="XML">axes28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes29">
<file-path>axes</file-path>
<purpose>Test for 'following::' Axis Identifier with specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes29.xml</input-file>
<input-file role="principal-stylesheet">axes29.xsl</input-file>
<output-file role="principal" compare="XML">axes29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes30">
<file-path>axes</file-path>
<purpose>Test for 'preceding::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes30.xml</input-file>
<input-file role="principal-stylesheet">axes30.xsl</input-file>
<output-file role="principal" compare="XML">axes30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes31">
<file-path>axes</file-path>
<purpose>Test for 'preceding::' Axis Identifier with specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes31.xml</input-file>
<input-file role="principal-stylesheet">axes31.xsl</input-file>
<output-file role="principal" compare="XML">axes31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes32">
<file-path>axes</file-path>
<purpose>Test for 'following-sibling::' Axis Identifier with index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes32.xml</input-file>
<input-file role="principal-stylesheet">axes32.xsl</input-file>
<output-file role="principal" compare="XML">axes32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes33">
<file-path>axes</file-path>
<purpose>Test for 'following-sibling::' Axis Identifier with specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes33.xml</input-file>
<input-file role="principal-stylesheet">axes33.xsl</input-file>
<output-file role="principal" compare="XML">axes33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes34">
<file-path>axes</file-path>
<purpose>Test for 'preceding-sibling::' Axis Identifier with wildcard and index.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes34.xml</input-file>
<input-file role="principal-stylesheet">axes34.xsl</input-file>
<output-file role="principal" compare="XML">axes34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes35">
<file-path>axes</file-path>
<purpose>Test for 'preceding-sibling::' Axis Identifier with specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes35.xml</input-file>
<input-file role="principal-stylesheet">axes35.xsl</input-file>
<output-file role="principal" compare="XML">axes35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes36">
<file-path>axes</file-path>
<purpose>Test for 'parent::' Axis Identifier using specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes36.xml</input-file>
<input-file role="principal-stylesheet">axes36.xsl</input-file>
<output-file role="principal" compare="XML">axes36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes37">
<file-path>axes</file-path>
<purpose>Test for 'parent::' Axis Identifier using index (not that it's practical).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes37.xml</input-file>
<input-file role="principal-stylesheet">axes37.xsl</input-file>
<output-file role="principal" compare="XML">axes37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes38">
<file-path>axes</file-path>
<purpose>Test for 'parent::' Axis Identifier using specified element name that is not found.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes38.xml</input-file>
<input-file role="principal-stylesheet">axes38.xsl</input-file>
<output-file role="principal" compare="XML">axes38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes39">
<file-path>axes</file-path>
<purpose>Test for abbreviated '..' syntax.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes39.xml</input-file>
<input-file role="principal-stylesheet">axes39.xsl</input-file>
<output-file role="principal" compare="XML">axes39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes40">
<file-path>axes</file-path>
<purpose>Test for 'self::' Axis Identifier with specified element name.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes40.xml</input-file>
<input-file role="principal-stylesheet">axes40.xsl</input-file>
<output-file role="principal" compare="XML">axes40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes41">
<file-path>axes</file-path>
<purpose>Test for 'self::' Axis Identifier with index (not that it's practical).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes41.xml</input-file>
<input-file role="principal-stylesheet">axes41.xsl</input-file>
<output-file role="principal" compare="XML">axes41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes42">
<file-path>axes</file-path>
<purpose>Test for 'self::' Axis Identifier with specified element name that is not found.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes42.xml</input-file>
<input-file role="principal-stylesheet">axes42.xsl</input-file>
<output-file role="principal" compare="XML">axes42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes43">
<file-path>axes</file-path>
<purpose>Test for abbreviated '.' syntax.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes43.xml</input-file>
<input-file role="principal-stylesheet">axes43.xsl</input-file>
<output-file role="principal" compare="XML">axes43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes44">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'attribute::' Axis Identifier with name of attribute.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes44.xml</input-file>
<input-file role="principal-stylesheet">axes44.xsl</input-file>
<output-file role="principal" compare="XML">axes44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes45">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for '@' to select an attribute, with name of attribute.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes45.xml</input-file>
<input-file role="principal-stylesheet">axes45.xsl</input-file>
<output-file role="principal" compare="XML">axes45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes46">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for '..' and an attribute of parent node.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes46.xml</input-file>
<input-file role="principal-stylesheet">axes46.xsl</input-file>
<output-file role="principal" compare="XML">axes46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes47">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for '..//name' and an attribute.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes47.xml</input-file>
<input-file role="principal-stylesheet">axes47.xsl</input-file>
<output-file role="principal" compare="XML">axes47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes48">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for two 'child::' Axis Identifiers in succession.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes48.xml</input-file>
<input-file role="principal-stylesheet">axes48.xsl</input-file>
<output-file role="principal" compare="XML">axes48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes49">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'child::*' followed by 'descendant::*' (i.e., all grandchildren and below).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes49.xml</input-file>
<input-file role="principal-stylesheet">axes49.xsl</input-file>
<output-file role="principal" compare="XML">axes49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes50">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'descendant::*' followed by 'child::*' (i.e., all grandchildren and below).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes50.xml</input-file>
<input-file role="principal-stylesheet">axes50.xsl</input-file>
<output-file role="principal" compare="XML">axes50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes51">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for '//' followed by 'child::*' (i.e., all grandchildren).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes51.xml</input-file>
<input-file role="principal-stylesheet">axes51.xsl</input-file>
<output-file role="principal" compare="XML">axes51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes52">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for '//' followed by 'descendant::*' (i.e., all children and below).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes52.xml</input-file>
<input-file role="principal-stylesheet">axes52.xsl</input-file>
<output-file role="principal" compare="XML">axes52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes53">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for named node followed by 'descendant::*' (i.e., all children and below).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes53.xml</input-file>
<input-file role="principal-stylesheet">axes53.xsl</input-file>
<output-file role="principal" compare="XML">axes53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes54">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for named node followed by 'child::*' (i.e., all children).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes54.xml</input-file>
<input-file role="principal-stylesheet">axes54.xsl</input-file>
<output-file role="principal" compare="XML">axes54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes55">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for '//*' (i.e., all descendants, but elements only).</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes55.xml</input-file>
<input-file role="principal-stylesheet">axes55.xsl</input-file>
<output-file role="principal" compare="XML">axes55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes56">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that combination of // and descendant specifies node can be anywhere in ancestry.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes56.xml</input-file>
<input-file role="principal-stylesheet">axes56.xsl</input-file>
<output-file role="principal" compare="XML">axes56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes57">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that // goes down at least 15 levels.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes57.xml</input-file>
<input-file role="principal-stylesheet">axes57.xsl</input-file>
<output-file role="principal" compare="XML">axes57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes58">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Check the attribute:: axis. The foo:doc selection is necessary to pick up the last doc, cuz, I change the default namespace.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes58.xml</input-file>
<input-file role="principal-stylesheet">axes58.xsl</input-file>
<output-file role="principal" compare="XML">axes58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes59">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Step through names on the namespace axis. Ensure attributes aren't counted.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes59.xml</input-file>
<input-file role="principal-stylesheet">axes59.xsl</input-file>
<output-file role="principal" compare="XML">axes59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes60">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for 'attribute::*' in match pattern.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes60.xml</input-file>
<input-file role="principal-stylesheet">axes60.xsl</input-file>
<output-file role="principal" compare="XML">axes60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes61">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for 'child::*' in match pattern.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes61.xml</input-file>
<input-file role="principal-stylesheet">axes61.xsl</input-file>
<output-file role="principal" compare="XML">axes61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes62">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use a NameTest on the namespace axis.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes62.xml</input-file>
<input-file role="principal-stylesheet">axes62.xsl</input-file>
<output-file role="principal" compare="XML">axes62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes63">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'self::' Axis Identifier with child predicate</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes63.xml</input-file>
<input-file role="principal-stylesheet">axes63.xsl</input-file>
<output-file role="principal" compare="XML">axes63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes64">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'self::' Axis Identifier with attribute predicate</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes64.xml</input-file>
<input-file role="principal-stylesheet">axes64.xsl</input-file>
<output-file role="principal" compare="XML">axes64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes65">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'self::text()' being empty when it should be</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes65.xml</input-file>
<input-file role="principal-stylesheet">axes65.xsl</input-file>
<output-file role="principal" compare="XML">axes65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes66">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'self::comment()' being empty when it should be</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes66.xml</input-file>
<input-file role="principal-stylesheet">axes66.xsl</input-file>
<output-file role="principal" compare="XML">axes66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes67">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'self::processing-instruction()' being empty when it should be</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes67.xml</input-file>
<input-file role="principal-stylesheet">axes67.xsl</input-file>
<output-file role="principal" compare="XML">axes67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes68">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check that namespace axis includes all namespaces in scope.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes68.xml</input-file>
<input-file role="principal-stylesheet">axes68.xsl</input-file>
<output-file role="principal" compare="XML">axes68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes69">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for preceding-sibling:: and following-sibling:: with explicit iteration.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes69.xml</input-file>
<input-file role="principal-stylesheet">axes69.xsl</input-file>
<output-file role="principal" compare="XML">axes69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes70">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for preceding-sibling:: and following-sibling:: conjoined.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes70.xml</input-file>
<input-file role="principal-stylesheet">axes70.xsl</input-file>
<output-file role="principal" compare="XML">axes70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes71">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for preceding-sibling:: and following-sibling:: conjoined, with positional predicate on the first axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes71.xml</input-file>
<input-file role="principal-stylesheet">axes71.xsl</input-file>
<output-file role="principal" compare="XML">axes71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes72">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for preceding-sibling:: and following-sibling:: conjoined, with positional predicates on both axes.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes72.xml</input-file>
<input-file role="principal-stylesheet">axes72.xsl</input-file>
<output-file role="principal" compare="XML">axes72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes73">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test where we bounce "horizontally" across the tree, using positions.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes73.xml</input-file>
<input-file role="principal-stylesheet">axes73.xsl</input-file>
<output-file role="principal" compare="XML">axes73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes74">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for following-sibling:: and preceding-sibling:: with explicit iteration.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes74.xml</input-file>
<input-file role="principal-stylesheet">axes74.xsl</input-file>
<output-file role="principal" compare="XML">axes74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes75">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for following-sibling:: and preceding-sibling:: conjoined.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes75.xml</input-file>
<input-file role="principal-stylesheet">axes75.xsl</input-file>
<output-file role="principal" compare="XML">axes75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes76">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for following-sibling:: and preceding-sibling:: conjoined, with positional predicate on the first axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes76.xml</input-file>
<input-file role="principal-stylesheet">axes76.xsl</input-file>
<output-file role="principal" compare="XML">axes76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes77">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for following-sibling:: and preceding-sibling:: conjoined, with positional predicates on both axes. Reverse document order applies.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes77.xml</input-file>
<input-file role="principal-stylesheet">axes77.xsl</input-file>
<output-file role="principal" compare="XML">axes77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes78">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test where we bounce "horizontally" across the tree, using positions.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes78.xml</input-file>
<input-file role="principal-stylesheet">axes78.xsl</input-file>
<output-file role="principal" compare="XML">axes78.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes79">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for following::, parent, and child conjoined, with positional predicates.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes79.xml</input-file>
<input-file role="principal-stylesheet">axes79.xsl</input-file>
<output-file role="principal" compare="XML">axes79.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes80">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for preceding::, parent, and following:: conjoined, with positional predicates.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes80.xml</input-file>
<input-file role="principal-stylesheet">axes80.xsl</input-file>
<output-file role="principal" compare="XML">axes80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes81">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test for preceding::, parent, descendant::, and following-sibling:: conjoined, with positional predicates and a node test.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes81.xml</input-file>
<input-file role="principal-stylesheet">axes81.xsl</input-file>
<output-file role="principal" compare="XML">axes81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes82">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test simple notation to select entire tree.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes82.xml</input-file>
<input-file role="principal-stylesheet">axes82.xsl</input-file>
<output-file role="principal" compare="XML">axes82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes83">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test selecting everything that has children.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes83.xml</input-file>
<input-file role="principal-stylesheet">axes83.xsl</input-file>
<output-file role="principal" compare="XML">axes83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes84">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compound test going "vertically" in the tree.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes84.xml</input-file>
<input-file role="principal-stylesheet">axes84.xsl</input-file>
<output-file role="principal" compare="XML">axes84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes85">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Alternate test to select the set of all grandparents.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes85.xml</input-file>
<input-file role="principal-stylesheet">axes85.xsl</input-file>
<output-file role="principal" compare="XML">axes85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes86">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test to select the set of all aunts, great-aunts, etc. but exclude ancestors.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes86.xml</input-file>
<input-file role="principal-stylesheet">axes86.xsl</input-file>
<output-file role="principal" compare="XML">axes86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes87">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Traverse ancestor:: starting from attributes.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes87.xml</input-file>
<input-file role="principal-stylesheet">axes87.xsl</input-file>
<output-file role="principal" compare="XML">axes87.out</output-file>
</scenario>
</test-case>
<!--
@*/following::* and @*/preceding::* is not defined by XPath 1.0 spec.

<test-case category="XSLT-Result-Tree-Testing" id="axes_axes88">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Traverse following:: starting from attributes.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes88.xml</input-file>
<input-file role="principal-stylesheet">axes88.xsl</input-file>
<output-file role="principal" compare="XML">axes88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes89">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Traverse preceding:: starting from attributes.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes89.xml</input-file>
<input-file role="principal-stylesheet">axes89.xsl</input-file>
<output-file role="principal" compare="XML">axes89.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes90">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for union of preceding-sibling:: and following-sibling::</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes90.xml</input-file>
<input-file role="principal-stylesheet">axes90.xsl</input-file>
<output-file role="principal" compare="XML">axes90.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes91">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for steps beyond union of two axes.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes91.xml</input-file>
<input-file role="principal-stylesheet">axes91.xsl</input-file>
<output-file role="principal" compare="XML">axes91.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes92">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for union of two relative-location-paths</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes92.xml</input-file>
<input-file role="principal-stylesheet">axes92.xsl</input-file>
<output-file role="principal" compare="XML">axes92.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes93">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes93.xml</input-file>
<input-file role="principal-stylesheet">axes93.xsl</input-file>
<output-file role="principal" compare="XML">axes93.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes94">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes94.xml</input-file>
<input-file role="principal-stylesheet">axes94.xsl</input-file>
<output-file role="principal" compare="XML">axes94.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes95">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes95.xml</input-file>
<input-file role="principal-stylesheet">axes95.xsl</input-file>
<output-file role="principal" compare="XML">axes95.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes96">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes96.xml</input-file>
<input-file role="principal-stylesheet">axes96.xsl</input-file>
<output-file role="principal" compare="XML">axes96.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes97">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes97.xml</input-file>
<input-file role="principal-stylesheet">axes97.xsl</input-file>
<output-file role="principal" compare="XML">axes97.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes98">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes98.xml</input-file>
<input-file role="principal-stylesheet">axes98.xsl</input-file>
<output-file role="principal" compare="XML">axes98.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes99">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes99.xml</input-file>
<input-file role="principal-stylesheet">axes99.xsl</input-file>
<output-file role="principal" compare="XML">axes99.out</output-file>
</scenario>
</test-case>
<!--
@*/following::* and @*/preceding::* is not defined by XPath 1.0 spec.


<test-case category="XSLT-Result-Tree-Testing" id="axes_axes100">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes100.xml</input-file>
<input-file role="principal-stylesheet">axes100.xsl</input-file>
<output-file role="principal" compare="XML">axes100.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes101">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes101.xml</input-file>
<input-file role="principal-stylesheet">axes101.xsl</input-file>
<output-file role="principal" compare="XML">axes101.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes102">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes102.xml</input-file>
<input-file role="principal-stylesheet">axes102.xsl</input-file>
<output-file role="principal" compare="XML">axes102.out</output-file>
</scenario>
</test-case>
<!--
@*/following::* and @*/preceding::* is not defined by XPath 1.0 spec.


<test-case category="XSLT-Result-Tree-Testing" id="axes_axes103">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes103.xml</input-file>
<input-file role="principal-stylesheet">axes103.xsl</input-file>
<output-file role="principal" compare="XML">axes103.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes104">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes104.xml</input-file>
<input-file role="principal-stylesheet">axes104.xsl</input-file>
<output-file role="principal" compare="XML">axes104.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes105">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes105.xml</input-file>
<input-file role="principal-stylesheet">axes105.xsl</input-file>
<output-file role="principal" compare="XML">axes105.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes106">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes106.xml</input-file>
<input-file role="principal-stylesheet">axes106.xsl</input-file>
<output-file role="principal" compare="XML">axes106.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes107">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps. Note that namespace nodes should not be included on the preceeding axis, and specifically that the implied declaration of xml: should not appear in the output.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes107.xml</input-file>
<input-file role="principal-stylesheet">axes107.xsl</input-file>
<output-file role="principal" compare="XML">axes107.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes108">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes108.xml</input-file>
<input-file role="principal-stylesheet">axes108.xsl</input-file>
<output-file role="principal" compare="XML">axes108.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes109">
<file-path>axes</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Tests following axis starting from an attribute.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes109.xml</input-file>
<input-file role="principal-stylesheet">axes109.xsl</input-file>
<output-file role="principal" compare="XML">axes109.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes110">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes110.xml</input-file>
<input-file role="principal-stylesheet">axes110.xsl</input-file>
<output-file role="principal" compare="XML">axes110.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes111">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes111.xml</input-file>
<input-file role="principal-stylesheet">axes111.xsl</input-file>
<output-file role="principal" compare="XML">axes111.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes112">
<file-path>axes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates starting with a attribute axis followed by additional relative-location-path steps.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes112.xml</input-file>
<input-file role="principal-stylesheet">axes112.xsl</input-file>
<output-file role="principal" compare="XML">axes112.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes113">
<file-path>axes</file-path>
<creator>Dave Haffner</creator>
<date>2001-11-08</date>
<purpose>Comprehensive test of all axes</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes113.xml</input-file>
<input-file role="principal-stylesheet">axes113.xsl</input-file>
<output-file role="principal" compare="XML">axes113.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes114">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for preceding::foo[1] vs. (preceding::foo)[1], as discussed in the first NOTE in section 3.3</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes114.xml</input-file>
<input-file role="principal-stylesheet">axes114.xsl</input-file>
<output-file role="principal" compare="XML">axes114.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes115">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for preceding-sibling::foo[1] vs. (preceding-sibling::foo)[1], similar to the treatment of preceding:: in the first NOTE in section 3.3</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes115.xml</input-file>
<input-file role="principal-stylesheet">axes115.xsl</input-file>
<output-file role="principal" compare="XML">axes115.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes116">
<file-path>axes</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for likely optimizations of descendant patterns to make sure they're done correctly.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes116.xml</input-file>
<input-file role="principal-stylesheet">axes116.xsl</input-file>
<output-file role="principal" compare="XML">axes116.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes117">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of //@ sequences</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes117.xml</input-file>
<input-file role="principal-stylesheet">axes117.xsl</input-file>
<output-file role="principal" compare="XML">axes117.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes119">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try 'ancestor-or-self::*' after walking down to it.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes119.xml</input-file>
<input-file role="principal-stylesheet">axes119.xsl</input-file>
<output-file role="principal" compare="XML">axes119.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes120">
<file-path>axes</file-path>
<creator>Paul Dick (Revision of axes118)</creator>
<date>2001-11-08</date>
<purpose>Check that namespace nodes exist separately on each element.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes120.xml</input-file>
<input-file role="principal-stylesheet">axes120.xsl</input-file>
<output-file role="principal" compare="XML">axes120.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes121">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for '/descendant::*' to select all elements (excluding root node). No text or comments should be picked up.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes121.xml</input-file>
<input-file role="principal-stylesheet">axes121.xsl</input-file>
<output-file role="principal" compare="XML">axes121.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes122">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for last() on two-step paths, contrasting descendant-or-self with ancestor-or-self.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes122.xml</input-file>
<input-file role="principal-stylesheet">axes122.xsl</input-file>
<output-file role="principal" compare="XML">axes122.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes123">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates from an attribute using parent axis.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes123.xml</input-file>
<input-file role="principal-stylesheet">axes123.xsl</input-file>
<output-file role="principal" compare="XML">axes123.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes124">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Tests apply-templates from a comment using parent axis.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes124.xml</input-file>
<input-file role="principal-stylesheet">axes124.xsl</input-file>
<output-file role="principal" compare="XML">axes124.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes125">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that preceding::node() doesn't get namespace or attribute nodes</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes125.xml</input-file>
<input-file role="principal-stylesheet">axes125.xsl</input-file>
<output-file role="principal" compare="XML">axes125.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes126">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that preceding::node() does get comment or PI nodes</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes126.xml</input-file>
<input-file role="principal-stylesheet">axes126.xsl</input-file>
<output-file role="principal" compare="XML">axes126.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes127">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that following::node() doesn't get namespace or attribute nodes</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes127.xml</input-file>
<input-file role="principal-stylesheet">axes127.xsl</input-file>
<output-file role="principal" compare="XML">axes127.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes128">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that preceding::node() does get comment and PI nodes</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes128.xml</input-file>
<input-file role="principal-stylesheet">axes128.xsl</input-file>
<output-file role="principal" compare="XML">axes128.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes129">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check the namespace axis starting from an attribute; should be empty</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes129.xml</input-file>
<input-file role="principal-stylesheet">axes129.xsl</input-file>
<output-file role="principal" compare="XML">axes129.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes130">
<file-path>axes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'self::' axis on an attribute</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes130.xml</input-file>
<input-file role="principal-stylesheet">axes130.xsl</input-file>
<output-file role="principal" compare="XML">axes130.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree-Testing" id="axes_axes131">
<file-path>axes</file-path>
<creator>Henry Zongaro</creator>
<date>2001-11-08</date>
<purpose>Test for descendant axis when siblings have some children or the context node has no siblings.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">axes131.xml</input-file>
<input-file role="principal-stylesheet">axes131.xsl</input-file>
<output-file role="principal" compare="XML">axes131.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="boolean_boolean01">
<file-path>boolean</file-path>
<purpose>Test of true()</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean01.xml</input-file>
<input-file role="principal-stylesheet">boolean01.xsl</input-file>
<output-file role="principal" compare="XML">boolean01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean02">
<file-path>boolean</file-path>
<purpose>Test of boolean "and" operator with both values true</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean02.xml</input-file>
<input-file role="principal-stylesheet">boolean02.xsl</input-file>
<output-file role="principal" compare="XML">boolean02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean03">
<file-path>boolean</file-path>
<purpose>Test of boolean "or" operator with two true values</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean03.xml</input-file>
<input-file role="principal-stylesheet">boolean03.xsl</input-file>
<output-file role="principal" compare="XML">boolean03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean04">
<file-path>boolean</file-path>
<purpose>Test of boolean "not" operator with true value.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean04.xml</input-file>
<input-file role="principal-stylesheet">boolean04.xsl</input-file>
<output-file role="principal" compare="XML">boolean04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean05">
<file-path>boolean</file-path>
<purpose>Test of boolean() function - conversion of empty string.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean05.xml</input-file>
<input-file role="principal-stylesheet">boolean05.xsl</input-file>
<output-file role="principal" compare="XML">boolean05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean06">
<file-path>boolean</file-path>
<purpose>Test of "&gt;" operator with false expected value.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean06.xml</input-file>
<input-file role="principal-stylesheet">boolean06.xsl</input-file>
<output-file role="principal" compare="XML">boolean06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean07">
<file-path>boolean</file-path>
<purpose>Test of "&gt;=" operators with expected false result.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean07.xml</input-file>
<input-file role="principal-stylesheet">boolean07.xsl</input-file>
<output-file role="principal" compare="XML">boolean07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean08">
<file-path>boolean</file-path>
<purpose>Test of lang() function</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean08.xml</input-file>
<input-file role="principal-stylesheet">boolean08.xsl</input-file>
<output-file role="principal" compare="XML">boolean08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean09">
<file-path>boolean</file-path>
<purpose>Test of false() function</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean09.xml</input-file>
<input-file role="principal-stylesheet">boolean09.xsl</input-file>
<output-file role="principal" compare="XML">boolean09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean10">
<file-path>boolean</file-path>
<purpose>Test of the '=' operator for true.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean10.xml</input-file>
<input-file role="principal-stylesheet">boolean10.xsl</input-file>
<output-file role="principal" compare="XML">boolean10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean11">
<file-path>boolean</file-path>
<purpose>Test of '=' operator for false.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean11.xml</input-file>
<input-file role="principal-stylesheet">boolean11.xsl</input-file>
<output-file role="principal" compare="XML">boolean11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean12">
<file-path>boolean</file-path>
<purpose>Test of '=' operator on two numbers, one having decimal point and zeroes after</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean12.xml</input-file>
<input-file role="principal-stylesheet">boolean12.xsl</input-file>
<output-file role="principal" compare="XML">boolean12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean13">
<file-path>boolean</file-path>
<purpose>Test of '=' operator with positive and negative zero.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean13.xml</input-file>
<input-file role="principal-stylesheet">boolean13.xsl</input-file>
<output-file role="principal" compare="XML">boolean13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean14">
<file-path>boolean</file-path>
<purpose>Test of '=' operator with one number with leading zero, one not.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean14.xml</input-file>
<input-file role="principal-stylesheet">boolean14.xsl</input-file>
<output-file role="principal" compare="XML">boolean14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean15">
<file-path>boolean</file-path>
<purpose>Test of '=' operator, true value compared against a non-empty string.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean15.xml</input-file>
<input-file role="principal-stylesheet">boolean15.xsl</input-file>
<output-file role="principal" compare="XML">boolean15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean16">
<file-path>boolean</file-path>
<purpose>Test of '=' operator, false value compared against an empty string.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean16.xml</input-file>
<input-file role="principal-stylesheet">boolean16.xsl</input-file>
<output-file role="principal" compare="XML">boolean16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean17">
<file-path>boolean</file-path>
<purpose>Test of '=' operator, true value compared against a non-zero number.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean17.xml</input-file>
<input-file role="principal-stylesheet">boolean17.xsl</input-file>
<output-file role="principal" compare="XML">boolean17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean18">
<file-path>boolean</file-path>
<purpose>Test of '=' operator, false value compared against zero.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean18.xml</input-file>
<input-file role="principal-stylesheet">boolean18.xsl</input-file>
<output-file role="principal" compare="XML">boolean18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean19">
<file-path>boolean</file-path>
<purpose>Test of boolean "and" operator with both values false</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean19.xml</input-file>
<input-file role="principal-stylesheet">boolean19.xsl</input-file>
<output-file role="principal" compare="XML">boolean19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean20">
<file-path>boolean</file-path>
<purpose>Test of boolean "and" operator with two strings; strings are evaluated to True if there length &gt; 1.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean20.xml</input-file>
<input-file role="principal-stylesheet">boolean20.xsl</input-file>
<output-file role="principal" compare="XML">boolean20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean21">
<file-path>boolean</file-path>
<purpose>Test of boolean "and" operator with one value true and one value false</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean21.xml</input-file>
<input-file role="principal-stylesheet">boolean21.xsl</input-file>
<output-file role="principal" compare="XML">boolean21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean22">
<file-path>boolean</file-path>
<purpose>Test of boolean "and" operator with one value false and one value true</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean22.xml</input-file>
<input-file role="principal-stylesheet">boolean22.xsl</input-file>
<output-file role="principal" compare="XML">boolean22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean23">
<file-path>boolean</file-path>
<purpose>Test of boolean "and" operator with two strings that look like numbers</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean23.xml</input-file>
<input-file role="principal-stylesheet">boolean23.xsl</input-file>
<output-file role="principal" compare="XML">boolean23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean24">
<file-path>boolean</file-path>
<purpose>Test of boolean "or" operator with true first, then false</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean24.xml</input-file>
<input-file role="principal-stylesheet">boolean24.xsl</input-file>
<output-file role="principal" compare="XML">boolean24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean25">
<file-path>boolean</file-path>
<purpose>Test of boolean "or" operator, false first, then true</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean25.xml</input-file>
<input-file role="principal-stylesheet">boolean25.xsl</input-file>
<output-file role="principal" compare="XML">boolean25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean26">
<file-path>boolean</file-path>
<purpose>Test of boolean "or" operator with two false values</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean26.xml</input-file>
<input-file role="principal-stylesheet">boolean26.xsl</input-file>
<output-file role="principal" compare="XML">boolean26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean27">
<file-path>boolean</file-path>
<purpose>Test of boolean "or" operator, numeric vs. empty string</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean27.xml</input-file>
<input-file role="principal-stylesheet">boolean27.xsl</input-file>
<output-file role="principal" compare="XML">boolean27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean28">
<file-path>boolean</file-path>
<purpose>Test of boolean "not" operator on a false</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean28.xml</input-file>
<input-file role="principal-stylesheet">boolean28.xsl</input-file>
<output-file role="principal" compare="XML">boolean28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean29">
<file-path>boolean</file-path>
<purpose>Test of boolean "not" operator on a true expression</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean29.xml</input-file>
<input-file role="principal-stylesheet">boolean29.xsl</input-file>
<output-file role="principal" compare="XML">boolean29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean30">
<file-path>boolean</file-path>
<purpose>Test of boolean "not" operator on a false expression</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean30.xml</input-file>
<input-file role="principal-stylesheet">boolean30.xsl</input-file>
<output-file role="principal" compare="XML">boolean30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean31">
<file-path>boolean</file-path>
<purpose>Test of boolean "not" operator on an empty string</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean31.xml</input-file>
<input-file role="principal-stylesheet">boolean31.xsl</input-file>
<output-file role="principal" compare="XML">boolean31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean32">
<file-path>boolean</file-path>
<purpose>Test of boolean "not" operator on a string</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean32.xml</input-file>
<input-file role="principal-stylesheet">boolean32.xsl</input-file>
<output-file role="principal" compare="XML">boolean32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean33">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a non-empty string to true</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean33.xml</input-file>
<input-file role="principal-stylesheet">boolean33.xsl</input-file>
<output-file role="principal" compare="XML">boolean33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean34">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a zero to false</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean34.xml</input-file>
<input-file role="principal-stylesheet">boolean34.xsl</input-file>
<output-file role="principal" compare="XML">boolean34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean35">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a -0 to false</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean35.xml</input-file>
<input-file role="principal-stylesheet">boolean35.xsl</input-file>
<output-file role="principal" compare="XML">boolean35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean36">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a non-zero number to true</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean36.xml</input-file>
<input-file role="principal-stylesheet">boolean36.xsl</input-file>
<output-file role="principal" compare="XML">boolean36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean37">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a problem expression to true</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean37.xml</input-file>
<input-file role="principal-stylesheet">boolean37.xsl</input-file>
<output-file role="principal" compare="XML">boolean37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean38">
<file-path>boolean</file-path>
<purpose>Display a problem expression</purpose>
<spec-citation place="7.6.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">boolean38.xml</input-file>
<input-file role="principal-stylesheet">boolean38.xsl</input-file>
<output-file role="principal" compare="XML">boolean38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean39">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a problem expression</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean39.xml</input-file>
<input-file role="principal-stylesheet">boolean39.xsl</input-file>
<output-file role="principal" compare="XML">boolean39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean40">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a node-set to true</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean40.xml</input-file>
<input-file role="principal-stylesheet">boolean40.xsl</input-file>
<output-file role="principal" compare="XML">boolean40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean41">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting an empty node-set to false</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean41.xml</input-file>
<input-file role="principal-stylesheet">boolean41.xsl</input-file>
<output-file role="principal" compare="XML">boolean41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean42">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting a result tree fragment</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean42.xml</input-file>
<input-file role="principal-stylesheet">boolean42.xsl</input-file>
<output-file role="principal" compare="XML">boolean42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean43">
<file-path>boolean</file-path>
<purpose>Test of boolean() function, converting an empty result tree fragment</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean43.xml</input-file>
<input-file role="principal-stylesheet">boolean43.xsl</input-file>
<output-file role="principal" compare="XML">boolean43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean44">
<file-path>boolean</file-path>
<purpose>Test of "&gt;" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean44.xml</input-file>
<input-file role="principal-stylesheet">boolean44.xsl</input-file>
<output-file role="principal" compare="XML">boolean44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean45">
<file-path>boolean</file-path>
<purpose>Test of "&gt;" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean45.xml</input-file>
<input-file role="principal-stylesheet">boolean45.xsl</input-file>
<output-file role="principal" compare="XML">boolean45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean46">
<file-path>boolean</file-path>
<purpose>Test of "&lt;" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean46.xml</input-file>
<input-file role="principal-stylesheet">boolean46.xsl</input-file>
<output-file role="principal" compare="XML">boolean46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean47">
<file-path>boolean</file-path>
<purpose>Test of "&lt;" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean47.xml</input-file>
<input-file role="principal-stylesheet">boolean47.xsl</input-file>
<output-file role="principal" compare="XML">boolean47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean48">
<file-path>boolean</file-path>
<purpose>Test of "&lt;" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean48.xml</input-file>
<input-file role="principal-stylesheet">boolean48.xsl</input-file>
<output-file role="principal" compare="XML">boolean48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean49">
<file-path>boolean</file-path>
<purpose>Test of "&gt;" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean49.xml</input-file>
<input-file role="principal-stylesheet">boolean49.xsl</input-file>
<output-file role="principal" compare="XML">boolean49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean50">
<file-path>boolean</file-path>
<purpose>Test of "&gt;" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean50.xml</input-file>
<input-file role="principal-stylesheet">boolean50.xsl</input-file>
<output-file role="principal" compare="XML">boolean50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean51">
<file-path>boolean</file-path>
<purpose>Test of "&lt;=" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean51.xml</input-file>
<input-file role="principal-stylesheet">boolean51.xsl</input-file>
<output-file role="principal" compare="XML">boolean51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean52">
<file-path>boolean</file-path>
<purpose>Test of "&gt;=" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean52.xml</input-file>
<input-file role="principal-stylesheet">boolean52.xsl</input-file>
<output-file role="principal" compare="XML">boolean52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean53">
<file-path>boolean</file-path>
<purpose>Test of "&lt;=" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean53.xml</input-file>
<input-file role="principal-stylesheet">boolean53.xsl</input-file>
<output-file role="principal" compare="XML">boolean53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean54">
<file-path>boolean</file-path>
<purpose>Test of "&lt;=" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean54.xml</input-file>
<input-file role="principal-stylesheet">boolean54.xsl</input-file>
<output-file role="principal" compare="XML">boolean54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean55">
<file-path>boolean</file-path>
<purpose>Test of "&lt;=" operator</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean55.xml</input-file>
<input-file role="principal-stylesheet">boolean55.xsl</input-file>
<output-file role="principal" compare="XML">boolean55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean56">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that "and" doesn't bother with right operand if left is false</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean56.xml</input-file>
<input-file role="principal-stylesheet">boolean56.xsl</input-file>
<output-file role="principal" compare="XML">boolean56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean57">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that "or" doesn't evaluate right operand if left is true</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean57.xml</input-file>
<input-file role="principal-stylesheet">boolean57.xsl</input-file>
<output-file role="principal" compare="XML">boolean57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean58">
<file-path>boolean</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>If $x is bound to a node-set, then $x="foo" does not mean the same as not($x!="foo"): the former is true if and only if some node in $x has the string-value foo; the latter is true if and only if all nodes in $x have the string-value foo.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean58.xml</input-file>
<input-file role="principal-stylesheet">boolean58.xsl</input-file>
<output-file role="principal" compare="XML">boolean58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean59">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test =, !=, and not, comparing node-set to string, where node-set is empty.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean59.xml</input-file>
<input-file role="principal-stylesheet">boolean59.xsl</input-file>
<output-file role="principal" compare="XML">boolean59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean60">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of the '!=' operator returning false on two numbers.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean60.xml</input-file>
<input-file role="principal-stylesheet">boolean60.xsl</input-file>
<output-file role="principal" compare="XML">boolean60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean61">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of the '!=' operator returning true on two numbers.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean61.xml</input-file>
<input-file role="principal-stylesheet">boolean61.xsl</input-file>
<output-file role="principal" compare="XML">boolean61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean62">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two numbers, one having decimal point and zeroes after</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean62.xml</input-file>
<input-file role="principal-stylesheet">boolean62.xsl</input-file>
<output-file role="principal" compare="XML">boolean62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean63">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two booleans, false first.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean63.xml</input-file>
<input-file role="principal-stylesheet">boolean63.xsl</input-file>
<output-file role="principal" compare="XML">boolean63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean64">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two booleans, true first.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean64.xml</input-file>
<input-file role="principal-stylesheet">boolean64.xsl</input-file>
<output-file role="principal" compare="XML">boolean64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean65">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two booleans that are equal, so false should result.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean65.xml</input-file>
<input-file role="principal-stylesheet">boolean65.xsl</input-file>
<output-file role="principal" compare="XML">boolean65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean66">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two strings that are equal, so false should result.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean66.xml</input-file>
<input-file role="principal-stylesheet">boolean66.xsl</input-file>
<output-file role="principal" compare="XML">boolean66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean67">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two strings that are unequal, so true should result.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean67.xml</input-file>
<input-file role="principal-stylesheet">boolean67.xsl</input-file>
<output-file role="principal" compare="XML">boolean67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean68">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two strings that are unequal, but only in leading spaces.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean68.xml</input-file>
<input-file role="principal-stylesheet">boolean68.xsl</input-file>
<output-file role="principal" compare="XML">boolean68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean69">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '!=' operator on two strings that are unequal, but only in trailing spaces.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean69.xml</input-file>
<input-file role="principal-stylesheet">boolean69.xsl</input-file>
<output-file role="principal" compare="XML">boolean69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean70">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test = on two node-sets, where both are the same.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean70.xml</input-file>
<input-file role="principal-stylesheet">boolean70.xsl</input-file>
<output-file role="principal" compare="XML">boolean70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean71">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test = on two disjoint node-sets.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean71.xml</input-file>
<input-file role="principal-stylesheet">boolean71.xsl</input-file>
<output-file role="principal" compare="XML">boolean71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean72">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test = on two node-sets that have one node in common.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean72.xml</input-file>
<input-file role="principal-stylesheet">boolean72.xsl</input-file>
<output-file role="principal" compare="XML">boolean72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean73">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test != on two node-sets, where both are the same.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean73.xml</input-file>
<input-file role="principal-stylesheet">boolean73.xsl</input-file>
<output-file role="principal" compare="XML">boolean73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean74">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test != on two disjoint node-sets.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean74.xml</input-file>
<input-file role="principal-stylesheet">boolean74.xsl</input-file>
<output-file role="principal" compare="XML">boolean74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean75">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test != on two node-sets that have one node in common.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean75.xml</input-file>
<input-file role="principal-stylesheet">boolean75.xsl</input-file>
<output-file role="principal" compare="XML">boolean75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean76">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test != on two node-sets that have their only node in common.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean76.xml</input-file>
<input-file role="principal-stylesheet">boolean76.xsl</input-file>
<output-file role="principal" compare="XML">boolean76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean77">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of "&lt;" operator comparing two real numbers, true result</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean77.xml</input-file>
<input-file role="principal-stylesheet">boolean77.xsl</input-file>
<output-file role="principal" compare="XML">boolean77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean78">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of "&lt;" operator comparing two real numbers, false result</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean78.xml</input-file>
<input-file role="principal-stylesheet">boolean78.xsl</input-file>
<output-file role="principal" compare="XML">boolean78.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean79">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of "&lt;" operator comparing real to integer, true result</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean79.xml</input-file>
<input-file role="principal-stylesheet">boolean79.xsl</input-file>
<output-file role="principal" compare="XML">boolean79.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean80">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of "&lt;" operator comparing real to integer, false result</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean80.xml</input-file>
<input-file role="principal-stylesheet">boolean80.xsl</input-file>
<output-file role="principal" compare="XML">boolean80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean81">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '=' operator with one number with leading zero, one not. Reverse order of boolean14.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean81.xml</input-file>
<input-file role="principal-stylesheet">boolean81.xsl</input-file>
<output-file role="principal" compare="XML">boolean81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean82">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '=' operator, false value compared against zero. Reverse order of boolean18.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean82.xml</input-file>
<input-file role="principal-stylesheet">boolean82.xsl</input-file>
<output-file role="principal" compare="XML">boolean82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean83">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of '=' operator, boolean to string. Reverse order of boolean15.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean83.xml</input-file>
<input-file role="principal-stylesheet">boolean83.xsl</input-file>
<output-file role="principal" compare="XML">boolean83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean84">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test =, !=, and not, comparing node-set to number.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean84.xml</input-file>
<input-file role="principal-stylesheet">boolean84.xsl</input-file>
<output-file role="principal" compare="XML">boolean84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean85">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test =, !=, and not, comparing node-set to boolean.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean85.xml</input-file>
<input-file role="principal-stylesheet">boolean85.xsl</input-file>
<output-file role="principal" compare="XML">boolean85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean86">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test =, !=, and not, comparing empty node-set to boolean.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean86.xml</input-file>
<input-file role="principal-stylesheet">boolean86.xsl</input-file>
<output-file role="principal" compare="XML">boolean86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean87">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test = and !=, comparing RTF to boolean.</purpose>
<spec-citation place="11.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">boolean87.xml</input-file>
<input-file role="principal-stylesheet">boolean87.xsl</input-file>
<output-file role="principal" compare="XML">boolean87.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean88">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test = and !=, comparing RTF to string.</purpose>
<spec-citation place="11.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">boolean88.xml</input-file>
<input-file role="principal-stylesheet">boolean88.xsl</input-file>
<output-file role="principal" compare="XML">boolean88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean89">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test = and !=, comparing RTF to string.</purpose>
<spec-citation place="11.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">boolean89.xml</input-file>
<input-file role="principal-stylesheet">boolean89.xsl</input-file>
<output-file role="principal" compare="XML">boolean89.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="boolean_boolean90">
<file-path>boolean</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean() on string "1".</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">boolean90.xml</input-file>
<input-file role="principal-stylesheet">boolean90.xsl</input-file>
<output-file role="principal" compare="XML">boolean90.out</output-file>
</scenario>
</test-case>
	
	<test-case category="XSLT-Result-Tree" id="conditional_conditional01">
<file-path>conditional</file-path>
<purpose>General test of choose, with otherwise</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional01.xml</input-file>
<input-file role="principal-stylesheet">conditional01.xsl</input-file>
<output-file role="principal" compare="XML">conditional01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional02">
<file-path>conditional</file-path>
<purpose>Test choose with no matches and missing otherwise clause.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional02.xml</input-file>
<input-file role="principal-stylesheet">conditional02.xsl</input-file>
<output-file role="principal" compare="XML">conditional02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional03">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for "when" testing on nonexsisent attribute node.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional03.xml</input-file>
<input-file role="principal-stylesheet">conditional03.xsl</input-file>
<output-file role="principal" compare="XML">conditional03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional04">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:when by itself, success.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional04.xml</input-file>
<input-file role="principal-stylesheet">conditional04.xsl</input-file>
<output-file role="principal" compare="XML">conditional04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional05">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test two xsl:when elements without xsl:otherwise, one succeeding.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional05.xml</input-file>
<input-file role="principal-stylesheet">conditional05.xsl</input-file>
<output-file role="principal" compare="XML">conditional05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional06">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test two xsl:when, no xsl:otherwise, second matches.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional06.xml</input-file>
<input-file role="principal-stylesheet">conditional06.xsl</input-file>
<output-file role="principal" compare="XML">conditional06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional07">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test single when by itself, fail.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional07.xml</input-file>
<input-file role="principal-stylesheet">conditional07.xsl</input-file>
<output-file role="principal" compare="XML">conditional07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional08">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test failing when with xsl:otherwise.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional08.xml</input-file>
<input-file role="principal-stylesheet">conditional08.xsl</input-file>
<output-file role="principal" compare="XML">conditional08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional09">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test single when with xsl:otherwise, success on when.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional09.xml</input-file>
<input-file role="principal-stylesheet">conditional09.xsl</input-file>
<output-file role="principal" compare="XML">conditional09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional10">
<file-path>conditional</file-path>
<purpose>Test xsl:if with simplistic boolean expression.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional10.xml</input-file>
<input-file role="principal-stylesheet">conditional10.xsl</input-file>
<output-file role="principal" compare="XML">conditional10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional11">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:if with test expression that converts to boolean true.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional11.xml</input-file>
<input-file role="principal-stylesheet">conditional11.xsl</input-file>
<output-file role="principal" compare="XML">conditional11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional12">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:if with test involving current node value.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional12.xml</input-file>
<input-file role="principal-stylesheet">conditional12.xsl</input-file>
<output-file role="principal" compare="XML">conditional12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional13">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:if with boolean function and test of current node.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional13.xml</input-file>
<input-file role="principal-stylesheet">conditional13.xsl</input-file>
<output-file role="principal" compare="XML">conditional13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional14">
<file-path>conditional</file-path>
<purpose>Test xsl:if with test of subelement value.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional14.xml</input-file>
<input-file role="principal-stylesheet">conditional14.xsl</input-file>
<output-file role="principal" compare="XML">conditional14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional15">
<file-path>conditional</file-path>
<purpose>Test xsl:if with equality of result tree fragments.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional15.xml</input-file>
<input-file role="principal-stylesheet">conditional15.xsl</input-file>
<output-file role="principal" compare="XML">conditional15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional16">
<file-path>conditional</file-path>
<purpose>Test of compound conditions within xsl:if.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional16.xml</input-file>
<input-file role="principal-stylesheet">conditional16.xsl</input-file>
<output-file role="principal" compare="XML">conditional16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional17">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that only the content of the first matching xsl:when is instantiated.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional17.xml</input-file>
<input-file role="principal-stylesheet">conditional17.xsl</input-file>
<output-file role="principal" compare="XML">conditional17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional18">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that xsl:if can be nested.</purpose>
<spec-citation place="9.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional18.xml</input-file>
<input-file role="principal-stylesheet">conditional18.xsl</input-file>
<output-file role="principal" compare="XML">conditional18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional19">
<file-path>conditional</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that xsl:choose can be nested.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional19.xml</input-file>
<input-file role="principal-stylesheet">conditional19.xsl</input-file>
<output-file role="principal" compare="XML">conditional19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional20">
<file-path>conditional</file-path>
<purpose>Test two xsl:when elements using a variable in the test.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional20.xml</input-file>
<input-file role="principal-stylesheet">conditional20.xsl</input-file>
<output-file role="principal" compare="XML">conditional20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional21">
<file-path>conditional</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test xsl:if inside xsl:otherwise.</purpose>
<spec-citation place="9" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional21.xml</input-file>
<input-file role="principal-stylesheet">conditional21.xsl</input-file>
<output-file role="principal" compare="XML">conditional21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional22">
<file-path>conditional</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test xsl:if inside xsl:when.</purpose>
<spec-citation place="9" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional22.xml</input-file>
<input-file role="principal-stylesheet">conditional22.xsl</input-file>
<output-file role="principal" compare="XML">conditional22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conditional_conditional23">
<file-path>conditional</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a function (round) in the test attribute.</purpose>
<spec-citation place="9.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conditional23.xml</input-file>
<input-file role="principal-stylesheet">conditional23.xsl</input-file>
<output-file role="principal" compare="XML">conditional23.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="conflictres_conflictres01">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test match of element name.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres01.xml</input-file>
<input-file role="principal-stylesheet">conflictres01.xsl</input-file>
<output-file role="principal" compare="XML">conflictres01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres02">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution on wildcard names.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres02.xml</input-file>
<input-file role="principal-stylesheet">conflictres02.xsl</input-file>
<output-file role="principal" compare="XML">conflictres02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres03">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution - nodetype.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres03.xml</input-file>
<input-file role="principal-stylesheet">conflictres03.xsl</input-file>
<output-file role="principal" compare="XML">conflictres03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres04">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for nodetest override of default priority. Also, node selected is attribute instead of element.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres04.xml</input-file>
<input-file role="principal-stylesheet">conflictres04.xsl</input-file>
<output-file role="principal" compare="XML">conflictres04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres05">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution between simple and non-simple node patterns.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres05.xml</input-file>
<input-file role="principal-stylesheet">conflictres05.xsl</input-file>
<output-file role="principal" compare="XML">conflictres05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres06">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution on a predicate</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres06.xml</input-file>
<input-file role="principal-stylesheet">conflictres06.xsl</input-file>
<output-file role="principal" compare="XML">conflictres06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres07">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution with 2 non-simple patterns (predicate and '/')</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres07.xml</input-file>
<input-file role="principal-stylesheet">conflictres07.xsl</input-file>
<output-file role="principal" compare="XML">conflictres07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres08">
<file-path>conflictres</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution with 2 non-simple patterns ('/' and predicate)</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres08.xml</input-file>
<input-file role="principal-stylesheet">conflictres08.xsl</input-file>
<output-file role="principal" compare="XML">conflictres08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres10">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that second instance of template wins.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres10.xml</input-file>
<input-file role="principal-stylesheet">conflictres10.xsl</input-file>
<output-file role="principal" compare="XML">conflictres10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres11">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution - two different node tests.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres11.xml</input-file>
<input-file role="principal-stylesheet">conflictres11.xsl</input-file>
<output-file role="principal" compare="XML">conflictres11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres12">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that child and descendant are equal in priority.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres12.xml</input-file>
<input-file role="principal-stylesheet">conflictres12.xsl</input-file>
<output-file role="principal" compare="XML">conflictres12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres13">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that two patterns containing * at one level are equal in priority, despite one * being deeper.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres13.xml</input-file>
<input-file role="principal-stylesheet">conflictres13.xsl</input-file>
<output-file role="principal" compare="XML">conflictres13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres14">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that pattern containing * at one level is equal in priority to one containing * at two levels.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres14.xml</input-file>
<input-file role="principal-stylesheet">conflictres14.xsl</input-file>
<output-file role="principal" compare="XML">conflictres14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres15">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that pattern a//c is higher priority than a/*/c, even though it allows more nodes to qualify.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres15.xml</input-file>
<input-file role="principal-stylesheet">conflictres15.xsl</input-file>
<output-file role="principal" compare="XML">conflictres15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres16">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution on a predicate of a wildcard</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres16.xml</input-file>
<input-file role="principal-stylesheet">conflictres16.xsl</input-file>
<output-file role="principal" compare="XML">conflictres16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres17">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>If equal priorities are explicitly assigned, default priority rules have no effect on resolving conflicts.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres17.xml</input-file>
<input-file role="principal-stylesheet">conflictres17.xsl</input-file>
<output-file role="principal" compare="XML">conflictres17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres18">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that @foo has higher priority than @*.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres18.xml</input-file>
<input-file role="principal-stylesheet">conflictres18.xsl</input-file>
<output-file role="principal" compare="XML">conflictres18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres19">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test priority rankings of non-namespaced and namespaced attributes. The @ped:* ranks above @* and below the others.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres19.xml</input-file>
<input-file role="principal-stylesheet">conflictres19.xsl</input-file>
<output-file role="principal" compare="XML">conflictres19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres20">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test priority rankings of non-namespaced and namespaced elements. The ped:* ranks above * and below the others.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres20.xml</input-file>
<input-file role="principal-stylesheet">conflictres20.xsl</input-file>
<output-file role="principal" compare="XML">conflictres20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres21">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution on a predicate of a node test.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres21.xml</input-file>
<input-file role="principal-stylesheet">conflictres21.xsl</input-file>
<output-file role="principal" compare="XML">conflictres21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres22">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution on a predicate of a node test for comments.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres22.xml</input-file>
<input-file role="principal-stylesheet">conflictres22.xsl</input-file>
<output-file role="principal" compare="XML">conflictres22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres23">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution on processing-instruction() node test.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres23.xml</input-file>
<input-file role="principal-stylesheet">conflictres23.xsl</input-file>
<output-file role="principal" compare="XML">conflictres23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres24">
<file-path>conflictres</file-path>
<creator>Gary Peskin</creator>
<date>2001-11-08</date>
<purpose>Test for conflict resolution on templates assigned equal priority.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres24.xml</input-file>
<input-file role="principal-stylesheet">conflictres24.xsl</input-file>
<output-file role="principal" compare="XML">conflictres24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres25">
<file-path>conflictres</file-path>
<creator>Santiago Pericas-Geertsen</creator>
<date>2001-11-08</date>
<purpose>Test explicit priorities vs. default for attributes.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres25.xml</input-file>
<input-file role="principal-stylesheet">conflictres25.xsl</input-file>
<output-file role="principal" compare="XML">conflictres25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres26">
<file-path>conflictres</file-path>
<creator>Santiago Pericas-Geertsen</creator>
<date>2001-11-08</date>
<purpose>Test explicit priorities vs. default for attributes.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres26.xml</input-file>
<input-file role="principal-stylesheet">conflictres26.xsl</input-file>
<output-file role="principal" compare="XML">conflictres26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres27">
<file-path>conflictres</file-path>
<creator>Santiago Pericas-Geertsen</creator>
<date>2001-11-08</date>
<purpose>Test explicit priorities for "*".</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres27.xml</input-file>
<input-file role="principal-stylesheet">conflictres27.xsl</input-file>
<output-file role="principal" compare="XML">conflictres27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres28">
<file-path>conflictres</file-path>
<creator>Santiago Pericas-Geertsen</creator>
<date>2001-11-08</date>
<purpose>Test explicit priority for "node()", higher than default of -0.5</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres28.xml</input-file>
<input-file role="principal-stylesheet">conflictres28.xsl</input-file>
<output-file role="principal" compare="XML">conflictres28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres29">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test conflict of two ways to wildcard attributes. Also assign conflicting priority on a template.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres29.xml</input-file>
<input-file role="principal-stylesheet">conflictres29.xsl</input-file>
<output-file role="principal" compare="XML">conflictres29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres30">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test conflict of two ways to wildcard attributes.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres30.xml</input-file>
<input-file role="principal-stylesheet">conflictres30.xsl</input-file>
<output-file role="principal" compare="XML">conflictres30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres31">
<file-path>conflictres</file-path>
<creator>Tom Amiro</creator>
<date>2001-11-08</date>
<purpose>Test system allocated priorities for "*[]".</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres31.xml</input-file>
<input-file role="principal-stylesheet">conflictres31.xsl</input-file>
<output-file role="principal" compare="XML">conflictres31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres32">
<file-path>conflictres</file-path>
<creator>Tom Amiro</creator>
<date>2001-11-08</date>
<purpose>Test system allocated priorities for "@*[]".</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres32.xml</input-file>
<input-file role="principal-stylesheet">conflictres32.xsl</input-file>
<output-file role="principal" compare="XML">conflictres32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres33">
<file-path>conflictres</file-path>
<creator>Tom Amiro</creator>
<date>2001-11-08</date>
<purpose>Test system allocated priorities for "node()[]"</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres33.xml</input-file>
<input-file role="principal-stylesheet">conflictres33.xsl</input-file>
<output-file role="principal" compare="XML">conflictres33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres34">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Confirm default priority of 0 for processing-instruction('name') pattern.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres34.xml</input-file>
<input-file role="principal-stylesheet">conflictres34.xsl</input-file>
<output-file role="principal" compare="XML">conflictres34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres35">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that pattern a//b is equal priority than a/b, even though it allows more nodes to qualify.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres35.xml</input-file>
<input-file role="principal-stylesheet">conflictres35.xsl</input-file>
<output-file role="principal" compare="XML">conflictres35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="conflictres_conflictres36">
<file-path>conflictres</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that pattern containing * at one level is equal in priority to one containing * at a lower level.</purpose>
<spec-citation place="5.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">conflictres36.xml</input-file>
<input-file role="principal-stylesheet">conflictres36.xsl</input-file>
<output-file role="principal" compare="XML">conflictres36.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="copy_copy01">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for simple identity transformation with template match</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy01.xml</input-file>
<input-file role="principal-stylesheet">copy01.xsl</input-file>
<output-file role="principal" compare="XML">copy01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy02">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for simple tree copy, in main template via copy-of naming the document element</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy02.xml</input-file>
<input-file role="principal-stylesheet">copy02.xsl</input-file>
<output-file role="principal" compare="XML">copy02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy03">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use identity transformation to put document tree into result tree fragment, then use xsl:copy-of to move to result</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy03.xml</input-file>
<input-file role="principal-stylesheet">copy03.xsl</input-file>
<output-file role="principal" compare="XML">copy03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy04">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of whole tree via wildcard pattern</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy04.xml</input-file>
<input-file role="principal-stylesheet">copy04.xsl</input-file>
<output-file role="principal" compare="XML">copy04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy05">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test copy-of a string constant</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy05.xml</input-file>
<input-file role="principal-stylesheet">copy05.xsl</input-file>
<output-file role="principal" compare="XML">copy05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy06">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of a number</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy06.xml</input-file>
<input-file role="principal-stylesheet">copy06.xsl</input-file>
<output-file role="principal" compare="XML">copy06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy07">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for copying attributes from source to result tree</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy07.xml</input-file>
<input-file role="principal-stylesheet">copy07.xsl</input-file>
<output-file role="principal" compare="XML">copy07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy08">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of passing HTML to a named template.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy08.xml</input-file>
<input-file role="principal-stylesheet">copy08.xsl</input-file>
<output-file role="principal" compare="XML">copy08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy09">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:copy-of with nodeset. Shows handling of namespaces.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy09.xml</input-file>
<input-file role="principal-stylesheet">copy09.xsl</input-file>
<output-file role="principal" compare="XML">copy09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy10">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use copy-of to put a tree fragment under an element.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy10.xml</input-file>
<input-file role="principal-stylesheet">copy10.xsl</input-file>
<output-file role="principal" compare="XML">copy10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy11">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use copy-of to put a non-tree node-set under an element.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy11.xml</input-file>
<input-file role="principal-stylesheet">copy11.xsl</input-file>
<output-file role="principal" compare="XML">copy11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy12">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of with boolean constant</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy12.xml</input-file>
<input-file role="principal-stylesheet">copy12.xsl</input-file>
<output-file role="principal" compare="XML">copy12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy13">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of with '*' wildcard pattern</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy13.xml</input-file>
<input-file role="principal-stylesheet">copy13.xsl</input-file>
<output-file role="principal" compare="XML">copy13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy14">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of with '*' wildcard pattern</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy14.xml</input-file>
<input-file role="principal-stylesheet">copy14.xsl</input-file>
<output-file role="principal" compare="XML">copy14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy15">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each inside xsl:copy</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy15.xml</input-file>
<input-file role="principal-stylesheet">copy15.xsl</input-file>
<output-file role="principal" compare="XML">copy15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy16">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use id(node-set) to try to create a set of nodes in random order. Either id() or xsl:copy is arranging them in document order.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">copy16.xml</input-file>
<input-file role="principal-stylesheet">copy16.xsl</input-file>
<output-file role="principal" compare="XML">copy16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy17">
<file-path>copy</file-path>
<purpose>Test for identity transformation exactly as in spec.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy17.xml</input-file>
<input-file role="principal-stylesheet">copy17.xsl</input-file>
<output-file role="principal" compare="XML">copy17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy18">
<file-path>copy</file-path>
<creator>Gertjan van Son</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of with union of attribute nodes.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy18.xml</input-file>
<input-file role="principal-stylesheet">copy18.xsl</input-file>
<output-file role="principal" compare="XML">copy18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy19">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test copy-of a string constant containing character entity</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy19.xml</input-file>
<input-file role="principal-stylesheet">copy19.xsl</input-file>
<output-file role="principal" compare="XML">copy19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy20">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test copy-of a string constant containing character entity</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy20.xml</input-file>
<input-file role="principal-stylesheet">copy20.xsl</input-file>
<output-file role="principal" compare="XML">copy20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy21">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that external entity reference works in copy.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy21.xml</input-file>
<input-file role="principal-stylesheet">copy21.xsl</input-file>
<output-file role="principal" compare="XML">copy21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy22">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that external entity reference with high-byte character works in copy.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy22.xml</input-file>
<input-file role="principal-stylesheet">copy22.xsl</input-file>
<output-file role="principal" compare="XML">copy22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy23">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of text nodes including CDATA.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy23.xml</input-file>
<input-file role="principal-stylesheet">copy23.xsl</input-file>
<output-file role="principal" compare="XML">copy23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy24">
<file-path>copy</file-path>
<creator>Myriam Midy</creator>
<date>2001-11-08</date>
<purpose>Test for processing-instruction() node-test in copy-of.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">copy24.xml</input-file>
<input-file role="principal-stylesheet">copy24.xsl</input-file>
<output-file role="principal" compare="XML">copy24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy25">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Accumulate attributes from several places in the source.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy25.xml</input-file>
<input-file role="principal-stylesheet">copy25.xsl</input-file>
<output-file role="principal" compare="XML">copy25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy26">
<file-path>copy</file-path>
<creator>Bob Morris</creator>
<date>2001-11-08</date>
<purpose>Should be able to copy the same tree fragment twice in succession.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy26.xml</input-file>
<input-file role="principal-stylesheet">copy26.xsl</input-file>
<output-file role="principal" compare="XML">copy26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy27">
<file-path>copy</file-path>
<creator>Oliver Becker</creator>
<date>2001-11-08</date>
<purpose>Demonstrate copying a named template from the stylesheet into the result. From a thread on XSL-list 7/30/2001.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy27.xml</input-file>
<input-file role="principal-stylesheet">copy27.xsl</input-file>
<output-file role="principal" compare="XML">copy27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy28">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for copy-of an empty node.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy28.xml</input-file>
<input-file role="principal-stylesheet">copy28.xsl</input-file>
<output-file role="principal" compare="XML">copy28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy29">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>current() should work in copy-of.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy29.xml</input-file>
<input-file role="principal-stylesheet">copy29.xsl</input-file>
<output-file role="principal" compare="XML">copy29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy30">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use key() to try to create a set of nodes in random order.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy30.xml</input-file>
<input-file role="principal-stylesheet">copy30.xsl</input-file>
<output-file role="principal" compare="XML">copy30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy31">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:copy with nodeset. Shows handling of namespaces.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy31.xml</input-file>
<input-file role="principal-stylesheet">copy31.xsl</input-file>
<output-file role="principal" compare="XML">copy31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy32">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Make each comment be the current node, and copy it.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy32.xml</input-file>
<input-file role="principal-stylesheet">copy32.xsl</input-file>
<output-file role="principal" compare="XML">copy32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy33">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Make each PI be the current node, and copy it.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy33.xml</input-file>
<input-file role="principal-stylesheet">copy33.xsl</input-file>
<output-file role="principal" compare="XML">copy33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy34">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Make an RTF of the whole doc and watch for incorrect xml-decl placement.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy34.xml</input-file>
<input-file role="principal-stylesheet">copy34.xsl</input-file>
<output-file role="principal" compare="XML">copy34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy35">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Make a node-set of the whole doc and watch for incorrect xml-decl placement.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy35.xml</input-file>
<input-file role="principal-stylesheet">copy35.xsl</input-file>
<output-file role="principal" compare="XML">copy35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy36">
<file-path>copy</file-path>
<creator>&lt;Jochen.Schwarze@cit.de&gt;</creator>
<date>2001-11-08</date>
<purpose>Use prefixed attributes with no preceding text nodes.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy36.xml</input-file>
<input-file role="principal-stylesheet">copy36.xsl</input-file>
<output-file role="principal" compare="XML">copy36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy37">
<file-path>copy</file-path>
<creator>Tom Amiro</creator>
<date>2001-11-08</date>
<purpose>Look for bug in building union for identity transform.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy37.xml</input-file>
<input-file role="principal-stylesheet">copy37.xsl</input-file>
<output-file role="principal" compare="XML">copy37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy38">
<file-path>copy</file-path>
<creator>Michael Kay</creator>
<date>2001-11-08</date>
<purpose>Using copy-of for repeated output of an RTF (HTML output)</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy38.xml</input-file>
<input-file role="principal-stylesheet">copy38.xsl</input-file>
<output-file role="principal" compare="XML">copy38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy39">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Another style of identity transform, where attributes are copied by copy-of rather than by recursive use of the template.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy39.xml</input-file>
<input-file role="principal-stylesheet">copy39.xsl</input-file>
<output-file role="principal" compare="XML">copy39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy40">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use key() to get nodes from various places, then copy and mark.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy40.xml</input-file>
<input-file role="principal-stylesheet">copy40.xsl</input-file>
<output-file role="principal" compare="XML">copy40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy41">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to copy a comment before there is any element produced.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy41.xml</input-file>
<input-file role="principal-stylesheet">copy41.xsl</input-file>
<output-file role="principal" compare="XML">copy41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy42">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Demonstrate sorting of tree fragments</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy42.xml</input-file>
<input-file role="principal-stylesheet">copy42.xsl</input-file>
<output-file role="principal" compare="XML">copy42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy43">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Copy the whole input tree to non-root position in output. "a root node is copied by copying its children"</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy43.xml</input-file>
<input-file role="principal-stylesheet">copy43.xsl</input-file>
<output-file role="principal" compare="XML">copy43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy44">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Introduce namespace nodes through copy-of (i.e., no earlier reference).</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy44.xml</input-file>
<input-file role="principal-stylesheet">copy44.xsl</input-file>
<output-file role="principal" compare="XML">copy44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy45">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Make an RTF on the fly and watch for incorrect xml-decl placement.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy45.xml</input-file>
<input-file role="principal-stylesheet">copy45.xsl</input-file>
<output-file role="principal" compare="XML">copy45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy46">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Introduce namespace nodes through copy-of where select ignores namespace.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy46.xml</input-file>
<input-file role="principal-stylesheet">copy46.xsl</input-file>
<output-file role="principal" compare="XML">copy46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy47">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that exclude-result-prefixes doesn't affect copy-of.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy47.xml</input-file>
<input-file role="principal-stylesheet">copy47.xsl</input-file>
<output-file role="principal" compare="XML">copy47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy48">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Unusual effect: "foo" is in effect on each copied node, but excluded from LREs "out" and "union".</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy48.xml</input-file>
<input-file role="principal-stylesheet">copy48.xsl</input-file>
<output-file role="principal" compare="XML">copy48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy49">
<file-path>copy</file-path>
<creator>Tony Pentinnen</creator>
<date>2001-11-08</date>
<purpose>Verify xml:lang attributes can be copied from source to result</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy49.xml</input-file>
<input-file role="principal-stylesheet">copy49.xsl</input-file>
<output-file role="principal" compare="XML">copy49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy50">
<file-path>copy</file-path>
<creator>Joerg Heinicke (joerg.heinicke@gmx.de)</creator>
<date>2001-11-08</date>
<purpose>Attribute encountered before first copied node must not be copied.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="add-attribute-to-non-element" behavior="ignore"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">copy50.xml</input-file>
<input-file role="principal-stylesheet">copy50.xsl</input-file>
<output-file role="principal" compare="XML">copy50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy51">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:copy on namespaces referenced directly.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy51.xml</input-file>
<input-file role="principal-stylesheet">copy51.xsl</input-file>
<output-file role="principal" compare="XML">copy51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy52">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Make each PI of a certain name be the current node, and copy it.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy52.xml</input-file>
<input-file role="principal-stylesheet">copy52.xsl</input-file>
<output-file role="principal" compare="XML">copy52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy53">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Copy all PIs of a certain name via copy-of.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy53.xml</input-file>
<input-file role="principal-stylesheet">copy53.xsl</input-file>
<output-file role="principal" compare="XML">copy53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy54">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Copy some PIs with a multiply-filtered select.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy54.xml</input-file>
<input-file role="principal-stylesheet">copy54.xsl</input-file>
<output-file role="principal" compare="XML">copy54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy55">
<file-path>copy</file-path>
<creator>Tom Amiro</creator>
<date>2001-11-08</date>
<purpose>Test copy-of identity transformation on XML with namespace nodes that redefines the default and one prefixed namespace on inner element.</purpose>
<spec-citation place="7.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy55.xml</input-file>
<input-file role="principal-stylesheet">copy55.xsl</input-file>
<output-file role="principal" compare="XML">copy55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy56">
<file-path>copy</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use copy-of to attempt to put a node-set in an attribute.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy56.xml</input-file>
<input-file role="principal-stylesheet">copy56.xsl</input-file>
<output-file role="principal" compare="XML">copy56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy57">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use copy-of to put a node-set in an attribute, where all members are text nodes.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy57.xml</input-file>
<input-file role="principal-stylesheet">copy57.xsl</input-file>
<output-file role="principal" compare="XML">copy57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy58">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use copy-of to put a node-set in an attribute, where some members are text nodes.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy58.xml</input-file>
<input-file role="principal-stylesheet">copy58.xsl</input-file>
<output-file role="principal" compare="XML">copy58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy59">
<file-path>copy</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Use copy-of to put a node-set and RTF in a comment, where some members are text nodes.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy59.xml</input-file>
<input-file role="principal-stylesheet">copy59.xsl</input-file>
<output-file role="principal" compare="XML">copy59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy60">
<file-path>copy</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Use copy-of to put a node-set and RTF in a PI, where some members are text nodes.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">copy60.xml</input-file>
<input-file role="principal-stylesheet">copy60.xsl</input-file>
<output-file role="principal" compare="XML">copy60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy61">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to copy an attribute, via copy, after child element.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="add-attribute-after-children"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">copy61.xml</input-file>
<input-file role="principal-stylesheet">copy61.xsl</input-file>
<output-file role="principal" compare="XML">copy61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="copy_copy62">
<file-path>copy</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to copy an attribute, via copy-of, after child element.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="add-attribute-after-children"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">copy62.xml</input-file>
<input-file role="principal-stylesheet">copy62.xsl</input-file>
<output-file role="principal" compare="XML">copy62.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="dflt_dflt01">
<file-path>dflt</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for built-in template rule for attributes.</purpose>
<spec-citation place="5.8" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">dflt01.xml</input-file>
<input-file role="principal-stylesheet">dflt01.xsl</input-file>
<output-file role="principal" compare="XML">dflt01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="dflt_dflt02">
<file-path>dflt</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of built-in template for text nodes.</purpose>
<spec-citation place="5.8" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">dflt02.xml</input-file>
<input-file role="principal-stylesheet">dflt02.xsl</input-file>
<output-file role="principal" compare="XML">dflt02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="dflt_dflt03">
<file-path>dflt</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of built-in template for elements.</purpose>
<spec-citation place="5.8" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">dflt03.xml</input-file>
<input-file role="principal-stylesheet">dflt03.xsl</input-file>
<output-file role="principal" compare="XML">dflt03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="dflt_dflt04">
<file-path>dflt</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of built-in template for elements for a named mode.</purpose>
<spec-citation place="5.8" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">dflt04.xml</input-file>
<input-file role="principal-stylesheet">dflt04.xsl</input-file>
<output-file role="principal" compare="XML">dflt04.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="expression_expression01">
<file-path>expression</file-path>
<purpose>Test of lang() function, with exact match on "en"</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">expression01.xml</input-file>
<input-file role="principal-stylesheet">expression01.xsl</input-file>
<output-file role="principal" compare="XML">expression01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="expression_expression02">
<file-path>expression</file-path>
<purpose>Invoke unparsed-entity-uri function</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">expression02.xml</input-file>
<input-file role="principal-stylesheet">expression02.xsl</input-file>
<output-file role="principal" compare="XML">expression02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="expression_expression03">
<file-path>expression</file-path>
<purpose>Test of lang() function, matching "en-us" to partial qualifier</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">expression03.xml</input-file>
<input-file role="principal-stylesheet">expression03.xsl</input-file>
<output-file role="principal" compare="XML">expression03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="expression_expression04">
<file-path>expression</file-path>
<purpose>Test of lang() function</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">expression04.xml</input-file>
<input-file role="principal-stylesheet">expression04.xsl</input-file>
<output-file role="principal" compare="XML">expression04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="expression_expression05">
<file-path>expression</file-path>
<purpose>Test of lang() function, attempting to match "EN" to "en"</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">expression05.xml</input-file>
<input-file role="principal-stylesheet">expression05.xsl</input-file>
<output-file role="principal" compare="XML">expression05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="expression_expression06">
<file-path>expression</file-path>
<purpose>Test of lang() function in a for-each</purpose>
<spec-citation place="4.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">expression06.xml</input-file>
<input-file role="principal-stylesheet">expression06.xsl</input-file>
<output-file role="principal" compare="XML">expression06.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="extend_extend01">
<file-path>extend</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Testing Conformance specific extension stuff. The top-level usage of a extension element is not really allowed and should be ignored. Therefore the first xsl:fallback should also be ignored.</purpose>
<spec-citation place="14" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">extend01.xml</input-file>
<input-file role="principal-stylesheet">extend01.xsl</input-file>
<output-file role="principal" compare="XML">extend01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="extend_extend02">
<file-path>extend</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Testing that xsl:fallback engages when required.</purpose>
<spec-citation place="15" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">extend02.xml</input-file>
<input-file role="principal-stylesheet">extend02.xsl</input-file>
<output-file role="principal" compare="XML">extend02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="extend_extend03">
<file-path>extend</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test function-available and element-available with xslt elements and functions.</purpose>
<spec-citation place="14" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">extend03.xml</input-file>
<input-file role="principal-stylesheet">extend03.xsl</input-file>
<output-file role="principal" compare="XML">extend03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="extend_extend04">
<file-path>extend</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each inside xsl:fallback. Also have content with in the extension.</purpose>
<spec-citation place="15" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">extend04.xml</input-file>
<input-file role="principal-stylesheet">extend04.xsl</input-file>
<output-file role="principal" compare="XML">extend04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="extend_extend05.xsl">
<file-path>extend</file-path>
<purpose>Using element-available function to test for vendor extensions</purpose>
<spec-citation place="14" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">extend05.xml</input-file>
<input-file role="principal-stylesheet">extend05.xsl</input-file>
<output-file role="principal" compare="XML">extend05.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="idkey_idkey01">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test generate-id() as used in grouping.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey01.xml</input-file>
<input-file role="principal-stylesheet">idkey01.xsl</input-file>
<output-file role="principal" compare="XML">idkey01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey02">
<file-path>idkey</file-path>
<purpose>Make one keyspace and use it.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey02.xml</input-file>
<input-file role="principal-stylesheet">idkey02.xsl</input-file>
<output-file role="principal" compare="XML">idkey02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey03">
<file-path>idkey</file-path>
<purpose>Test for key() in template pattern matching.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey03.xml</input-file>
<input-file role="principal-stylesheet">idkey03.xsl</input-file>
<output-file role="principal" compare="XML">idkey03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey04">
<file-path>idkey</file-path>
<purpose>Test for id().</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey04.xml</input-file>
<input-file role="principal-stylesheet">idkey04.xsl</input-file>
<output-file role="principal" compare="XML">idkey04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey05">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key, where value of use is a string constant.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey05.xml</input-file>
<input-file role="principal-stylesheet">idkey05.xsl</input-file>
<output-file role="principal" compare="XML">idkey05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey06">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of 'generate-id()' - ensure same node generates same ID.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey06.xml</input-file>
<input-file role="principal-stylesheet">idkey06.xsl</input-file>
<output-file role="principal" compare="XML">idkey06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey07">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of generate-id() uniqueness.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey07.xml</input-file>
<input-file role="principal-stylesheet">idkey07.xsl</input-file>
<output-file role="principal" compare="XML">idkey07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey08">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key, where value of use is an integer.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey08.xml</input-file>
<input-file role="principal-stylesheet">idkey08.xsl</input-file>
<output-file role="principal" compare="XML">idkey08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey09">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id() behaving well when there is no DTD to designate an ID.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey09.xml</input-file>
<input-file role="principal-stylesheet">idkey09.xsl</input-file>
<output-file role="principal" compare="XML">idkey09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey10">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for match attribute being first in xsl:key.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey10.xml</input-file>
<input-file role="principal-stylesheet">idkey10.xsl</input-file>
<output-file role="principal" compare="XML">idkey10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey11">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for use attribute being first in xsl:key.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey11.xml</input-file>
<input-file role="principal-stylesheet">idkey11.xsl</input-file>
<output-file role="principal" compare="XML">idkey11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey12">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key matching multiple keys on same node.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey12.xml</input-file>
<input-file role="principal-stylesheet">idkey12.xsl</input-file>
<output-file role="principal" compare="XML">idkey12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey13">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key matching multiple nodes on same looked-up value.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey13.xml</input-file>
<input-file role="principal-stylesheet">idkey13.xsl</input-file>
<output-file role="principal" compare="XML">idkey13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey15">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:key where match nodes occur at different levels in the document.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey15.xml</input-file>
<input-file role="principal-stylesheet">idkey15.xsl</input-file>
<output-file role="principal" compare="XML">idkey15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey16">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for three keyspaces using the same nodes as keys.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey16.xml</input-file>
<input-file role="principal-stylesheet">idkey16.xsl</input-file>
<output-file role="principal" compare="XML">idkey16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey17">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test key() with a node-set as second argument.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey17.xml</input-file>
<input-file role="principal-stylesheet">idkey17.xsl</input-file>
<output-file role="principal" compare="XML">idkey17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey18">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test combination of key() and document() as suggested in spec.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey18.xml</input-file>
<input-file role="principal-stylesheet">idkey18.xsl</input-file>
<output-file role="principal" compare="XML">idkey18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey19">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key and key() with a qualified name.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey19.xml</input-file>
<input-file role="principal-stylesheet">idkey19.xsl</input-file>
<output-file role="principal" compare="XML">idkey19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey20">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key being imported.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey20.xml</input-file>
<input-file role="principal-stylesheet">idkey20.xsl</input-file>
<output-file role="principal" compare="XML">idkey20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey21">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for nested calls to key() function.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey21.xml</input-file>
<input-file role="principal-stylesheet">idkey21.xsl</input-file>
<output-file role="principal" compare="XML">idkey21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey22">
<file-path>idkey</file-path>
<creator>David Marston (original idea sent in by user)</creator>
<date>2001-11-08</date>
<purpose>Test for id() in complex structure.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey22.xml</input-file>
<input-file role="principal-stylesheet">idkey22.xsl</input-file>
<output-file role="principal" compare="XML">idkey22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey23">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id() with a non-matching value.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey23.xml</input-file>
<input-file role="principal-stylesheet">idkey23.xsl</input-file>
<output-file role="principal" compare="XML">idkey23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey24">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id(string), where string is a whitespace-separated list of values.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey24.xml</input-file>
<input-file role="principal-stylesheet">idkey24.xsl</input-file>
<output-file role="principal" compare="XML">idkey24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey25">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for variable as first argument to key().</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey25.xml</input-file>
<input-file role="principal-stylesheet">idkey25.xsl</input-file>
<output-file role="principal" compare="XML">idkey25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey26">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id(node-set), where node-set has multiple values.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey26.xml</input-file>
<input-file role="principal-stylesheet">idkey26.xsl</input-file>
<output-file role="principal" compare="XML">idkey26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey27">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test whether blank keying (use) value works or is ignored.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey27.xml</input-file>
<input-file role="principal-stylesheet">idkey27.xsl</input-file>
<output-file role="principal" compare="XML">idkey27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey28">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test whether blank keying (use) value works when it's an attribute.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey28.xml</input-file>
<input-file role="principal-stylesheet">idkey28.xsl</input-file>
<output-file role="principal" compare="XML">idkey28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey29">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use content of an element as the "use" value.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey29.xml</input-file>
<input-file role="principal-stylesheet">idkey29.xsl</input-file>
<output-file role="principal" compare="XML">idkey29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey30">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that 'generate-id()' on various kinds of nodes yields unique values for each</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey30.xml</input-file>
<input-file role="principal-stylesheet">idkey30.xsl</input-file>
<output-file role="principal" compare="XML">idkey30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey31">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of 'generate-id()' on namespace nodes</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey31.xml</input-file>
<input-file role="principal-stylesheet">idkey31.xsl</input-file>
<output-file role="principal" compare="XML">idkey31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey32">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use key() for sorting with apply-templates.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey32.xml</input-file>
<input-file role="principal-stylesheet">idkey32.xsl</input-file>
<output-file role="principal" compare="XML">idkey32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey33">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use key() for sorting in for-each.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey33.xml</input-file>
<input-file role="principal-stylesheet">idkey33.xsl</input-file>
<output-file role="principal" compare="XML">idkey33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey34">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test descendants of node-set from key().</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey34.xml</input-file>
<input-file role="principal-stylesheet">idkey34.xsl</input-file>
<output-file role="principal" compare="XML">idkey34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey35">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test descendants of node-set from key() in a match pattern.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey35.xml</input-file>
<input-file role="principal-stylesheet">idkey35.xsl</input-file>
<output-file role="principal" compare="XML">idkey35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey36">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for three keyspaces, some being imported.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey36.xml</input-file>
<input-file role="principal-stylesheet">idkey36.xsl</input-file>
<output-file role="principal" compare="XML">idkey36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey37">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test id(list) filtered by a predicate, in a match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey37.xml</input-file>
<input-file role="principal-stylesheet">idkey37.xsl</input-file>
<output-file role="principal" compare="XML">idkey37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey38">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test id() filtered by a predicate, in a match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey38.xml</input-file>
<input-file role="principal-stylesheet">idkey38.xsl</input-file>
<output-file role="principal" compare="XML">idkey38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey39">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test id(list) with lower path filtered by a predicate, in a match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey39.xml</input-file>
<input-file role="principal-stylesheet">idkey39.xsl</input-file>
<output-file role="principal" compare="XML">idkey39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey40">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Find text in a node with particular ID, via match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey40.xml</input-file>
<input-file role="principal-stylesheet">idkey40.xsl</input-file>
<output-file role="principal" compare="XML">idkey40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey41">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Find all text under a node with particular ID, via match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey41.xml</input-file>
<input-file role="principal-stylesheet">idkey41.xsl</input-file>
<output-file role="principal" compare="XML">idkey41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey42">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Find all text under IDed node and apply predicate, via match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey42.xml</input-file>
<input-file role="principal-stylesheet">idkey42.xsl</input-file>
<output-file role="principal" compare="XML">idkey42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey43">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use variables in predicate of match pattern that also has id()</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey43.xml</input-file>
<input-file role="principal-stylesheet">idkey43.xsl</input-file>
<output-file role="principal" compare="XML">idkey43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey44">
<file-path>idkey</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test simple key()// filtered by a predicate, in a match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey44.xml</input-file>
<input-file role="principal-stylesheet">idkey44.xsl</input-file>
<output-file role="principal" compare="XML">idkey44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey45">
<file-path>idkey</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test complex key()// filtered by a predicate in predicate, in a match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey45.xml</input-file>
<input-file role="principal-stylesheet">idkey45.xsl</input-file>
<output-file role="principal" compare="XML">idkey45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey46">
<file-path>idkey</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test complex key()//x in match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey46.xml</input-file>
<input-file role="principal-stylesheet">idkey46.xsl</input-file>
<output-file role="principal" compare="XML">idkey46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey47">
<file-path>idkey</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test complex key()//x/x in match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey47.xml</input-file>
<input-file role="principal-stylesheet">idkey47.xsl</input-file>
<output-file role="principal" compare="XML">idkey47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey48">
<file-path>idkey</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test complex key()//x/x, with complex predicate in match pattern.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey48.xml</input-file>
<input-file role="principal-stylesheet">idkey48.xsl</input-file>
<output-file role="principal" compare="XML">idkey48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey49">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test generate-id() when nodes are coming from different documents. All IDs should be distinct.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey49.xml</input-file>
<input-file role="principal-stylesheet">idkey49.xsl</input-file>
<output-file role="principal" compare="XML">idkey49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey50">
<file-path>idkey</file-path>
<creator>Uche Ogbuji, adapted by David Marston</creator>
<date>2001-11-08</date>
<purpose>Test combination of key() and document() reading from stylesheet.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey50.xml</input-file>
<input-file role="principal-stylesheet">idkey50.xsl</input-file>
<output-file role="principal" compare="XML">idkey50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey51">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test two calls to generate-id() on the same file. All IDs should be the same. If both filenames were given literally, the spec says that IDs must match. Retrieving the name from the principal XML document should still clearly mean the same file. Putting nodes in a variable is more of a gray area.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey51.xml</input-file>
<input-file role="principal-stylesheet">idkey51.xsl</input-file>
<output-file role="principal" compare="XML">idkey51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey52">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test combination of key() and document() on multiple files.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey52.xml</input-file>
<input-file role="principal-stylesheet">idkey52.xsl</input-file>
<output-file role="principal" compare="XML">idkey52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey53">
<file-path>idkey</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key and key() with a qualified name, different prefix.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey53.xml</input-file>
<input-file role="principal-stylesheet">idkey53.xsl</input-file>
<output-file role="principal" compare="XML">idkey53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey54">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:key and key() with a leaing underscore in the name.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey54.xml</input-file>
<input-file role="principal-stylesheet">idkey54.xsl</input-file>
<output-file role="principal" compare="XML">idkey54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey55">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id(list) and position() in a for-each loop</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey55.xml</input-file>
<input-file role="principal-stylesheet">idkey55.xsl</input-file>
<output-file role="principal" compare="XML">idkey55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey56">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id(list) and position() in apply-templates</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey56.xml</input-file>
<input-file role="principal-stylesheet">idkey56.xsl</input-file>
<output-file role="principal" compare="XML">idkey56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey57">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id(node-set), where node-set has a string with a list of ID values.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey57.xml</input-file>
<input-file role="principal-stylesheet">idkey57.xsl</input-file>
<output-file role="principal" compare="XML">idkey57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey58">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for id($var), where $var has a string with a list of ID values.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey58.xml</input-file>
<input-file role="principal-stylesheet">idkey58.xsl</input-file>
<output-file role="principal" compare="XML">idkey58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey59">
<file-path>idkey</file-path>
<creator>Frank Weiss</creator>
<date>2001-11-08</date>
<purpose>Test xsl:key with union in "use" attribute.</purpose>
<spec-citation place="12.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey59.xml</input-file>
<input-file role="principal-stylesheet">idkey59.xsl</input-file>
<output-file role="principal" compare="XML">idkey59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey60">
<file-path>idkey</file-path>
<creator>Henry Zongaro</creator>
<date>2001-11-08</date>
<purpose>Try multiple child steps after id() in match patterns</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">idkey60.xml</input-file>
<input-file role="principal-stylesheet">idkey60.xsl</input-file>
<output-file role="principal" compare="XML">idkey60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey61">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for count() of id(), multiple values.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey61.xml</input-file>
<input-file role="principal-stylesheet">idkey61.xsl</input-file>
<output-file role="principal" compare="XML">idkey61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey62">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for count() of id(), one value.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey62.xml</input-file>
<input-file role="principal-stylesheet">idkey62.xsl</input-file>
<output-file role="principal" compare="XML">idkey62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="idkey_idkey63">
<file-path>idkey</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for count() of id(), no matching values.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">idkey63.xml</input-file>
<input-file role="principal-stylesheet">idkey63.xsl</input-file>
<output-file role="principal" compare="XML">idkey63.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="impincl_impincl01">
<file-path>impincl</file-path>
<purpose>Test of basic Import &amp; Include functionality.</purpose>
<spec-citation place="2.6.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl01.xml</input-file>
<input-file role="principal-stylesheet">impincl01.xsl</input-file>
<output-file role="principal" compare="XML">impincl01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl02">
<file-path>impincl</file-path>
<purpose>Included document's xsl:import (f imports g) is moved into the including document. Import precedence is (high) impincl02, g (low)</purpose>
<spec-citation place="2.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl02.xml</input-file>
<input-file role="principal-stylesheet">impincl02.xsl</input-file>
<output-file role="principal" compare="XML">impincl02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl03">
<file-path>impincl</file-path>
<purpose>Nest imports and includes so that there are two of each, import on top.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl03.xml</input-file>
<input-file role="principal-stylesheet">impincl03.xsl</input-file>
<output-file role="principal" compare="XML">impincl03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl04">
<file-path>impincl</file-path>
<purpose>Verifies; "A relative URI is resolved relative to the base URI of the xsl:include element". The included document loads from an included file that resides in a different subdirectory.</purpose>
<spec-citation place="2.6.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl04.xml</input-file>
<input-file role="principal-stylesheet">impincl04.xsl</input-file>
<output-file role="principal" compare="XML">impincl04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl05">
<file-path>impincl</file-path>
<purpose>Two imports, each of which has an import, plus an apply-imports in main stylesheet. Precedence (low) DBECA (high) per spec.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl05.xml</input-file>
<input-file role="principal-stylesheet">impincl05.xsl</input-file>
<output-file role="principal" compare="XML">impincl05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl06">
<file-path>impincl</file-path>
<purpose>Two includes (see below), each of which has an import.</purpose>
<spec-citation place="2.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl06.xml</input-file>
<input-file role="principal-stylesheet">impincl06.xsl</input-file>
<output-file role="principal" compare="XML">impincl06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl07">
<file-path>impincl</file-path>
<purpose>Show the significance of the order of xsl:import declarations.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl07.xml</input-file>
<input-file role="principal-stylesheet">impincl07.xsl</input-file>
<output-file role="principal" compare="XML">impincl07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl08">
<file-path>impincl</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Loads document from an included file that resides in a different subdirectory.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl08.xml</input-file>
<input-file role="principal-stylesheet">impincl08.xsl</input-file>
<output-file role="principal" compare="XML">impincl08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl09">
<file-path>impincl</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>The resource located by the href attribute value is parsed as an XML document, and the children of the xsl:stylesheet element in this document replace the xsl:include element in the including document. (No namespaces should be copied over.</purpose>
<spec-citation place="2.6.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl09.xml</input-file>
<input-file role="principal-stylesheet">impincl09.xsl</input-file>
<output-file role="principal" compare="XML">impincl09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl10">
<file-path>impincl</file-path>
<purpose>General test of xsl:apply-imports from spec.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl10.xml</input-file>
<input-file role="principal-stylesheet">impincl10.xsl</input-file>
<output-file role="principal" compare="XML">impincl10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl11">
<file-path>impincl</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Nest imports and includes using relative paths.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl11.xml</input-file>
<input-file role="principal-stylesheet">impincl11.xsl</input-file>
<output-file role="principal" compare="XML">impincl11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl12">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that apply-imports really means imports, not includes</purpose>
<spec-citation place="2.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl12.xml</input-file>
<input-file role="principal-stylesheet">impincl12.xsl</input-file>
<output-file role="principal" compare="XML">impincl12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl13">
<file-path>impincl</file-path>
<creator>David Marston, from an idea by Norm Walsh</creator>
<date>2001-11-08</date>
<purpose>Show that included templates doing apply-imports *will* get includer's import tree.</purpose>
<spec-citation place="2.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl13.xml</input-file>
<input-file role="principal-stylesheet">impincl13.xsl</input-file>
<output-file role="principal" compare="XML">impincl13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl14">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that apply-imports has limited scope of rules to search.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl14.xml</input-file>
<input-file role="principal-stylesheet">impincl14.xsl</input-file>
<output-file role="principal" compare="XML">impincl14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl15">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that apply-imports stays in same mode as what called it.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl15.xml</input-file>
<input-file role="principal-stylesheet">impincl15.xsl</input-file>
<output-file role="principal" compare="XML">impincl15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl16">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of importing a basic stylesheet involving matching.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">impincl16.xml</input-file>
<input-file role="principal-stylesheet">impincl16.xsl</input-file>
<output-file role="principal" compare="XML">impincl16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl17">
<file-path>impincl</file-path>
<creator>Claudio Sacerdoti Coen, revised by David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of importing a stylesheet involving keys.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">impincl17.xml</input-file>
<input-file role="principal-stylesheet">impincl17.xsl</input-file>
<output-file role="principal" compare="XML">impincl17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl18">
<file-path>impincl</file-path>
<creator>Gary L Peskin</creator>
<date>2001-11-08</date>
<purpose>When no stylesheets are imported, an xsl:apply-imports should select the built-in templates.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl18.xml</input-file>
<input-file role="principal-stylesheet">impincl18.xsl</input-file>
<output-file role="principal" compare="XML">impincl18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl19">
<file-path>impincl</file-path>
<creator>Vikranth Reddy (vreddy@covigo.com)</creator>
<date>2001-11-08</date>
<purpose>Test of import (down and up directory tree) using ..\main_import.xsl from two separate subdiretories. Filename deliberately repeated!</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl19.xml</input-file>
<input-file role="principal-stylesheet">impincl19.xsl</input-file>
<output-file role="principal" compare="XML">impincl19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl20">
<file-path>impincl</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Show that apply-imports applies on its matching node, not children.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl20.xml</input-file>
<input-file role="principal-stylesheet">impincl20.xsl</input-file>
<output-file role="principal" compare="XML">impincl20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl21">
<file-path>impincl</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Show selection of templates from files with 1st and 2nd import precedence.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl21.xml</input-file>
<input-file role="principal-stylesheet">impincl21.xsl</input-file>
<output-file role="principal" compare="XML">impincl21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl22">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>With two imports, precedence goes to the last one. Import precedence for templates matching foo (f imports g) is (high) h, f, g (low)</purpose>
<spec-citation place="2.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl22.xml</input-file>
<input-file role="principal-stylesheet">impincl22.xsl</input-file>
<output-file role="principal" compare="XML">impincl22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl23">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Included document's xsl:import (i23incl imports i23sub) is moved into the including document. Import precedence for templates matching foo is (high) i23sub, h (low)</purpose>
<spec-citation place="2.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl23.xml</input-file>
<input-file role="principal-stylesheet">impincl23.xsl</input-file>
<output-file role="principal" compare="XML">impincl23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl24">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that global variables are in scope in apply-imports templates.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl24.xml</input-file>
<input-file role="principal-stylesheet">impincl24.xsl</input-file>
<output-file role="principal" compare="XML">impincl24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl25">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show apply-imports matching a template deeper into the import tree.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl25.xml</input-file>
<input-file role="principal-stylesheet">impincl25.xsl</input-file>
<output-file role="principal" compare="XML">impincl25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl26">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Each apply-imports must take its own view of the import tree.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl26.xml</input-file>
<input-file role="principal-stylesheet">impincl26.xsl</input-file>
<output-file role="principal" compare="XML">impincl26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl27">
<file-path>impincl</file-path>
<creator>Morris Kwan</creator>
<date>2001-11-08</date>
<purpose>href is a URI containing the "file:" scheme part.</purpose>
<spec-citation place="2.6.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl27.xml</input-file>
<input-file role="principal-stylesheet">impincl27.xsl</input-file>
<output-file role="principal" compare="XML">impincl27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl28">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>See what happens to apply-imports when there is a param stack in place.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl28.xml</input-file>
<input-file role="principal-stylesheet">impincl28.xsl</input-file>
<output-file role="principal" compare="XML">impincl28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="impincl_impincl29">
<file-path>impincl</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>See what happens to apply-imports when there is a param stack in place on the upper apply-templates, but no xsl:param to receive p1 until we get to the import.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">impincl29.xml</input-file>
<input-file role="principal-stylesheet">impincl29.xsl</input-file>
<output-file role="principal" compare="XML">impincl29.out</output-file>
</scenario>
</test-case>
	
	<test-case category="XSLT-Result-Tree" id="lre_lre01">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Basic demonstration that namespace node is added when namespaced attribute is instantiated.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre01.xml</input-file>
<input-file role="principal-stylesheet">lre01.xsl</input-file>
<output-file role="principal" compare="XML">lre01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre02">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test exclusion of prefixes specified as xsl:stylesheet attribute.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre02.xml</input-file>
<input-file role="principal-stylesheet">lre02.xsl</input-file>
<output-file role="principal" compare="XML">lre02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre03">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test exclude-result-prefixes as an attribute on an LRE.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre03.xml</input-file>
<input-file role="principal-stylesheet">lre03.xsl</input-file>
<output-file role="principal" compare="XML">lre03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre04">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>The designation of a namespace as an excluded namespace is effective within the subtree of the stylesheet rooted at the element bearing the exclude-result-prefixes or xsl:exclude-result-prefixes attribute.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre04.xml</input-file>
<input-file role="principal-stylesheet">lre04.xsl</input-file>
<output-file role="principal" compare="XML">lre04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre05">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Show that exclude-result-prefixes is scoped to just it's LRE.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre05.xml</input-file>
<input-file role="principal-stylesheet">lre05.xsl</input-file>
<output-file role="principal" compare="XML">lre05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre06">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests that the value of an attribute of a LRE is interpreted as a attribute value template, which can contain expressions within curly braces({}).</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre06.xml</input-file>
<input-file role="principal-stylesheet">lre06.xsl</input-file>
<output-file role="principal" compare="XML">lre06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre07">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Show that attributes from XSLT namespace are automatically excluded.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre07.xml</input-file>
<input-file role="principal-stylesheet">lre07.xsl</input-file>
<output-file role="principal" compare="XML">lre07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre08">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>The name attribute of xsl:element is interpreted as an attribute value template.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre08.xml</input-file>
<input-file role="principal-stylesheet">lre08.xsl</input-file>
<output-file role="principal" compare="XML">lre08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre09">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that names are preserved, case and all.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre09.xml</input-file>
<input-file role="principal-stylesheet">lre09.xsl</input-file>
<output-file role="principal" compare="XML">lre09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre10">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that attributes from extension namespaces cause inclusion of the namespace node.</purpose>
<purpose>The created element node will also have a copy of the namespace nodes that were present on the element node in the stylesheet tree with the exception of any namespace node whose string-value is the XSLT namespace URI, a namespace URI declared as an extension namespace, or a namespace URI designated as an excluded namespace.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre10.xml</input-file>
<input-file role="principal-stylesheet">lre10.xsl</input-file>
<output-file role="principal" compare="XML">lre10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre12">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test warning if required element name is null.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre12.xml</input-file>
<input-file role="principal-stylesheet">lre12.xsl</input-file>
<output-file role="principal" compare="XML">lre12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre13">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to put out text without any tags.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre13.xml</input-file>
<input-file role="principal-stylesheet">lre13.xsl</input-file>
<output-file role="principal" compare="XML">lre13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre14">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each inside xsl:element</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre14.xml</input-file>
<input-file role="principal-stylesheet">lre14.xsl</input-file>
<output-file role="principal" compare="XML">lre14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre15">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>xsl:exclude-result-prefixes should only work to omit namespace declarations that are not actually used.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre15.xml</input-file>
<input-file role="principal-stylesheet">lre15.xsl</input-file>
<output-file role="principal" compare="XML">lre15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre16">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to put out value of a variable as an LRE. Get "$var" literally.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre16.xml</input-file>
<input-file role="principal-stylesheet">lre16.xsl</input-file>
<output-file role="principal" compare="XML">lre16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre17">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>xsl:exclude-result-prefixes should only work to omit namespace declarations that are not actually used.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre17.xml</input-file>
<input-file role="principal-stylesheet">lre17.xsl</input-file>
<output-file role="principal" compare="XML">lre17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre18">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>xsl:exclude-result-prefixes should only work to omit namespace declarations that are not actually used.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre18.xml</input-file>
<input-file role="principal-stylesheet">lre18.xsl</input-file>
<output-file role="principal" compare="XML">lre18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre19">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test use of leading underscore in names.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre19.xml</input-file>
<input-file role="principal-stylesheet">lre19.xsl</input-file>
<output-file role="principal" compare="XML">lre19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre20">
<file-path>lre</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Show that the namespace node for an extension namespace is automatically excluded.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre20.xml</input-file>
<input-file role="principal-stylesheet">lre20.xsl</input-file>
<output-file role="principal" compare="XML">lre20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre21">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Exclude namespace node for an extension namespace via local declaration.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre21.xml</input-file>
<input-file role="principal-stylesheet">lre21.xsl</input-file>
<output-file role="principal" compare="XML">lre21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre22">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test exclusion of #default, stylesheet level.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre22.xml</input-file>
<input-file role="principal-stylesheet">lre22.xsl</input-file>
<output-file role="principal" compare="XML">lre22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="lre_lre23">
<file-path>lre</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test exclusion of #default as an attribute on an LRE.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">lre23.xml</input-file>
<input-file role="principal-stylesheet">lre23.xsl</input-file>
<output-file role="principal" compare="XML">lre23.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="match_match01">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for //name match pattern.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match01.xml</input-file>
<input-file role="principal-stylesheet">match01.xsl</input-file>
<output-file role="principal" compare="XML">match01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match02">
<file-path>match</file-path>
<purpose>Test of predicate, using attribute, in match pattern.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match02.xml</input-file>
<input-file role="principal-stylesheet">match02.xsl</input-file>
<output-file role="principal" compare="XML">match02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match03">
<file-path>match</file-path>
<purpose>Test of @attrib=value in predicate in match pattern.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match03.xml</input-file>
<input-file role="principal-stylesheet">match03.xsl</input-file>
<output-file role="principal" compare="XML">match03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match04">
<file-path>match</file-path>
<purpose>Test of node=value in predicate in match pattern.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match04.xml</input-file>
<input-file role="principal-stylesheet">match04.xsl</input-file>
<output-file role="principal" compare="XML">match04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match05">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of or in predicate of match pattern.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match05.xml</input-file>
<input-file role="principal-stylesheet">match05.xsl</input-file>
<output-file role="principal" compare="XML">match05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match06">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean not function in match pattern.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match06.xml</input-file>
<input-file role="principal-stylesheet">match06.xsl</input-file>
<output-file role="principal" compare="XML">match06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match07">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of node!=value match pattern.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match07.xml</input-file>
<input-file role="principal-stylesheet">match07.xsl</input-file>
<output-file role="principal" compare="XML">match07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match08">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of 2 predicates.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match08.xml</input-file>
<input-file role="principal-stylesheet">match08.xsl</input-file>
<output-file role="principal" compare="XML">match08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match09">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean and in predicate.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match09.xml</input-file>
<input-file role="principal-stylesheet">match09.xsl</input-file>
<output-file role="principal" compare="XML">match09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match10">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of functions in predicate.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match10.xml</input-file>
<input-file role="principal-stylesheet">match10.xsl</input-file>
<output-file role="principal" compare="XML">match10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match11">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of id('literal') as match pattern.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match11.xml</input-file>
<input-file role="principal-stylesheet">match11.xsl</input-file>
<output-file role="principal" compare="XML">match11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match12">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that apply-templates goes down at least 15 levels.</purpose>
<spec-citation place="5.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match12.xml</input-file>
<input-file role="principal-stylesheet">match12.xsl</input-file>
<output-file role="principal" compare="XML">match12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match13">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of large union.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match13.xml</input-file>
<input-file role="principal-stylesheet">match13.xsl</input-file>
<output-file role="principal" compare="XML">match13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match14">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that a variable can be used in a match pattern, though not for the name test. The variable must be top-level, of course.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match14.xml</input-file>
<input-file role="principal-stylesheet">match14.xsl</input-file>
<output-file role="principal" compare="XML">match14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match15">
<file-path>match</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a match patttern with a complex expression.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">match15.xml</input-file>
<input-file role="principal-stylesheet">match15.xsl</input-file>
<output-file role="principal" compare="XML">match15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match16">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test step//step[predicate], with positional predicate, to show that position numbering applies "relative to the child axis", not //.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match16.xml</input-file>
<input-file role="principal-stylesheet">match16.xsl</input-file>
<output-file role="principal" compare="XML">match16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match17">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of 2 predicates, first one being positional.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match17.xml</input-file>
<input-file role="principal-stylesheet">match17.xsl</input-file>
<output-file role="principal" compare="XML">match17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match18">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of predicate with two conditions, one positional.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match18.xml</input-file>
<input-file role="principal-stylesheet">match18.xsl</input-file>
<output-file role="principal" compare="XML">match18.out</output-file>
</scenario>
</test-case>
<!--
MS predicate bugs.

<test-case category="XSLT-Result-Tree" id="match_match19">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of two predicates, second one being positional.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match19.xml</input-file>
<input-file role="principal-stylesheet">match19.xsl</input-file>
<output-file role="principal" compare="XML">match19.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="match_match20">
<file-path>match</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test of two predicates, both being positional. First predicate reduces the set to {a,c,e,g,i,k}.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match20.xml</input-file>
<input-file role="principal-stylesheet">match20.xsl</input-file>
<output-file role="principal" compare="XML">match20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match21">
<file-path>match</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test of three predicates, all being positional. First predicate reduces the set to {a,c,e,g,i,k}.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match21.xml</input-file>
<input-file role="principal-stylesheet">match21.xsl</input-file>
<output-file role="principal" compare="XML">match21.out</output-file>
</scenario>
</test-case>
<!--
MS predicate bugs.

<test-case category="XSLT-Result-Tree" id="match_match22">
<file-path>match</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test of three predicates, all being positional. Different notation. First predicate reduces the set to {a,c,e,g,i,k}.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match22.xml</input-file>
<input-file role="principal-stylesheet">match22.xsl</input-file>
<output-file role="principal" compare="XML">match22.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="match_match23">
<file-path>match</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test of three predicates, all being positional. Use last() for one. First predicate reduces the set to {a,c,e,g,i,k}.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match23.xml</input-file>
<input-file role="principal-stylesheet">match23.xsl</input-file>
<output-file role="principal" compare="XML">match23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match24">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of three predicates, two being positional. Use last() for one. First predicate reduces the set to {a,c,e,g,i,k}. Second predicate, taken alone, reduces the set to {f,g,h,i,j,k,l}.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match24.xml</input-file>
<input-file role="principal-stylesheet">match24.xsl</input-file>
<output-file role="principal" compare="XML">match24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match25">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of three predicates, two being positional. Use last() for one. First predicate reduces the set to {b,e,h,k}. Second predicate further reduces the set to {h,k}.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match25.xml</input-file>
<input-file role="principal-stylesheet">match25.xsl</input-file>
<output-file role="principal" compare="XML">match25.out</output-file>
</scenario>
</test-case>
<!--
MS predicate bugs.

<test-case category="XSLT-Result-Tree" id="match_match26">
<file-path>match</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of three predicates, two being positional. First predicate reduces the set to {a,c,e,g,i,k}. Second predicate further reduces the set to {c}. Third predicate, taken alone, reduces the set to {a,b,c,d,e,f,g,h,i}.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match26.xml</input-file>
<input-file role="principal-stylesheet">match26.xsl</input-file>
<output-file role="principal" compare="XML">match26.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="match_match27">
<file-path>match</file-path>
<creator>David Marston, from an idea by Holger Floerke</creator>
<date>2001-11-08</date>
<purpose>// at start of match pattern should not affect selection of nodes.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match27.xml</input-file>
<input-file role="principal-stylesheet">match27.xsl</input-file>
<output-file role="principal" compare="XML">match27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match28">
<file-path>match</file-path>
<creator>David Marston, from an idea by Holger Floerke</creator>
<date>2001-11-08</date>
<purpose>// at start of match pattern should not affect selection of nodes.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match28.xml</input-file>
<input-file role="principal-stylesheet">match28.xsl</input-file>
<output-file role="principal" compare="XML">match28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match29">
<file-path>match</file-path>
<creator>David Marston, from an idea by Holger Floerke</creator>
<date>2001-11-08</date>
<purpose>// at start of match pattern should not affect selection of nodes.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match29.xml</input-file>
<input-file role="principal-stylesheet">match29.xsl</input-file>
<output-file role="principal" compare="XML">match29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match30">
<file-path>match</file-path>
<creator>Henry Zongaro</creator>
<date>2001-11-08</date>
<purpose>Use multiple levels of child axis in match patterns. Intermix 'child::' and default, but only with child:: in the middle.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match30.xml</input-file>
<input-file role="principal-stylesheet">match30.xsl</input-file>
<output-file role="principal" compare="XML">match30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match31">
<file-path>match</file-path>
<creator>Henry Zongaro</creator>
<date>2001-11-08</date>
<purpose>Use multiple levels of child axis in match patterns. Intermix 'child::' and default, but only with child:: on the tail.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match31.xml</input-file>
<input-file role="principal-stylesheet">match31.xsl</input-file>
<output-file role="principal" compare="XML">match31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="match_match32">
<file-path>match</file-path>
<creator>Henry Zongaro</creator>
<date>2001-11-08</date>
<purpose>Use multiple levels of child axis in match patterns. Spell out 'child::' sometimes.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">match32.xml</input-file>
<input-file role="principal-stylesheet">match32.xsl</input-file>
<output-file role="principal" compare="XML">match32.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="math_math01">
<file-path>math</file-path>
<purpose>Test of number() conversion function on an element.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math01.xml</input-file>
<input-file role="principal-stylesheet">math01.xsl</input-file>
<output-file role="principal" compare="XML">math01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math02">
<file-path>math</file-path>
<purpose>Test of floor().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math02.xml</input-file>
<input-file role="principal-stylesheet">math02.xsl</input-file>
<output-file role="principal" compare="XML">math02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math03">
<file-path>math</file-path>
<purpose>Test of ceiling().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math03.xml</input-file>
<input-file role="principal-stylesheet">math03.xsl</input-file>
<output-file role="principal" compare="XML">math03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math04">
<file-path>math</file-path>
<purpose>Test of round().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math04.xml</input-file>
<input-file role="principal-stylesheet">math04.xsl</input-file>
<output-file role="principal" compare="XML">math04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math05">
<file-path>math</file-path>
<purpose>Test of sum().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math05.xml</input-file>
<input-file role="principal-stylesheet">math05.xsl</input-file>
<output-file role="principal" compare="XML">math05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math06">
<file-path>math</file-path>
<purpose>Test of '*' operator.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math06.xml</input-file>
<input-file role="principal-stylesheet">math06.xsl</input-file>
<output-file role="principal" compare="XML">math06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math07">
<file-path>math</file-path>
<purpose>Test of '+' operator.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math07.xml</input-file>
<input-file role="principal-stylesheet">math07.xsl</input-file>
<output-file role="principal" compare="XML">math07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math08">
<file-path>math</file-path>
<purpose>Test of '-' operator. Note since XML allows "-" in names the "-" operator typically needs to be preceded by whitespace.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math08.xml</input-file>
<input-file role="principal-stylesheet">math08.xsl</input-file>
<output-file role="principal" compare="XML">math08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math09">
<file-path>math</file-path>
<purpose>Test of 'div' operator.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math09.xml</input-file>
<input-file role="principal-stylesheet">math09.xsl</input-file>
<output-file role="principal" compare="XML">math09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math10">
<file-path>math</file-path>
<purpose>Test of 'mod' operator.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math10.xml</input-file>
<input-file role="principal-stylesheet">math10.xsl</input-file>
<output-file role="principal" compare="XML">math10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math11">
<file-path>math</file-path>
<purpose>Test of number() conversion function on a non-existent node.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math11.xml</input-file>
<input-file role="principal-stylesheet">math11.xsl</input-file>
<output-file role="principal" compare="XML">math11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math12">
<file-path>math</file-path>
<purpose>Test of number() conversion function on numeric input.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math12.xml</input-file>
<input-file role="principal-stylesheet">math12.xsl</input-file>
<output-file role="principal" compare="XML">math12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math13">
<file-path>math</file-path>
<purpose>Test of number() conversion function on a string that is convertible.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math13.xml</input-file>
<input-file role="principal-stylesheet">math13.xsl</input-file>
<output-file role="principal" compare="XML">math13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math14">
<file-path>math</file-path>
<purpose>Test of number() conversion function on a null string.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math14.xml</input-file>
<input-file role="principal-stylesheet">math14.xsl</input-file>
<output-file role="principal" compare="XML">math14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math15">
<file-path>math</file-path>
<purpose>Test of number() conversion function on a string that is not convertible.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math15.xml</input-file>
<input-file role="principal-stylesheet">math15.xsl</input-file>
<output-file role="principal" compare="XML">math15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math16">
<file-path>math</file-path>
<purpose>Test of number() and string() conversion functions for numeric accuracy.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math16.xml</input-file>
<input-file role="principal-stylesheet">math16.xsl</input-file>
<output-file role="principal" compare="XML">math16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math17">
<file-path>math</file-path>
<purpose>Test of number() conversion function on a tree fragment.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math17.xml</input-file>
<input-file role="principal-stylesheet">math17.xsl</input-file>
<output-file role="principal" compare="XML">math17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math18">
<file-path>math</file-path>
<purpose>Test of number() conversion function on an empty tree fragment.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math18.xml</input-file>
<input-file role="principal-stylesheet">math18.xsl</input-file>
<output-file role="principal" compare="XML">math18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math19">
<file-path>math</file-path>
<purpose>Test of number() conversion of boolean constant true.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math19.xml</input-file>
<input-file role="principal-stylesheet">math19.xsl</input-file>
<output-file role="principal" compare="XML">math19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math20">
<file-path>math</file-path>
<purpose>Test of number() conversion of boolean constant false.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math20.xml</input-file>
<input-file role="principal-stylesheet">math20.xsl</input-file>
<output-file role="principal" compare="XML">math20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math21">
<file-path>math</file-path>
<purpose>Test of consistency number() conversion of non-convertible strings.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math21.xml</input-file>
<input-file role="principal-stylesheet">math21.xsl</input-file>
<output-file role="principal" compare="XML">math21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math22">
<file-path>math</file-path>
<purpose>Test of number() conversion of a non-convertible string.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math22.xml</input-file>
<input-file role="principal-stylesheet">math22.xsl</input-file>
<output-file role="principal" compare="XML">math22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math23">
<file-path>math</file-path>
<purpose>Test of floor() on a node.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math23.xml</input-file>
<input-file role="principal-stylesheet">math23.xsl</input-file>
<output-file role="principal" compare="XML">math23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math24">
<file-path>math</file-path>
<purpose>Test of floor() on a non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math24.xml</input-file>
<input-file role="principal-stylesheet">math24.xsl</input-file>
<output-file role="principal" compare="XML">math24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math25">
<file-path>math</file-path>
<purpose>Test of floor() on a node containing a non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math25.xml</input-file>
<input-file role="principal-stylesheet">math25.xsl</input-file>
<output-file role="principal" compare="XML">math25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math26">
<file-path>math</file-path>
<purpose>Test of floor() near a boundary.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math26.xml</input-file>
<input-file role="principal-stylesheet">math26.xsl</input-file>
<output-file role="principal" compare="XML">math26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math27">
<file-path>math</file-path>
<purpose>Test of floor() on a node containing a boundary case.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math27.xml</input-file>
<input-file role="principal-stylesheet">math27.xsl</input-file>
<output-file role="principal" compare="XML">math27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math28">
<file-path>math</file-path>
<purpose>Test of floor() on a negative non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math28.xml</input-file>
<input-file role="principal-stylesheet">math28.xsl</input-file>
<output-file role="principal" compare="XML">math28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math29">
<file-path>math</file-path>
<purpose>Test of floor().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math29.xml</input-file>
<input-file role="principal-stylesheet">math29.xsl</input-file>
<output-file role="principal" compare="XML">math29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math30">
<file-path>math</file-path>
<purpose>Test of floor() of a non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math30.xml</input-file>
<input-file role="principal-stylesheet">math30.xsl</input-file>
<output-file role="principal" compare="XML">math30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math31">
<file-path>math</file-path>
<purpose>Test of floor() on a negative non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math31.xml</input-file>
<input-file role="principal-stylesheet">math31.xsl</input-file>
<output-file role="principal" compare="XML">math31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math32">
<file-path>math</file-path>
<purpose>Test of ceiling() on a node containing an integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math32.xml</input-file>
<input-file role="principal-stylesheet">math32.xsl</input-file>
<output-file role="principal" compare="XML">math32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math33">
<file-path>math</file-path>
<purpose>Test of ceiling() on a non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math33.xml</input-file>
<input-file role="principal-stylesheet">math33.xsl</input-file>
<output-file role="principal" compare="XML">math33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math34">
<file-path>math</file-path>
<purpose>Test of ceiling() of a node containing a non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math34.xml</input-file>
<input-file role="principal-stylesheet">math34.xsl</input-file>
<output-file role="principal" compare="XML">math34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math35">
<file-path>math</file-path>
<purpose>Test of ceiling() on a boundary case.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math35.xml</input-file>
<input-file role="principal-stylesheet">math35.xsl</input-file>
<output-file role="principal" compare="XML">math35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math36">
<file-path>math</file-path>
<purpose>Test of ceiling() on a node containing a boundary case.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math36.xml</input-file>
<input-file role="principal-stylesheet">math36.xsl</input-file>
<output-file role="principal" compare="XML">math36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math37">
<file-path>math</file-path>
<purpose>Test of ceiling().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math37.xml</input-file>
<input-file role="principal-stylesheet">math37.xsl</input-file>
<output-file role="principal" compare="XML">math37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math38">
<file-path>math</file-path>
<purpose>Test of ceiling() on a non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math38.xml</input-file>
<input-file role="principal-stylesheet">math38.xsl</input-file>
<output-file role="principal" compare="XML">math38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math39">
<file-path>math</file-path>
<purpose>Test of ceiling() on a negative non-integer.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math39.xml</input-file>
<input-file role="principal-stylesheet">math39.xsl</input-file>
<output-file role="principal" compare="XML">math39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math40">
<file-path>math</file-path>
<purpose>Test of round() on a node.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math40.xml</input-file>
<input-file role="principal-stylesheet">math40.xsl</input-file>
<output-file role="principal" compare="XML">math40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math41">
<file-path>math</file-path>
<purpose>Test of round() of a non-integer below halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math41.xml</input-file>
<input-file role="principal-stylesheet">math41.xsl</input-file>
<output-file role="principal" compare="XML">math41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math42">
<file-path>math</file-path>
<purpose>Test of round() of a node containing a non-integer below halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math42.xml</input-file>
<input-file role="principal-stylesheet">math42.xsl</input-file>
<output-file role="principal" compare="XML">math42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math43">
<file-path>math</file-path>
<purpose>Test of round() of a boundary case.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math43.xml</input-file>
<input-file role="principal-stylesheet">math43.xsl</input-file>
<output-file role="principal" compare="XML">math43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math44">
<file-path>math</file-path>
<purpose>Test of round() of a node containing a boundary case.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math44.xml</input-file>
<input-file role="principal-stylesheet">math44.xsl</input-file>
<output-file role="principal" compare="XML">math44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math45">
<file-path>math</file-path>
<purpose>Test of round() of a non-integer below halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math45.xml</input-file>
<input-file role="principal-stylesheet">math45.xsl</input-file>
<output-file role="principal" compare="XML">math45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math46">
<file-path>math</file-path>
<purpose>Test of round() of a negative non-integer above halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math46.xml</input-file>
<input-file role="principal-stylesheet">math46.xsl</input-file>
<output-file role="principal" compare="XML">math46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math47">
<file-path>math</file-path>
<purpose>Test of round() of a non-integer above halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math47.xml</input-file>
<input-file role="principal-stylesheet">math47.xsl</input-file>
<output-file role="principal" compare="XML">math47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math48">
<file-path>math</file-path>
<purpose>Test of round() of a negative non-integer below halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math48.xml</input-file>
<input-file role="principal-stylesheet">math48.xsl</input-file>
<output-file role="principal" compare="XML">math48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math49">
<file-path>math</file-path>
<purpose>Test of round() of a non-integer at halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math49.xml</input-file>
<input-file role="principal-stylesheet">math49.xsl</input-file>
<output-file role="principal" compare="XML">math49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math50">
<file-path>math</file-path>
<purpose>Test of round() of a non-integer at halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math50.xml</input-file>
<input-file role="principal-stylesheet">math50.xsl</input-file>
<output-file role="principal" compare="XML">math50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math51">
<file-path>math</file-path>
<purpose>Test of round() of a negative non-integer at halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math51.xml</input-file>
<input-file role="principal-stylesheet">math51.xsl</input-file>
<output-file role="principal" compare="XML">math51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math52">
<file-path>math</file-path>
<purpose>Test of round() of a negative non-integer at halfway.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math52.xml</input-file>
<input-file role="principal-stylesheet">math52.xsl</input-file>
<output-file role="principal" compare="XML">math52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math53">
<file-path>math</file-path>
<purpose>Test of sum().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math53.xml</input-file>
<input-file role="principal-stylesheet">math53.xsl</input-file>
<output-file role="principal" compare="XML">math53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math54">
<file-path>math</file-path>
<purpose>Test of sum().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math54.xml</input-file>
<input-file role="principal-stylesheet">math54.xsl</input-file>
<output-file role="principal" compare="XML">math54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math55">
<file-path>math</file-path>
<purpose>Test of '*' operator on two nodes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math55.xml</input-file>
<input-file role="principal-stylesheet">math55.xsl</input-file>
<output-file role="principal" compare="XML">math55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math56">
<file-path>math</file-path>
<purpose>Test of '*' operator on attributes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math56.xml</input-file>
<input-file role="principal-stylesheet">math56.xsl</input-file>
<output-file role="principal" compare="XML">math56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math57">
<file-path>math</file-path>
<purpose>Test of '+' operator on two nodes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math57.xml</input-file>
<input-file role="principal-stylesheet">math57.xsl</input-file>
<output-file role="principal" compare="XML">math57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math58">
<file-path>math</file-path>
<purpose>Test of '+' operator on two attributes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math58.xml</input-file>
<input-file role="principal-stylesheet">math58.xsl</input-file>
<output-file role="principal" compare="XML">math58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math59">
<file-path>math</file-path>
<purpose>Test of '+' operator on two attributes, without parentheses.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math59.xml</input-file>
<input-file role="principal-stylesheet">math59.xsl</input-file>
<output-file role="principal" compare="XML">math59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math60">
<file-path>math</file-path>
<purpose>Test of '-' operator, negative result.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math60.xml</input-file>
<input-file role="principal-stylesheet">math60.xsl</input-file>
<output-file role="principal" compare="XML">math60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math61">
<file-path>math</file-path>
<purpose>Test of '-' operator on two nodes whose names have hyphens.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math61.xml</input-file>
<input-file role="principal-stylesheet">math61.xsl</input-file>
<output-file role="principal" compare="XML">math61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math62">
<file-path>math</file-path>
<purpose>Test of '+' operator and unary '-'.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math62.xml</input-file>
<input-file role="principal-stylesheet">math62.xsl</input-file>
<output-file role="principal" compare="XML">math62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math63">
<file-path>math</file-path>
<purpose>Test of '+' operator and unary '-' on nodes whose names have hyphens.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math63.xml</input-file>
<input-file role="principal-stylesheet">math63.xsl</input-file>
<output-file role="principal" compare="XML">math63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math64">
<file-path>math</file-path>
<purpose>Test of '-' operator and unary '-'.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math64.xml</input-file>
<input-file role="principal-stylesheet">math64.xsl</input-file>
<output-file role="principal" compare="XML">math64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math65">
<file-path>math</file-path>
<purpose>Test of '-' operator and unary '-' on nodes whose names have hyphens.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math65.xml</input-file>
<input-file role="principal-stylesheet">math65.xsl</input-file>
<output-file role="principal" compare="XML">math65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math66">
<file-path>math</file-path>
<purpose>Test of '-' operator and unary '-'.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math66.xml</input-file>
<input-file role="principal-stylesheet">math66.xsl</input-file>
<output-file role="principal" compare="XML">math66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math67">
<file-path>math</file-path>
<purpose>Test of '-' operator and unary '-' on nodes whose names have hyphens.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math67.xml</input-file>
<input-file role="principal-stylesheet">math67.xsl</input-file>
<output-file role="principal" compare="XML">math67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math68">
<file-path>math</file-path>
<purpose>Test of '-' operator and unary '-' on attributes of nodes whose names have hyphens.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math68.xml</input-file>
<input-file role="principal-stylesheet">math68.xsl</input-file>
<output-file role="principal" compare="XML">math68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math69">
<file-path>math</file-path>
<purpose>Test of '-' operator and unary '-' outside parentheses, with values from attributes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math69.xml</input-file>
<input-file role="principal-stylesheet">math69.xsl</input-file>
<output-file role="principal" compare="XML">math69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math70">
<file-path>math</file-path>
<purpose>Test of 'div' operator, negative divisor.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math70.xml</input-file>
<input-file role="principal-stylesheet">math70.xsl</input-file>
<output-file role="principal" compare="XML">math70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math71">
<file-path>math</file-path>
<purpose>Test of 'div' operator on two nodes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math71.xml</input-file>
<input-file role="principal-stylesheet">math71.xsl</input-file>
<output-file role="principal" compare="XML">math71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math72">
<file-path>math</file-path>
<purpose>Test of 'div' operator on two nodes with confusing names.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math72.xml</input-file>
<input-file role="principal-stylesheet">math72.xsl</input-file>
<output-file role="principal" compare="XML">math72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math73">
<file-path>math</file-path>
<purpose>Test of 'div' operator on two attributes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math73.xml</input-file>
<input-file role="principal-stylesheet">math73.xsl</input-file>
<output-file role="principal" compare="XML">math73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math74">
<file-path>math</file-path>
<purpose>Test of 'div' operator on attributes of nodes with confusing names.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math74.xml</input-file>
<input-file role="principal-stylesheet">math74.xsl</input-file>
<output-file role="principal" compare="XML">math74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math75">
<file-path>math</file-path>
<purpose>Test of 'div' operator with -0 as divisor.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math75.xml</input-file>
<input-file role="principal-stylesheet">math75.xsl</input-file>
<output-file role="principal" compare="XML">math75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math76">
<file-path>math</file-path>
<purpose>Test of 'div' operator, comparing 0 and -0 as divisors.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math76.xml</input-file>
<input-file role="principal-stylesheet">math76.xsl</input-file>
<output-file role="principal" compare="XML">math76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math77">
<file-path>math</file-path>
<purpose>Test of 'div' operator with 0 on both sides.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math77.xml</input-file>
<input-file role="principal-stylesheet">math77.xsl</input-file>
<output-file role="principal" compare="XML">math77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math78">
<file-path>math</file-path>
<purpose>Test of 'div' operator and less-than.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math78.xml</input-file>
<input-file role="principal-stylesheet">math78.xsl</input-file>
<output-file role="principal" compare="XML">math78.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math79">
<file-path>math</file-path>
<purpose>Test of 'mod' operator on two nodes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math79.xml</input-file>
<input-file role="principal-stylesheet">math79.xsl</input-file>
<output-file role="principal" compare="XML">math79.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math80">
<file-path>math</file-path>
<purpose>Test of 'mod' operator on two nodes with confusing names.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math80.xml</input-file>
<input-file role="principal-stylesheet">math80.xsl</input-file>
<output-file role="principal" compare="XML">math80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math81">
<file-path>math</file-path>
<purpose>Test of 'mod' operator on two attributes.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math81.xml</input-file>
<input-file role="principal-stylesheet">math81.xsl</input-file>
<output-file role="principal" compare="XML">math81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math82">
<file-path>math</file-path>
<purpose>Test of 'mod' operator on attributes of nodes with confusing names.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math82.xml</input-file>
<input-file role="principal-stylesheet">math82.xsl</input-file>
<output-file role="principal" compare="XML">math82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math83">
<file-path>math</file-path>
<purpose>Test of 'mod' operator on positive and negative operands.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math83.xml</input-file>
<input-file role="principal-stylesheet">math83.xsl</input-file>
<output-file role="principal" compare="XML">math83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math84">
<file-path>math</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of sum().</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math84.xml</input-file>
<input-file role="principal-stylesheet">math84.xsl</input-file>
<output-file role="principal" compare="XML">math84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math85">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of nesting of parentheses.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math85.xml</input-file>
<input-file role="principal-stylesheet">math85.xsl</input-file>
<output-file role="principal" compare="XML">math85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math86">
<file-path>math</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of repeated use of * to multiply.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math86.xml</input-file>
<input-file role="principal-stylesheet">math86.xsl</input-file>
<output-file role="principal" compare="XML">math86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math87">
<file-path>math</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of repeated division.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math87.xml</input-file>
<input-file role="principal-stylesheet">math87.xsl</input-file>
<output-file role="principal" compare="XML">math87.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math88">
<file-path>math</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Mini stress of x-way multiply and divide.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math88.xml</input-file>
<input-file role="principal-stylesheet">math88.xsl</input-file>
<output-file role="principal" compare="XML">math88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math89">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that NaN propagates through + and parentheses.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math89.xml</input-file>
<input-file role="principal-stylesheet">math89.xsl</input-file>
<output-file role="principal" compare="XML">math89.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math90">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that NaN propagates through * and unary -.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math90.xml</input-file>
<input-file role="principal-stylesheet">math90.xsl</input-file>
<output-file role="principal" compare="XML">math90.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math91">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that NaN propagates through subtraction.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math91.xml</input-file>
<input-file role="principal-stylesheet">math91.xsl</input-file>
<output-file role="principal" compare="XML">math91.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math92">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that NaN propagates through div.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math92.xml</input-file>
<input-file role="principal-stylesheet">math92.xsl</input-file>
<output-file role="principal" compare="XML">math92.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math93">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that NaN propagates through mod.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math93.xml</input-file>
<input-file role="principal-stylesheet">math93.xsl</input-file>
<output-file role="principal" compare="XML">math93.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math94">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that NaN propagates through the numeric functions.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math94.xml</input-file>
<input-file role="principal-stylesheet">math94.xsl</input-file>
<output-file role="principal" compare="XML">math94.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math95">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of sum() with non-number.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math95.xml</input-file>
<input-file role="principal-stylesheet">math95.xsl</input-file>
<output-file role="principal" compare="XML">math95.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math96">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of sum() with unary - in some nodes.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math96.xml</input-file>
<input-file role="principal-stylesheet">math96.xsl</input-file>
<output-file role="principal" compare="XML">math96.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math97">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of repeated use of +.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math97.xml</input-file>
<input-file role="principal-stylesheet">math97.xsl</input-file>
<output-file role="principal" compare="XML">math97.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math98">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of repeated use of -. Space away from - when required.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math98.xml</input-file>
<input-file role="principal-stylesheet">math98.xsl</input-file>
<output-file role="principal" compare="XML">math98.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math99">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that * has precedence over + and -.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math99.xml</input-file>
<input-file role="principal-stylesheet">math99.xsl</input-file>
<output-file role="principal" compare="XML">math99.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math100">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that div has precedence over + and -.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math100.xml</input-file>
<input-file role="principal-stylesheet">math100.xsl</input-file>
<output-file role="principal" compare="XML">math100.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math101">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that mod has precedence over + and -.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math101.xml</input-file>
<input-file role="principal-stylesheet">math101.xsl</input-file>
<output-file role="principal" compare="XML">math101.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math102">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that number() with no argument applies to context node.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math102.xml</input-file>
<input-file role="principal-stylesheet">math102.xsl</input-file>
<output-file role="principal" compare="XML">math102.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math103">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of unary '-' on a union.</purpose>
<spec-citation place="3.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math103.xml</input-file>
<input-file role="principal-stylesheet">math103.xsl</input-file>
<output-file role="principal" compare="XML">math103.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math104">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of is-a-number technique.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math104.xml</input-file>
<input-file role="principal-stylesheet">math104.xsl</input-file>
<output-file role="principal" compare="XML">math104.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math105">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test what value-of does to a large number.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math105.xml</input-file>
<input-file role="principal-stylesheet">math105.xsl</input-file>
<output-file role="principal" compare="XML">math105.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math110">
<file-path>math</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of number() conversion function for small decimal numbers.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math110.xml</input-file>
<input-file role="principal-stylesheet">math110.xsl</input-file>
<output-file role="principal" compare="XML">math110.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="math_math111">
<file-path>math</file-path>
<creator>Gordon Chiu</creator>
<date>2001-11-08</date>
<purpose>Test of string to number conversion for small (yet still representable) decimal numbers.</purpose>
<spec-citation place="4.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">math111.xml</input-file>
<input-file role="principal-stylesheet">math111.xsl</input-file>
<output-file role="principal" compare="XML">math111.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="mdocs_mdocs01">
<file-path>mdocs</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test document() function: Provides multiple input sources. One argument: string.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs01.xml</input-file>
<input-file role="principal-stylesheet">mdocs01.xsl</input-file>
<output-file role="principal" compare="XML">mdocs01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs02">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test nesting of document() function.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs02.xml</input-file>
<input-file role="principal-stylesheet">mdocs02.xsl</input-file>
<output-file role="principal" compare="XML">mdocs02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs03">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test document() function: Provides multiple input sources. Two arguments: string, node-set.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs03.xml</input-file>
<input-file role="principal-stylesheet">mdocs03.xsl</input-file>
<output-file role="principal" compare="XML">mdocs03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs04">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test document() function with one argument: node-set.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs04.xml</input-file>
<input-file role="principal-stylesheet">mdocs04.xsl</input-file>
<output-file role="principal" compare="XML">mdocs04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs05">
<file-path>mdocs</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test document() function with path following.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs05.xml</input-file>
<input-file role="principal-stylesheet">mdocs05.xsl</input-file>
<output-file role="principal" compare="XML">mdocs05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs06">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test document() function with two arguments: node-set, node-set.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs06.xml</input-file>
<input-file role="principal-stylesheet">mdocs06.xsl</input-file>
<output-file role="principal" compare="XML">mdocs06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs07">
<file-path>mdocs</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test document() function: Mini Stress test. The many 'a' elements contain repeats of the file names. Union should not contain duplicate nodes.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs07.xml</input-file>
<input-file role="principal-stylesheet">mdocs07.xsl</input-file>
<output-file role="principal" compare="XML">mdocs07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs08">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test document() function: Generating nodeset based on ancestors of document() union.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs08.xml</input-file>
<input-file role="principal-stylesheet">mdocs08.xsl</input-file>
<output-file role="principal" compare="XML">mdocs08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs09">
<file-path>mdocs</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test that document("") refers to the root node of the stylesheet.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs09.xml</input-file>
<input-file role="principal-stylesheet">mdocs09.xsl</input-file>
<output-file role="principal" compare="XML">mdocs09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs10">
<file-path>mdocs</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test document() function with local file specification.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs10.xml</input-file>
<input-file role="principal-stylesheet">mdocs10.xsl</input-file>
<output-file role="principal" compare="XML">mdocs10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs11">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check that position() counts nodes in external document.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs11.xml</input-file>
<input-file role="principal-stylesheet">mdocs11.xsl</input-file>
<output-file role="principal" compare="XML">mdocs11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs12">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>When document('') refers to the root node of the stylesheet, it means the current file, not the main stylesheet. In this test, the call to document() is in the included stylesheet, hence local to it.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs12.xml</input-file>
<input-file role="principal-stylesheet">mdocs12.xsl</input-file>
<output-file role="principal" compare="XML">mdocs12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs13">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>When document('') refers to the root node of the stylesheet, it means the current file, not the main stylesheet. In this test, the call to document() is in the imported stylesheet, hence local to it.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs13.xml</input-file>
<input-file role="principal-stylesheet">mdocs13.xsl</input-file>
<output-file role="principal" compare="XML">mdocs13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs14">
<file-path>mdocs</file-path>
<creator>Jeni Tennison</creator>
<date>2001-11-08</date>
<purpose>Use document() to perform an include-like operation between two files. At the conformance level, this shows that we can put the node-set from document() into a variable, then reference where a node-set is required.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs14.xml</input-file>
<input-file role="principal-stylesheet">mdocs14.xsl</input-file>
<output-file role="principal" compare="XML">mdocs14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs15">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test / as second argument to document(). Two arguments: string variable, node-set.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs15.xml</input-file>
<input-file role="principal-stylesheet">mdocs15.xsl</input-file>
<output-file role="principal" compare="XML">mdocs15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs16">
<file-path>mdocs</file-path>
<creator>Norm Walsh</creator>
<date>2001-11-08</date>
<purpose>Compare two evaluation sequences for variable containing node-set returned from document() call.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs16.xml</input-file>
<input-file role="principal-stylesheet">mdocs16.xsl</input-file>
<output-file role="principal" compare="XML">mdocs16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs17">
<file-path>mdocs</file-path>
<creator>Doug Tidwell, adapted by David Marston</creator>
<date>2001-11-08</date>
<purpose>Use document('') to refer to the stylesheet, and have a local lookup table.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs17.xml</input-file>
<input-file role="principal-stylesheet">mdocs17.xsl</input-file>
<output-file role="principal" compare="XML">mdocs17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="mdocs_mdocs18">
<file-path>mdocs</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try sorting and numbering nodes from two other documents.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">mdocs18.xml</input-file>
<input-file role="principal-stylesheet">mdocs18.xsl</input-file>
<output-file role="principal" compare="XML">mdocs18.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="message_message01">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Issue a message from a literal constant, default on terminate option</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message01.xml</input-file>
<input-file role="principal-stylesheet">message01.xsl</input-file>
<output-file role="principal" compare="XML">message01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message02">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Issue a message from a literal constant, "no" on terminate option</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message02.xml</input-file>
<input-file role="principal-stylesheet">message02.xsl</input-file>
<output-file role="principal" compare="XML">message02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message03">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:text inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message03.xml</input-file>
<input-file role="principal-stylesheet">message03.xsl</input-file>
<output-file role="principal" compare="XML">message03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message04">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each and value-of inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message04.xml</input-file>
<input-file role="principal-stylesheet">message04.xsl</input-file>
<output-file role="principal" compare="XML">message04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message05">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test if and copy-of inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message05.xml</input-file>
<input-file role="principal-stylesheet">message05.xsl</input-file>
<output-file role="principal" compare="XML">message05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message06">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test choose and variable inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message06.xml</input-file>
<input-file role="principal-stylesheet">message06.xsl</input-file>
<output-file role="principal" compare="XML">message06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message07">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test apply-templates inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message07.xml</input-file>
<input-file role="principal-stylesheet">message07.xsl</input-file>
<output-file role="principal" compare="XML">message07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message08">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test call-template inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message08.xml</input-file>
<input-file role="principal-stylesheet">message08.xsl</input-file>
<output-file role="principal" compare="XML">message08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message09">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test one xsl:message inside another</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message09.xml</input-file>
<input-file role="principal-stylesheet">message09.xsl</input-file>
<output-file role="principal" compare="XML">message09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message10">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:element and xsl:attribute inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message10.xml</input-file>
<input-file role="principal-stylesheet">message10.xsl</input-file>
<output-file role="principal" compare="XML">message10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message11">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:comment inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message11.xml</input-file>
<input-file role="principal-stylesheet">message11.xsl</input-file>
<output-file role="principal" compare="XML">message11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message12">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:processing-instruction inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message12.xml</input-file>
<input-file role="principal-stylesheet">message12.xsl</input-file>
<output-file role="principal" compare="XML">message12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message13">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:copy inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message13.xml</input-file>
<input-file role="principal-stylesheet">message13.xsl</input-file>
<output-file role="principal" compare="XML">message13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message14">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number inside xsl:message; number should appear.</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message14.xml</input-file>
<input-file role="principal-stylesheet">message14.xsl</input-file>
<output-file role="principal" compare="XML">message14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message15">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:fallback inside xsl:message</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message15.xml</input-file>
<input-file role="principal-stylesheet">message15.xsl</input-file>
<output-file role="principal" compare="XML">message15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="message_message16">
<file-path>message</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:message inside xsl:param instead of xsl:template</purpose>
<spec-citation place="13" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">message16.xml</input-file>
<input-file role="principal-stylesheet">message16.xsl</input-file>
<output-file role="principal" compare="XML">message16.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="modes_modes01">
<file-path>modes</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Simple test of xsl:apply-templates with mode.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes01.xml</input-file>
<input-file role="principal-stylesheet">modes01.xsl</input-file>
<output-file role="principal" compare="XML">modes01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes02">
<file-path>modes</file-path>
<purpose>Test of moded template calling xsl:apply-templates on another template.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes02.xml</input-file>
<input-file role="principal-stylesheet">modes02.xsl</input-file>
<output-file role="principal" compare="XML">modes02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes03">
<file-path>modes</file-path>
<purpose>Test of xsl:apply-templates with mode not found.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes03.xml</input-file>
<input-file role="principal-stylesheet">modes03.xsl</input-file>
<output-file role="principal" compare="XML">modes03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes04">
<file-path>modes</file-path>
<purpose>Simple test of xsl:apply-templates with no mode, but with same-pattern template that has a mode available.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes04.xml</input-file>
<input-file role="principal-stylesheet">modes04.xsl</input-file>
<output-file role="principal" compare="XML">modes04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes05">
<file-path>modes</file-path>
<purpose>Simple test of xsl:apply-templates with mode, using the default rule.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes05.xml</input-file>
<input-file role="principal-stylesheet">modes05.xsl</input-file>
<output-file role="principal" compare="XML">modes05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes06">
<file-path>modes</file-path>
<purpose>Test of xsl:apply-templates with mode, using a qualified name.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes06.xml</input-file>
<input-file role="principal-stylesheet">modes06.xsl</input-file>
<output-file role="principal" compare="XML">modes06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes07">
<file-path>modes</file-path>
<purpose>Test of xsl:apply-templates with mode, using a non-qualified name, but with a qualified name in scope.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes07.xml</input-file>
<input-file role="principal-stylesheet">modes07.xsl</input-file>
<output-file role="principal" compare="XML">modes07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes08">
<file-path>modes</file-path>
<purpose>Test of several modes being available.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes08.xml</input-file>
<input-file role="principal-stylesheet">modes08.xsl</input-file>
<output-file role="principal" compare="XML">modes08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes09">
<file-path>modes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test an apply-templates that has no select but has a mode.</purpose>
<spec-citation place="5.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes09.xml</input-file>
<input-file role="principal-stylesheet">modes09.xsl</input-file>
<output-file role="principal" compare="XML">modes09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes10">
<file-path>modes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that we only go into a mode via apply-templates. You can't put a mode on call-template, and the fact that you call a named template that has a mode specifier doesn't mean you are in that mode.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes10.xml</input-file>
<input-file role="principal-stylesheet">modes10.xsl</input-file>
<output-file role="principal" compare="XML">modes10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes11">
<file-path>modes</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test apply-templates for a comment with a mode and moded matching template.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes11.xml</input-file>
<input-file role="principal-stylesheet">modes11.xsl</input-file>
<output-file role="principal" compare="XML">modes11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes12">
<file-path>modes</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test apply-templates for PI with a mode and moded matching template.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes12.xml</input-file>
<input-file role="principal-stylesheet">modes12.xsl</input-file>
<output-file role="principal" compare="XML">modes12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes13">
<file-path>modes</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test apply-templates for any node() with a mode and moded matching template.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes13.xml</input-file>
<input-file role="principal-stylesheet">modes13.xsl</input-file>
<output-file role="principal" compare="XML">modes13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes14">
<file-path>modes</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test apply-templates for an attribute with a mode and moded matching template.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes14.xml</input-file>
<input-file role="principal-stylesheet">modes14.xsl</input-file>
<output-file role="principal" compare="XML">modes14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes15">
<file-path>modes</file-path>
<creator>Mingfei Peng (mfpeng@excite.com), altered by David Marston</creator>
<date>2001-11-08</date>
<purpose>Re-use nodes in different modes; templates have step-paths</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes15.xml</input-file>
<input-file role="principal-stylesheet">modes15.xsl</input-file>
<output-file role="principal" compare="XML">modes15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes16">
<file-path>modes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that qualified name of a mode is used in expanded form.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes16.xml</input-file>
<input-file role="principal-stylesheet">modes16.xsl</input-file>
<output-file role="principal" compare="XML">modes16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="modes_modes17">
<file-path>modes</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check that underscores are allowed in names.</purpose>
<spec-citation place="5.7" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">modes17.xml</input-file>
<input-file role="principal-stylesheet">modes17.xsl</input-file>
<output-file role="principal" compare="XML">modes17.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate01">
<file-path>namedtemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>General test for xsl:call-template.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate01.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate01.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate02">
<file-path>namedtemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:call-template of one that has both match and name.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate02.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate02.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate03">
<file-path>namedtemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for recursion of xsl:call-template.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate03.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate03.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate04">
<file-path>namedtemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Make sure qualified names work for named templates.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate04.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate04.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate05">
<file-path>namedtemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Call named template with non-qualified name, but with qualified name in scope.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate05.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate05.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate06">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Call named template that has priority and mode.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate06.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate06.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate07">
<file-path>namedtemplate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Tests the ability to reset and evaluate a parameter.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate07.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate07.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate08">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of nested template calls.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate08.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate08.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate09">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of nested template calls.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate09.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate09.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate10">
<file-path>namedtemplate</file-path>
<purpose>Test of simulated numerically-indexed for loop.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate10.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate10.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate11">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each inside xsl:with-param.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate11.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate11.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate12">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test use of passed-in value in an AVT. Derived from example code at end of 11.6</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate12.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate12.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate13">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that we can use the default parameter value on some calls</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate13.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate13.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate14">
<file-path>namedtemplate</file-path>
<purpose>Test select= on xsl:param inside named template</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate14.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate14.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate15">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test use of leading underscore in names.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate15.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate15.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate16">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Make sure qualified names match by expanded name.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate16.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate16.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate17">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test import precedence: both ntimpa and ntimpb have "show" template, b wins.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate17.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate17.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate18">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test import precedence: main stylesheet wins over imported one.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate18.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate18.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namedtemplate_namedtemplate19">
<file-path>namedtemplate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test import precedence: both ntimpa and ntimpc have "show" template, c wins.</purpose>
<spec-citation place="6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namedtemplate19.xml</input-file>
<input-file role="principal-stylesheet">namedtemplate19.xsl</input-file>
<output-file role="principal" compare="XML">namedtemplate19.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="namespace_namespace01">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Apply namespaces to attributes</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace01.xml</input-file>
<input-file role="principal-stylesheet">namespace01.xsl</input-file>
<output-file role="principal" compare="XML">namespace01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace02">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Basic test of applying namespaces to elements.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace02.xml</input-file>
<input-file role="principal-stylesheet">namespace02.xsl</input-file>
<output-file role="principal" compare="XML">namespace02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace03">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Adding an attribute to an element replaces any existing attribute of that element with the same expanded-name. For attribute L, there is only a local name. Attribute Q has a namespace.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace03.xml</input-file>
<input-file role="principal-stylesheet">namespace03.xsl</input-file>
<output-file role="principal" compare="XML">namespace03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace04">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test that default namespaces do not apply directly to attributes.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace04.xml</input-file>
<input-file role="principal-stylesheet">namespace04.xsl</input-file>
<output-file role="principal" compare="XML">namespace04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace06">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Stylesheets are free to use any prefix, provided there is a namespace declaration that binds the prefix to the URI of XSLT namespace.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace05.xml</input-file>
<input-file role="principal-stylesheet">namespace05.xsl</input-file>
<output-file role="principal" compare="XML">namespace05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace06">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Testing an attribute not from the XSLT namespace, which is legal provided that the expanded name of the attribute has a non-null namespace URI.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace06.xml</input-file>
<input-file role="principal-stylesheet">namespace06.xsl</input-file>
<output-file role="principal" compare="XML">namespace06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace07">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'local-name()' function on an element.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace07.xml</input-file>
<input-file role="principal-stylesheet">namespace07.xsl</input-file>
<output-file role="principal" compare="XML">namespace07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace08">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test name functions on non-namespaced attribute node.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace08.xml</input-file>
<input-file role="principal-stylesheet">namespace08.xsl</input-file>
<output-file role="principal" compare="XML">namespace08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace09">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'local-name()' function on attribute in non-default namespace.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace09.xml</input-file>
<input-file role="principal-stylesheet">namespace09.xsl</input-file>
<output-file role="principal" compare="XML">namespace09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace10">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'namespace-uri' function.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace10.xml</input-file>
<input-file role="principal-stylesheet">namespace10.xsl</input-file>
<output-file role="principal" compare="XML">namespace10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace11">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'namespace-uri()' function, with hyphenated node name.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace11.xml</input-file>
<input-file role="principal-stylesheet">namespace11.xsl</input-file>
<output-file role="principal" compare="XML">namespace11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace12">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'namespace-uri()' function on an element.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace12.xml</input-file>
<input-file role="principal-stylesheet">namespace12.xsl</input-file>
<output-file role="principal" compare="XML">namespace12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace14">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have more than one prefix bound to the URI of XSLT namespace.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace14.xml</input-file>
<input-file role="principal-stylesheet">namespace14.xsl</input-file>
<output-file role="principal" compare="XML">namespace14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace15">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Stylesheet elements may contain any element not from the XSLT namespace, provided that the expanded name of the element has a non-null namespace URI.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace15.xml</input-file>
<input-file role="principal-stylesheet">namespace15.xsl</input-file>
<output-file role="principal" compare="XML">namespace15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace16">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>XSLT processor must ignore a top-level element without giving and error if it does not recognize the namespace URI. The prefix used must still resolve to a URI; but that URI may not be known.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace16.xml</input-file>
<input-file role="principal-stylesheet">namespace16.xsl</input-file>
<output-file role="principal" compare="XML">namespace16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace17">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:exclude-result-prefixes, stylesheet level</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace17.xml</input-file>
<input-file role="principal-stylesheet">namespace17.xsl</input-file>
<output-file role="principal" compare="XML">namespace17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace18">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test exclude-result-prefixes, attribute level</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace18.xml</input-file>
<input-file role="principal-stylesheet">namespace18.xsl</input-file>
<output-file role="principal" compare="XML">namespace18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace19">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test basic functionality of namespace-alias. Where XSL elements are created by using Literal Result Elements. namespace24 is very similar, but it creates the axsl:stylesheet element via xsl:element.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace19.xml</input-file>
<input-file role="principal-stylesheet">namespace19.xsl</input-file>
<output-file role="principal" compare="XML">namespace19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace20">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test exclude-result-prefixes.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace20.xml</input-file>
<input-file role="principal-stylesheet">namespace20.xsl</input-file>
<output-file role="principal" compare="XML">namespace20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace21">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Match namespace between stylesheet, in a select, and input. Prefixes differ but the URIs are the same.</purpose>
<spec-citation place="Namespace" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace21.xml</input-file>
<input-file role="principal-stylesheet">namespace21.xsl</input-file>
<output-file role="principal" compare="XML">namespace21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace22">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Show how namespaces are inherited down to succeeding elements.</purpose>
<spec-citation place="7.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace22.xml</input-file>
<input-file role="principal-stylesheet">namespace22.xsl</input-file>
<output-file role="principal" compare="XML">namespace22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace23">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Testing an attribute not from the XSLT namespace, which is legal provided that the expanded name of the attribute has a non-null namespace URI. This tests for many xslt elements, apparent code path are different for numerous elements. Should actually output a "bogus" stylesheet.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace23.xml</input-file>
<input-file role="principal-stylesheet">namespace23.xsl</input-file>
<output-file role="principal" compare="XML">namespace23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace24">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test basic functionality of namespace-alias. Where XSL elements are created by using xsl:element command.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace24.xml</input-file>
<input-file role="principal-stylesheet">namespace24.xsl</input-file>
<output-file role="principal" compare="XML">namespace24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace25">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Simple case of creating LRE with nested namespace declarations.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace25.xml</input-file>
<input-file role="principal-stylesheet">namespace25.xsl</input-file>
<output-file role="principal" compare="XML">namespace25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace26">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of 'local-name()' with zero arguments.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace26.xml</input-file>
<input-file role="principal-stylesheet">namespace26.xsl</input-file>
<output-file role="principal" compare="XML">namespace26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace27">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of 'namespace-uri()' with no arguments.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace27.xml</input-file>
<input-file role="principal-stylesheet">namespace27.xsl</input-file>
<output-file role="principal" compare="XML">namespace27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace28">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of local-name and name() on namespace axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace28.xml</input-file>
<input-file role="principal-stylesheet">namespace28.xsl</input-file>
<output-file role="principal" compare="XML">namespace28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace29">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test name functions on processing instructions.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace29.xml</input-file>
<input-file role="principal-stylesheet">namespace29.xsl</input-file>
<output-file role="principal" compare="XML">namespace29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace30">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test name functions on comments.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace30.xml</input-file>
<input-file role="principal-stylesheet">namespace30.xsl</input-file>
<output-file role="principal" compare="XML">namespace30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace31">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test name functions on text nodes.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace31.xml</input-file>
<input-file role="principal-stylesheet">namespace31.xsl</input-file>
<output-file role="principal" compare="XML">namespace31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace32">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of local-name() on default namespace declaration.</purpose>
<spec-citation place="5.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace32.xml</input-file>
<input-file role="principal-stylesheet">namespace32.xsl</input-file>
<output-file role="principal" compare="XML">namespace32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace33">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of namespace-uri() on namespaces.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace33.xml</input-file>
<input-file role="principal-stylesheet">namespace33.xsl</input-file>
<output-file role="principal" compare="XML">namespace33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace34">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of namespace-uri() on default namespace declaration.</purpose>
<spec-citation place="5.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace34.xml</input-file>
<input-file role="principal-stylesheet">namespace34.xsl</input-file>
<output-file role="principal" compare="XML">namespace34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace35">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Get xmlns declaration attached to outermost LRE. Prefix "axsl" should also be literal.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace35.xml</input-file>
<input-file role="principal-stylesheet">namespace35.xsl</input-file>
<output-file role="principal" compare="XML">namespace35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace36">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of the unspecified default namespace by a contained xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace36.xml</input-file>
<input-file role="principal-stylesheet">namespace36.xsl</input-file>
<output-file role="principal" compare="XML">namespace36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace37">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of a specified default namespace.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace37.xml</input-file>
<input-file role="principal-stylesheet">namespace37.xsl</input-file>
<output-file role="principal" compare="XML">namespace37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace38">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of a specified default namespace by a LRE.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace38.xml</input-file>
<input-file role="principal-stylesheet">namespace38.xsl</input-file>
<output-file role="principal" compare="XML">namespace38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace39">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of a prefixed namespace by a LRE.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace39.xml</input-file>
<input-file role="principal-stylesheet">namespace39.xsl</input-file>
<output-file role="principal" compare="XML">namespace39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace40">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of a prefixed namespace by a LRE.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="element-name-not-QName"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">namespace40.xml</input-file>
<input-file role="principal-stylesheet">namespace40.xsl</input-file>
<output-file role="principal" compare="XML">namespace40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace41">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for specification of an empty namespace.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace41.xml</input-file>
<input-file role="principal-stylesheet">namespace41.xsl</input-file>
<output-file role="principal" compare="XML">namespace41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace42">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test to make sure xsl:attribute isn't added to the containing element when an xsl:element is ignored. Should see a warning that xyz:foo was not created. The &lt;yyy/&gt; element is placed directly within out, but the attribute isn't.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace42.xml</input-file>
<input-file role="principal-stylesheet">namespace42.xsl</input-file>
<output-file role="principal" compare="XML">namespace42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace43">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for non-empty illegal element name.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="element-name-not-QName"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">namespace43.xml</input-file>
<input-file role="principal-stylesheet">namespace43.xsl</input-file>
<output-file role="principal" compare="XML">namespace43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace44">
<file-path>namespace</file-path>
<creator>Philip Strube</creator>
<date>2001-11-08</date>
<purpose>Create attribute with QName and namespace which restates same URI.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace44.xml</input-file>
<input-file role="principal-stylesheet">namespace44.xsl</input-file>
<output-file role="principal" compare="XML">namespace44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace45">
<file-path>namespace</file-path>
<creator>Philip Strube</creator>
<date>2001-11-08</date>
<purpose>Create attribute with QName whose prefix is known.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace45.xml</input-file>
<input-file role="principal-stylesheet">namespace45.xsl</input-file>
<output-file role="principal" compare="XML">namespace45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace46">
<file-path>namespace</file-path>
<creator>Philip Strube</creator>
<date>2001-11-08</date>
<purpose>Create attribute with NCName and newly-introduced namespace.</purpose>
<spec-citation place="7.1.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace46.xml</input-file>
<input-file role="principal-stylesheet">namespace46.xsl</input-file>
<output-file role="principal" compare="XML">namespace46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace47">
<file-path>namespace</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of an unspecified default namespace by a LRE.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace47.xml</input-file>
<input-file role="principal-stylesheet">namespace47.xsl</input-file>
<output-file role="principal" compare="XML">namespace47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace48">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for error recovery when assigned name ends with : (has null local-part)</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<discretionary>
<discretionary-choice name="name" behavior="element-name-not-QName"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">namespace48.xml</input-file>
<input-file role="principal-stylesheet">namespace48.xsl</input-file>
<output-file role="principal" compare="XML">namespace48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace49">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Baseline test of xsl:element; stylesheet has namespace node.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace49.xml</input-file>
<input-file role="principal-stylesheet">namespace49.xsl</input-file>
<output-file role="principal" compare="XML">namespace49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace50">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace attribute; prefix known at stylesheet level.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace50.xml</input-file>
<input-file role="principal-stylesheet">namespace50.xsl</input-file>
<output-file role="principal" compare="XML">namespace50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace51">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace attribute, but namespace new at that point.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace51.xml</input-file>
<input-file role="principal-stylesheet">namespace51.xsl</input-file>
<output-file role="principal" compare="XML">namespace51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace52">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace in AVT, comes out as null string.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace52.xml</input-file>
<input-file role="principal-stylesheet">namespace52.xsl</input-file>
<output-file role="principal" compare="XML">namespace52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace53">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace that is AVT, URI matches one already in scope.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace53.xml</input-file>
<input-file role="principal-stylesheet">namespace53.xsl</input-file>
<output-file role="principal" compare="XML">namespace53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace54">
<file-path>namespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with a namespace that has AVT, introduces new namespace.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace54.xml</input-file>
<input-file role="principal-stylesheet">namespace54.xsl</input-file>
<output-file role="principal" compare="XML">namespace54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace55">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Prefixed xmlns declaration and same-prefixed name; namespace matches default set locally.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace55.xml</input-file>
<input-file role="principal-stylesheet">namespace55.xsl</input-file>
<output-file role="principal" compare="XML">namespace55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace56">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for namespace attribute not (previously) tied to prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace56.xml</input-file>
<input-file role="principal-stylesheet">namespace56.xsl</input-file>
<output-file role="principal" compare="XML">namespace56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace57">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test what happens when namespace attrib is a known URI, but no prefixes involved.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace57.xml</input-file>
<input-file role="principal-stylesheet">namespace57.xsl</input-file>
<output-file role="principal" compare="XML">namespace57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace58">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for namespace attribute matching stylesheet default.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace58.xml</input-file>
<input-file role="principal-stylesheet">namespace58.xsl</input-file>
<output-file role="principal" compare="XML">namespace58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace59">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for namespace attribute with new URI and prefix requested.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace59.xml</input-file>
<input-file role="principal-stylesheet">namespace59.xsl</input-file>
<output-file role="principal" compare="XML">namespace59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace60">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of a prefixed namespace by a LRE; stylesheet default NS set.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="element-name-not-QName"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">namespace60.xml</input-file>
<input-file role="principal-stylesheet">namespace60.xsl</input-file>
<output-file role="principal" compare="XML">namespace60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace61">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for specification of an empty namespace; stylesheet default NS set.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace61.xml</input-file>
<input-file role="principal-stylesheet">namespace61.xsl</input-file>
<output-file role="principal" compare="XML">namespace61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace62">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Two xmlns declarations with namespace attrib (matches default) in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace62.xml</input-file>
<input-file role="principal-stylesheet">namespace62.xsl</input-file>
<output-file role="principal" compare="XML">namespace62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace63">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Reset default locally, but namespace attribute matches stylesheet default.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace63.xml</input-file>
<input-file role="principal-stylesheet">namespace63.xsl</input-file>
<output-file role="principal" compare="XML">namespace63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace64">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for prefixed name when prefixed NS is in scope; no namespace attrib.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace64.xml</input-file>
<input-file role="principal-stylesheet">namespace64.xsl</input-file>
<output-file role="principal" compare="XML">namespace64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace65">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test resetting prefix and URI to what they were anyway.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace65.xml</input-file>
<input-file role="principal-stylesheet">namespace65.xsl</input-file>
<output-file role="principal" compare="XML">namespace65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace66">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test resetting of a prefix to same URI as known prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace66.xml</input-file>
<input-file role="principal-stylesheet">namespace66.xsl</input-file>
<output-file role="principal" compare="XML">namespace66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace67">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for prefixed name when prefixed NS is in scope; also set default for stylesheet.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace67.xml</input-file>
<input-file role="principal-stylesheet">namespace67.xsl</input-file>
<output-file role="principal" compare="XML">namespace67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace68">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set default namespace in outer, then specify namespace for inner; add prefixed decl.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace68.xml</input-file>
<input-file role="principal-stylesheet">namespace68.xsl</input-file>
<output-file role="principal" compare="XML">namespace68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace69">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed xmlns declaration with prefixed name; default was set.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace69.xml</input-file>
<input-file role="principal-stylesheet">namespace69.xsl</input-file>
<output-file role="principal" compare="XML">namespace69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace70">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>When there two prefixes for an NS URI, exclude-result-prefixes of one prefix excludes all for that URI.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace70.xml</input-file>
<input-file role="principal-stylesheet">namespace70.xsl</input-file>
<output-file role="principal" compare="XML">namespace70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace71">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Baseline case of an xmlns declaration in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace71.xml</input-file>
<input-file role="principal-stylesheet">namespace71.xsl</input-file>
<output-file role="principal" compare="XML">namespace71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace72">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Put both an unprefixed xmlns declaration and namespace attrib in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace72.xml</input-file>
<input-file role="principal-stylesheet">namespace72.xsl</input-file>
<output-file role="principal" compare="XML">namespace72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace73">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Put an unprefixed xmlns declaration in xsl:element where requested name has prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="element-name-not-QName"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">namespace73.xml</input-file>
<input-file role="principal-stylesheet">namespace73.xsl</input-file>
<output-file role="principal" compare="XML">namespace73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace74">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Put both an unprefixed xmlns declaration and namespace attrib in; name has prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace74.xml</input-file>
<input-file role="principal-stylesheet">namespace74.xsl</input-file>
<output-file role="principal" compare="XML">namespace74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace75">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Baseline case of a non-empty but unprefixed xmlns declaration in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace75.xml</input-file>
<input-file role="principal-stylesheet">namespace75.xsl</input-file>
<output-file role="principal" compare="XML">namespace75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace77">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Mix a non-empty xmlns declaration and namespace attrib (to same) in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace77.xml</input-file>
<input-file role="principal-stylesheet">namespace77.xsl</input-file>
<output-file role="principal" compare="XML">namespace77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace78">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Mix a non-empty xmlns declaration and namespace attrib (different URI) in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace78.xml</input-file>
<input-file role="principal-stylesheet">namespace78.xsl</input-file>
<output-file role="principal" compare="XML">namespace78.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace75">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have a non-empty but unprefixed xmlns declaration while specifying prefixed name.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="name" behavior="element-name-not-QName"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">namespace75.xml</input-file>
<input-file role="principal-stylesheet">namespace75.xsl</input-file>
<output-file role="principal" compare="XML">namespace75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace80">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Prefixed xmlns declaration and same-prefixed name; no namespace attrib; default set.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace80.xml</input-file>
<input-file role="principal-stylesheet">namespace80.xsl</input-file>
<output-file role="principal" compare="XML">namespace80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace81">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Mix xmlns declaration and namespace attrib (to same) in xsl:element; name has prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace81.xml</input-file>
<input-file role="principal-stylesheet">namespace81.xsl</input-file>
<output-file role="principal" compare="XML">namespace81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace82">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set xmlns declaration and namespace attrib to different URIs; name has prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace82.xml</input-file>
<input-file role="principal-stylesheet">namespace82.xsl</input-file>
<output-file role="principal" compare="XML">namespace82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace83">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed name; requested NS matches default rather than what's declared for that prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace83.xml</input-file>
<input-file role="principal-stylesheet">namespace83.xsl</input-file>
<output-file role="principal" compare="XML">namespace83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace84">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed name; requested NS matches default; another decl present.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace84.xml</input-file>
<input-file role="principal-stylesheet">namespace84.xsl</input-file>
<output-file role="principal" compare="XML">namespace84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace86">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test crossing prefix set locally with namespace from outer level (where it has other prefix).</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace86.xml</input-file>
<input-file role="principal-stylesheet">namespace86.xsl</input-file>
<output-file role="principal" compare="XML">namespace86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace87">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Mix xmlns declaration and namespace attrib (to same) in xsl:element; name has prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace87.xml</input-file>
<input-file role="principal-stylesheet">namespace87.xsl</input-file>
<output-file role="principal" compare="XML">namespace87.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace88">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace attribute and default reset; prefix known at stylesheet level.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace88.xml</input-file>
<input-file role="principal-stylesheet">namespace88.xsl</input-file>
<output-file role="principal" compare="XML">namespace88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace89">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that exclude-result-prefixes should NOT affect xsl:element (when prefix needed)</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace89.xml</input-file>
<input-file role="principal-stylesheet">namespace89.xsl</input-file>
<output-file role="principal" compare="XML">namespace89.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace90">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test crossing prefix set at outer level with URI also attached to different prefix in local decl.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace90.xml</input-file>
<input-file role="principal-stylesheet">namespace90.xsl</input-file>
<output-file role="principal" compare="XML">namespace90.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace91">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Baseline case of prefixed xmlns declaration in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace91.xml</input-file>
<input-file role="principal-stylesheet">namespace91.xsl</input-file>
<output-file role="principal" compare="XML">namespace91.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace92">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed xmlns declaration with null namespace attrib.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace92.xml</input-file>
<input-file role="principal-stylesheet">namespace92.xsl</input-file>
<output-file role="principal" compare="XML">namespace92.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace93">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed xmlns declaration with non-null namespace attrib, different URIs.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace93.xml</input-file>
<input-file role="principal-stylesheet">namespace93.xsl</input-file>
<output-file role="principal" compare="XML">namespace93.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace94">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed xmlns declaration with non-null namespace attrib, same URI.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace94.xml</input-file>
<input-file role="principal-stylesheet">namespace94.xsl</input-file>
<output-file role="principal" compare="XML">namespace94.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace95">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Prefixed xmlns declaration and same-prefixed name; no namespace attrib.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace95.xml</input-file>
<input-file role="principal-stylesheet">namespace95.xsl</input-file>
<output-file role="principal" compare="XML">namespace95.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace96">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Issue prefixed name in current default namespace, rather than the one assigned to tha prefix at outer level</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace96.xml</input-file>
<input-file role="principal-stylesheet">namespace96.xsl</input-file>
<output-file role="principal" compare="XML">namespace96.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace97">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for prefixed name when prefixed NS is in scope; also set default locally.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace97.xml</input-file>
<input-file role="principal-stylesheet">namespace97.xsl</input-file>
<output-file role="principal" compare="XML">namespace97.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace98">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed xmlns declaration with non-null namespace attrib, same URI and prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace98.xml</input-file>
<input-file role="principal-stylesheet">namespace98.xsl</input-file>
<output-file role="principal" compare="XML">namespace98.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace99">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed xmlns declaration, namespace attrib sets different URI of that prefix.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace99.xml</input-file>
<input-file role="principal-stylesheet">namespace99.xsl</input-file>
<output-file role="principal" compare="XML">namespace99.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace100">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use prefixed xmlns declaration, namespace attrib to same URI, different prefix on name.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace100.xml</input-file>
<input-file role="principal-stylesheet">namespace100.xsl</input-file>
<output-file role="principal" compare="XML">namespace100.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace101">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use "plain" xsl:element while both default and prefixed NS defined at top.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace101.xml</input-file>
<input-file role="principal-stylesheet">namespace101.xsl</input-file>
<output-file role="principal" compare="XML">namespace101.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace102">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set default namespace, then reset via xmlns declaration in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace102.xml</input-file>
<input-file role="principal-stylesheet">namespace102.xsl</input-file>
<output-file role="principal" compare="XML">namespace102.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace103">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set default namespace, then set differently in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace103.xml</input-file>
<input-file role="principal-stylesheet">namespace103.xsl</input-file>
<output-file role="principal" compare="XML">namespace103.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace104">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Specify an empty namespace; stylesheet default NS set, and reset in xsl:element.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace104.xml</input-file>
<input-file role="principal-stylesheet">namespace104.xsl</input-file>
<output-file role="principal" compare="XML">namespace104.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace105">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Specify an empty namespace; default NS set at two levels.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace105.xml</input-file>
<input-file role="principal-stylesheet">namespace105.xsl</input-file>
<output-file role="principal" compare="XML">namespace105.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace106">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test recovery when assigned name begins with : (has null namespace)</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace106.xml</input-file>
<input-file role="principal-stylesheet">namespace106.xsl</input-file>
<output-file role="principal" compare="XML">namespace106.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace107">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace attribute; prefix known at stylesheet level; default set.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace107.xml</input-file>
<input-file role="principal-stylesheet">namespace107.xsl</input-file>
<output-file role="principal" compare="XML">namespace107.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace108">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace attribute that matches default; another in scope.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace108.xml</input-file>
<input-file role="principal-stylesheet">namespace108.xsl</input-file>
<output-file role="principal" compare="XML">namespace108.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace109">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use namespace attribute, but namespace new at that point; default was set.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace109.xml</input-file>
<input-file role="principal-stylesheet">namespace109.xsl</input-file>
<output-file role="principal" compare="XML">namespace109.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace110">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for invalid namespace URI; spec says "not syntactically legal URI" is NOT error.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace110.xml</input-file>
<input-file role="principal-stylesheet">namespace110.xsl</input-file>
<output-file role="principal" compare="XML">namespace110.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace111">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set and reset default namespace, no prefixes involved.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace111.xml</input-file>
<input-file role="principal-stylesheet">namespace111.xsl</input-file>
<output-file role="principal" compare="XML">namespace111.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace112">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set default namespace at two levels, no prefixes involved.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace112.xml</input-file>
<input-file role="principal-stylesheet">namespace112.xsl</input-file>
<output-file role="principal" compare="XML">namespace112.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace113">
<file-path>namespace</file-path>
<creator>Gary L Peskin, based on test case from Jens Lautenbacher</creator>
<date>2001-11-08</date>
<purpose>Verify that namespace-alias is honored in included stylesheets.</purpose>
<spec-citation place="7.1.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace113.xml</input-file>
<input-file role="principal-stylesheet">namespace113.xsl</input-file>
<output-file role="principal" compare="XML">namespace113.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace115">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use xsl:element with namespace attribute and default changed; prefix known at stylesheet level.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace115.xml</input-file>
<input-file role="principal-stylesheet">namespace115.xsl</input-file>
<output-file role="principal" compare="XML">namespace115.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace116">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to put un-namespaced attribute on namespaced element.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace116.xml</input-file>
<input-file role="principal-stylesheet">namespace116.xsl</input-file>
<output-file role="principal" compare="XML">namespace116.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace117">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Create prefixed attribute with namespace requested via attribute.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace117.xml</input-file>
<input-file role="principal-stylesheet">namespace117.xsl</input-file>
<output-file role="principal" compare="XML">namespace117.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace119">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Put namespace attribute on xsl:attribute, but set it to null (which it would have been anyway).</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace119.xml</input-file>
<input-file role="principal-stylesheet">namespace119.xsl</input-file>
<output-file role="principal" compare="XML">namespace119.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace120">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set a prefixed name to an NS not among those in scope; prefix was in use.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace120.xml</input-file>
<input-file role="principal-stylesheet">namespace120.xsl</input-file>
<output-file role="principal" compare="XML">namespace120.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace121">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Reset prefix from innermost URI to outer (default) one.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace121.xml</input-file>
<input-file role="principal-stylesheet">namespace121.xsl</input-file>
<output-file role="principal" compare="XML">namespace121.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace122">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Request prefix that is already mapped to requested NS, default set globally.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace122.xml</input-file>
<input-file role="principal-stylesheet">namespace122.xsl</input-file>
<output-file role="principal" compare="XML">namespace122.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace123">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set a prefixed name to same NS as outer default, prefix is new.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace123.xml</input-file>
<input-file role="principal-stylesheet">namespace123.xsl</input-file>
<output-file role="principal" compare="XML">namespace123.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace124">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set a prefixed name to same NS as other prefix already had, prefix is new.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace124.xml</input-file>
<input-file role="principal-stylesheet">namespace124.xsl</input-file>
<output-file role="principal" compare="XML">namespace124.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace125">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>See what happens to attribute when default namespace is declared.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace125.xml</input-file>
<input-file role="principal-stylesheet">namespace125.xsl</input-file>
<output-file role="principal" compare="XML">namespace125.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace126">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have default namespace declared, request attribute in null namespace.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace126.xml</input-file>
<input-file role="principal-stylesheet">namespace126.xsl</input-file>
<output-file role="principal" compare="XML">namespace126.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace127">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have default namespace declared, request attribute in namespace different from default. No prefix on attribute name. Processor must create a prefix.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace127.xml</input-file>
<input-file role="principal-stylesheet">namespace127.xsl</input-file>
<output-file role="principal" compare="XML">namespace127.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace128">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have default namespace declared, request attribute in namespace same as default. No prefix on attribute name. Processor must create a prefix.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace128.xml</input-file>
<input-file role="principal-stylesheet">namespace128.xsl</input-file>
<output-file role="principal" compare="XML">namespace128.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace130">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have default namespace declared, request attribute in namespace same as default. New prefix on attribute name. Processor must create a prefix.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace130.xml</input-file>
<input-file role="principal-stylesheet">namespace130.xsl</input-file>
<output-file role="principal" compare="XML">namespace130.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace131">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have default namespace declared, request attribute in namespace different from default. New prefix on attribute name. Processor must create a prefix.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace131.xml</input-file>
<input-file role="principal-stylesheet">namespace131.xsl</input-file>
<output-file role="principal" compare="XML">namespace131.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace132">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Declare prefixed namespace at stylesheet level, then use prefix in attribute name only. No namespace nor xmlns on xsl:attribute itself.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace132.xml</input-file>
<input-file role="principal-stylesheet">namespace132.xsl</input-file>
<output-file role="principal" compare="XML">namespace132.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace134">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Declare prefixed namespace at stylesheet level, then use another prefix in attribute name, but same namespace. New namespace-decl must be issued, or change prefix.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace134.xml</input-file>
<input-file role="principal-stylesheet">namespace134.xsl</input-file>
<output-file role="principal" compare="XML">namespace134.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace137">
<file-path>namespace</file-path>
<creator>Santiago Pericas-Geertsen</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of an unspecified default namespace by copy-of.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace137.xml</input-file>
<input-file role="principal-stylesheet">namespace137.xsl</input-file>
<output-file role="principal" compare="XML">namespace137.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace138">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of a namespace prefix by copy-of.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace138.xml</input-file>
<input-file role="principal-stylesheet">namespace138.xsl</input-file>
<output-file role="principal" compare="XML">namespace138.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace139">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test copying of a namespace node by copy-of.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace139.xml</input-file>
<input-file role="principal-stylesheet">namespace139.xsl</input-file>
<output-file role="principal" compare="XML">namespace139.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace140">
<file-path>namespace</file-path>
<creator>Santiago Pericas-Geertsen</creator>
<date>2001-11-08</date>
<purpose>Check for AVT on element name when xsl:element has namespace attribute.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace140.xml</input-file>
<input-file role="principal-stylesheet">namespace140.xsl</input-file>
<output-file role="principal" compare="XML">namespace140.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace141">
<file-path>namespace</file-path>
<creator>Gordon Chiu</creator>
<date>2001-11-08</date>
<purpose>Test for resetting of an unspecified default namespace by copy-of.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">namespace141.xml</input-file>
<input-file role="principal-stylesheet">namespace141.xsl</input-file>
<output-file role="principal" compare="XML">namespace141.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="namespace_namespace142">
<file-path>namespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test name functions on default-namespace declaration. Should be null strings.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">namespace142.xml</input-file>
<input-file role="principal-stylesheet">namespace142.xsl</input-file>
<output-file role="principal" compare="XML">namespace142.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="node_node01">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for text() node test.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node01.xml</input-file>
<input-file role="principal-stylesheet">node01.xsl</input-file>
<output-file role="principal" compare="XML">node01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node02">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for comment() node test.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node02.xml</input-file>
<input-file role="principal-stylesheet">node02.xsl</input-file>
<output-file role="principal" compare="XML">node02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node03">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for processing-instruction() node test.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node03.xml</input-file>
<input-file role="principal-stylesheet">node03.xsl</input-file>
<output-file role="principal" compare="XML">node03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node04">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'local-name()'</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node04.xml</input-file>
<input-file role="principal-stylesheet">node04.xsl</input-file>
<output-file role="principal" compare="XML">node04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node05">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'namespace-uri()'</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node05.xml</input-file>
<input-file role="principal-stylesheet">node05.xsl</input-file>
<output-file role="principal" compare="XML">node05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node06">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of 'name()', without arguments</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node06.xml</input-file>
<input-file role="principal-stylesheet">node06.xsl</input-file>
<output-file role="principal" compare="XML">node06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node07">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Processing Instructions and comments within a stylesheet are ignored.</purpose>
<spec-citation place="3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node07.xml</input-file>
<input-file role="principal-stylesheet">node07.xsl</input-file>
<output-file role="principal" compare="XML">node07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node08">
<file-path>node</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>String value of the root node is the concatenation of the string values of all text node descendants of the root node in document order.</purpose>
<spec-citation place="5.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node08.xml</input-file>
<input-file role="principal-stylesheet">node08.xsl</input-file>
<output-file role="principal" compare="XML">node08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node09">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for value-of with comment() node test.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node09.xml</input-file>
<input-file role="principal-stylesheet">node09.xsl</input-file>
<output-file role="principal" compare="XML">node09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node10">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for value-of with processing-instruction() node test.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node10.xml</input-file>
<input-file role="principal-stylesheet">node10.xsl</input-file>
<output-file role="principal" compare="XML">node10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node11">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for node tests in match patterns (and union in select).</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node11.xml</input-file>
<input-file role="principal-stylesheet">node11.xsl</input-file>
<output-file role="principal" compare="XML">node11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node12">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for node tests in select in for-each.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node12.xml</input-file>
<input-file role="principal-stylesheet">node12.xsl</input-file>
<output-file role="principal" compare="XML">node12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node13">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for access to comments hanging off the root.</purpose>
<spec-citation place="5.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node13.xml</input-file>
<input-file role="principal-stylesheet">node13.xsl</input-file>
<output-file role="principal" compare="XML">node13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node14">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for access to PIs hanging off the root.</purpose>
<spec-citation place="5.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node14.xml</input-file>
<input-file role="principal-stylesheet">node14.xsl</input-file>
<output-file role="principal" compare="XML">node14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node15">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for node() in match patterns. Default axis is child.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node15.xml</input-file>
<input-file role="principal-stylesheet">node15.xsl</input-file>
<output-file role="principal" compare="XML">node15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node16">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'attribute::*' in match pattern.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node16.xml</input-file>
<input-file role="principal-stylesheet">node16.xsl</input-file>
<output-file role="principal" compare="XML">node16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node17">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that 'namespace::node()' selects all namespaces.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node17.xml</input-file>
<input-file role="principal-stylesheet">node17.xsl</input-file>
<output-file role="principal" compare="XML">node17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node18">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for node test in argument to count() function.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node18.xml</input-file>
<input-file role="principal-stylesheet">node18.xsl</input-file>
<output-file role="principal" compare="XML">node18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node19">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'attribute::node()' in match pattern.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node19.xml</input-file>
<input-file role="principal-stylesheet">node19.xsl</input-file>
<output-file role="principal" compare="XML">node19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node20">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'parent::node()' in select.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node20.xml</input-file>
<input-file role="principal-stylesheet">node20.xsl</input-file>
<output-file role="principal" compare="XML">node20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="node_node21">
<file-path>node</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for 'ancestor::node()' in select.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">node21.xml</input-file>
<input-file role="principal-stylesheet">node21.xsl</input-file>
<output-file role="principal" compare="XML">node21.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="numberformat_numberformat01">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number with 2 arguments, showing zeroes.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat01.xml</input-file>
<input-file role="principal-stylesheet">numberformat01.xsl</input-file>
<output-file role="principal" compare="XML">numberformat01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat02">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number and # and 0 in format string.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat02.xml</input-file>
<input-file role="principal-stylesheet">numberformat02.xsl</input-file>
<output-file role="principal" compare="XML">numberformat02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat03">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number on a negative number.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat03.xml</input-file>
<input-file role="principal-stylesheet">numberformat03.xsl</input-file>
<output-file role="principal" compare="XML">numberformat03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat04">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number on a negative number; should choose second pattern.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat04.xml</input-file>
<input-file role="principal-stylesheet">numberformat04.xsl</input-file>
<output-file role="principal" compare="XML">numberformat04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat05">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number percentage format.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat05.xml</input-file>
<input-file role="principal-stylesheet">numberformat05.xsl</input-file>
<output-file role="principal" compare="XML">numberformat05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat06">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number per-mille format.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat06.xml</input-file>
<input-file role="principal-stylesheet">numberformat06.xsl</input-file>
<output-file role="principal" compare="XML">numberformat06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat07">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number currency symbol, which is not supposed to be there.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat07.xml</input-file>
<input-file role="principal-stylesheet">numberformat07.xsl</input-file>
<output-file role="principal" compare="XML">numberformat07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat08">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number with prefix and suffix in format string.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat08.xml</input-file>
<input-file role="principal-stylesheet">numberformat08.xsl</input-file>
<output-file role="principal" compare="XML">numberformat08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat09">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test default decimal-format on separator characters, changing both.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat09.xml</input-file>
<input-file role="principal-stylesheet">numberformat09.xsl</input-file>
<output-file role="principal" compare="XML">numberformat09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat11">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test default decimal-format on pattern-only characters, positive number.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat11.xml</input-file>
<input-file role="principal-stylesheet">numberformat11.xsl</input-file>
<output-file role="principal" compare="XML">numberformat11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat12">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test default decimal-format on pattern-only characters, negative number.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat12.xml</input-file>
<input-file role="principal-stylesheet">numberformat12.xsl</input-file>
<output-file role="principal" compare="XML">numberformat12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat13">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test default decimal-format on pattern-only characters, negative number and one pattern.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat13.xml</input-file>
<input-file role="principal-stylesheet">numberformat13.xsl</input-file>
<output-file role="principal" compare="XML">numberformat13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat14">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test specified result pattern for infinity.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat14.xml</input-file>
<input-file role="principal-stylesheet">numberformat14.xsl</input-file>
<output-file role="principal" compare="XML">numberformat14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat15">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test specified result pattern for not-a-number.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat15.xml</input-file>
<input-file role="principal-stylesheet">numberformat15.xsl</input-file>
<output-file role="principal" compare="XML">numberformat15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat16">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of decimal-format per-mille format with character being changed.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat16.xml</input-file>
<input-file role="principal-stylesheet">numberformat16.xsl</input-file>
<output-file role="principal" compare="XML">numberformat16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat17">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test decimal-format output character for negative, 2 patterns.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat17.xml</input-file>
<input-file role="principal-stylesheet">numberformat17.xsl</input-file>
<output-file role="principal" compare="XML">numberformat17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat18">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test decimal-format output character for negative, one pattern.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat18.xml</input-file>
<input-file role="principal-stylesheet">numberformat18.xsl</input-file>
<output-file role="principal" compare="XML">numberformat18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat19">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test decimal-format declaration with a name.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat19.xml</input-file>
<input-file role="principal-stylesheet">numberformat19.xsl</input-file>
<output-file role="principal" compare="XML">numberformat19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat20">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of decimal-format with qualified name. Unqualified name provided as a trap.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat20.xml</input-file>
<input-file role="principal-stylesheet">numberformat20.xsl</input-file>
<output-file role="principal" compare="XML">numberformat20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat21">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test include of a decimal-format.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat21.xml</input-file>
<input-file role="principal-stylesheet">numberformat21.xsl</input-file>
<output-file role="principal" compare="XML">numberformat21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat22">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test import of a decimal-format. Three formats should not conflict.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat22.xml</input-file>
<input-file role="principal-stylesheet">numberformat22.xsl</input-file>
<output-file role="principal" compare="XML">numberformat22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat23">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of include that does an import, providing two named decimal-formats. Three formats should not conflict.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat23.xml</input-file>
<input-file role="principal-stylesheet">numberformat23.xsl</input-file>
<output-file role="principal" compare="XML">numberformat23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat24">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of import that does an import, providing two named decimal-formats. Three formats should not conflict.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat24.xml</input-file>
<input-file role="principal-stylesheet">numberformat24.xsl</input-file>
<output-file role="principal" compare="XML">numberformat24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat25">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Create a conflict in the use of the '.' character.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat25.xml</input-file>
<input-file role="principal-stylesheet">numberformat25.xsl</input-file>
<output-file role="principal" compare="XML">numberformat25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat26">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Designate a space as the grouping separator.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat26.xml</input-file>
<input-file role="principal-stylesheet">numberformat26.xsl</input-file>
<output-file role="principal" compare="XML">numberformat26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat27">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number minus-sign behavior on positive numbers.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat27.xml</input-file>
<input-file role="principal-stylesheet">numberformat27.xsl</input-file>
<output-file role="principal" compare="XML">numberformat27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat28">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test what happens to minus sign embedded in second pattern.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat28.xml</input-file>
<input-file role="principal-stylesheet">numberformat28.xsl</input-file>
<output-file role="principal" compare="XML">numberformat28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat29">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test decimal-format output character does not influence input.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat29.xml</input-file>
<input-file role="principal-stylesheet">numberformat29.xsl</input-file>
<output-file role="principal" compare="XML">numberformat29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat30">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test effects of minus-sign in one pattern.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat30.xml</input-file>
<input-file role="principal-stylesheet">numberformat30.xsl</input-file>
<output-file role="principal" compare="XML">numberformat30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat31">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test output of altered minus, 2 patterns but no sign marker in pattern.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat31.xml</input-file>
<input-file role="principal-stylesheet">numberformat31.xsl</input-file>
<output-file role="principal" compare="XML">numberformat31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat32">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format-number percent format with character being changed.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat32.xml</input-file>
<input-file role="principal-stylesheet">numberformat32.xsl</input-file>
<output-file role="principal" compare="XML">numberformat32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat34">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test changing both digit and zero-digit in format string.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat34.xml</input-file>
<input-file role="principal-stylesheet">numberformat34.xsl</input-file>
<output-file role="principal" compare="XML">numberformat34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat35">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of unequal spacing of grouping-separator.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat35.xml</input-file>
<input-file role="principal-stylesheet">numberformat35.xsl</input-file>
<output-file role="principal" compare="XML">numberformat35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat36">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test what happens when we overflow available digits on the left.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat36.xml</input-file>
<input-file role="principal-stylesheet">numberformat36.xsl</input-file>
<output-file role="principal" compare="XML">numberformat36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat37">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test result pattern for infinity, unchanged.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat37.xml</input-file>
<input-file role="principal-stylesheet">numberformat37.xsl</input-file>
<output-file role="principal" compare="XML">numberformat37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat38">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test result pattern for not-a-number, unchanged.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat38.xml</input-file>
<input-file role="principal-stylesheet">numberformat38.xsl</input-file>
<output-file role="principal" compare="XML">numberformat38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat39">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test result pattern for negative infinity, unchanged.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat39.xml</input-file>
<input-file role="principal-stylesheet">numberformat39.xsl</input-file>
<output-file role="principal" compare="XML">numberformat39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat40">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test specification of result pattern for infinity when quantity to be displayed is negative infinity.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat40.xml</input-file>
<input-file role="principal-stylesheet">numberformat40.xsl</input-file>
<output-file role="principal" compare="XML">numberformat40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat41">
<file-path>numberformat</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Test of multiple decimal-format elements with identical qualified names. This is allowed as long as all attributes are identical (including defaults).</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat41.xml</input-file>
<input-file role="principal-stylesheet">numberformat41.xsl</input-file>
<output-file role="principal" compare="XML">numberformat41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat42">
<file-path>numberformat</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Test of multiple decimal-format elements with identical names. This is allowed as long as all attributes are identical (including defaults).</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat42.xml</input-file>
<input-file role="principal-stylesheet">numberformat42.xsl</input-file>
<output-file role="principal" compare="XML">numberformat42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat43">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Have two decimal-format elements with identical names, one in an import. This is allowed as long as all attributes are identical (including defaults).</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat43.xml</input-file>
<input-file role="principal-stylesheet">numberformat43.xsl</input-file>
<output-file role="principal" compare="XML">numberformat43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat44">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test whether a decimal-format declaration in an import is visible here.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat44.xml</input-file>
<input-file role="principal-stylesheet">numberformat44.xsl</input-file>
<output-file role="principal" compare="XML">numberformat44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat45">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test whether a default decimal-format defined in an import is applied here.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat45.xml</input-file>
<input-file role="principal-stylesheet">numberformat45.xsl</input-file>
<output-file role="principal" compare="XML">numberformat45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numberformat_numberformat46">
<file-path>numberformat</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test whether a default decimal-format defined in an include is applied here.</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">numberformat46.xml</input-file>
<input-file role="principal-stylesheet">numberformat46.xsl</input-file>
<output-file role="principal" compare="XML">numberformat46.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="numbering_numbering01">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document with no attributes specified.</purpose>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(number)"/>
<scenario operation="standard">
<input-file role="principal-data">numbering01.xml</input-file>
<input-file role="principal-stylesheet">numbering01.xsl</input-file>
<output-file role="principal" compare="XML">numbering01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering02">
<file-path>numbering</file-path>
<creator>Paul Dick, based on example in spec</creator>
<date>2001-11-08</date>
<purpose>Test of simple numbering, no attributes specified.</purpose>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(number)"/>
<scenario operation="standard">
<input-file role="principal-data">numbering02.xml</input-file>
<input-file role="principal-stylesheet">numbering02.xsl</input-file>
<output-file role="principal" compare="XML">numbering02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering03">
<file-path>numbering</file-path>
<creator>Paul Dick, based on example in spec</creator>
<date>2001-11-08</date>
<purpose>Test of level (multiple), count, format attributes.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering03.xml</input-file>
<input-file role="principal-stylesheet">numbering03.xsl</input-file>
<output-file role="principal" compare="XML">numbering03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering04">
<file-path>numbering</file-path>
<creator>Paul Dick, based on example in spec</creator>
<date>2001-11-08</date>
<purpose>Test of level (any) and from attributes.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering04.xml</input-file>
<input-file role="principal-stylesheet">numbering04.xsl</input-file>
<output-file role="principal" compare="XML">numbering04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering05">
<file-path>numbering</file-path>
<creator>Paul Dick, based on example in spec</creator>
<date>2001-11-08</date>
<purpose>Test of level (any) and nested from/count.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering05.xml</input-file>
<input-file role="principal-stylesheet">numbering05.xsl</input-file>
<output-file role="principal" compare="XML">numbering05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering06">
<file-path>numbering</file-path>
<creator>Paul Dick, based on example in spec</creator>
<date>2001-11-08</date>
<purpose>Test level=single specified explicitly</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering06.xml</input-file>
<input-file role="principal-stylesheet">numbering06.xsl</input-file>
<output-file role="principal" compare="XML">numbering06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering07">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Simple test of non-alphanumeric separator</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering07.xml</input-file>
<input-file role="principal-stylesheet">numbering07.xsl</input-file>
<output-file role="principal" compare="XML">numbering07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering08">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of leading zeroes in numbering. Last separator propagates.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[4]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering08.xml</input-file>
<input-file role="principal-stylesheet">numbering08.xsl</input-file>
<output-file role="principal" compare="XML">numbering08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering09">
<file-path>numbering</file-path>
<creator>David Marston, based on example in spec</creator>
<date>2001-11-08</date>
<purpose>Test of value attribute.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering09.xml</input-file>
<input-file role="principal-stylesheet">numbering09.xsl</input-file>
<output-file role="principal" compare="XML">numbering09.out</output-file>
</scenario>
</test-case>
<!--

Different Roman number "40" handling.

<test-case category="XSLT-Result-Tree" id="numbering_numbering10">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of format attributes that vary per level.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[4]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[5]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering10.xml</input-file>
<input-file role="principal-stylesheet">numbering10.xsl</input-file>
<output-file role="principal" compare="XML">numbering10.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="numbering_numbering11">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of grouping attributes.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[2]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering11.xml</input-file>
<input-file role="principal-stylesheet">numbering11.xsl</input-file>
<output-file role="principal" compare="XML">numbering11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering12">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of alphabetic "numbering" sequence.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering12.xml</input-file>
<input-file role="principal-stylesheet">numbering12.xsl</input-file>
<output-file role="principal" compare="XML">numbering12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering13">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of roman-numeral "numbering" sequence.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[5]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering13.xml</input-file>
<input-file role="principal-stylesheet">numbering13.xsl</input-file>
<output-file role="principal" compare="XML">numbering13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering14">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of greek-numeral "alphabetic" sequence.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[6]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[5]/text()[5]"/>
<discretionary>
<discretionary-choice name="number-greek-alpha" behavior="true"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">numbering14.xml</input-file>
<input-file role="principal-stylesheet">numbering14.xsl</input-file>
<output-file role="principal" compare="HTML">numbering14.out</output-file>
</scenario>
</test-case>
<!--

Different Roman number 40,400,4000 handling.

<test-case category="XSLT-Result-Tree" id="numbering_numbering17">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of proper formation of Roman numerals.</purpose>
<spec-citation spec="XSLT" version="1.0" type="ERROR!" place=""/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[5]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering17.xml</input-file>
<input-file role="principal-stylesheet">numbering17.xsl</input-file>
<output-file role="principal" compare="XML">numbering17.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="numbering_numbering18">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of node numbering before and after the nodes specified in from.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering18.xml</input-file>
<input-file role="principal-stylesheet">numbering18.xsl</input-file>
<output-file role="principal" compare="XML">numbering18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering19">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of node numbering before and after the nodes specified in from.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering19.xml</input-file>
<input-file role="principal-stylesheet">numbering19.xsl</input-file>
<output-file role="principal" compare="XML">numbering19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering20">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of node numbering before and after the nodes specified in from.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering20.xml</input-file>
<input-file role="principal-stylesheet">numbering20.xsl</input-file>
<output-file role="principal" compare="XML">numbering20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering21">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (any) and counting only some nodes.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering21.xml</input-file>
<input-file role="principal-stylesheet">numbering21.xsl</input-file>
<output-file role="principal" compare="XML">numbering21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering22">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (single) and counting only some nodes.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering22.xml</input-file>
<input-file role="principal-stylesheet">numbering22.xsl</input-file>
<output-file role="principal" compare="XML">numbering22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering23">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of value attribute with popular "of n" format.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[4]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering23.xml</input-file>
<input-file role="principal-stylesheet">numbering23.xsl</input-file>
<output-file role="principal" compare="XML">numbering23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering24">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Number without value= inside sorted for-each.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[2]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(for-each)"/>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(sorting)"/>
<scenario operation="standard">
<input-file role="principal-data">numbering24.xml</input-file>
<input-file role="principal-stylesheet">numbering24.xsl</input-file>
<output-file role="principal" compare="XML">numbering24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering25">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Number without value= inside template called within sorted for-each.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[2]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(for-each)"/>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(sorting)"/>
<scenario operation="standard">
<input-file role="principal-data">numbering25.xml</input-file>
<input-file role="principal-stylesheet">numbering25.xsl</input-file>
<output-file role="principal" compare="XML">numbering25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering26">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Numbering comes from sorted order if value attribute used.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(for-each)"/>
<spec-citation spec="XSLT" version="1.0" type="anchor" place="id(sorting)"/>
<scenario operation="standard">
<input-file role="principal-data">numbering26.xml</input-file>
<input-file role="principal-stylesheet">numbering26.xsl</input-file>
<output-file role="principal" compare="XML">numbering26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering27">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document, level=multiple and default from.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering27.xml</input-file>
<input-file role="principal-stylesheet">numbering27.xsl</input-file>
<output-file role="principal" compare="XML">numbering27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering28">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document, level=single and default from.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering28.xml</input-file>
<input-file role="principal-stylesheet">numbering28.xsl</input-file>
<output-file role="principal" compare="XML">numbering28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering29">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document, level=any and default from.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering29.xml</input-file>
<input-file role="principal-stylesheet">numbering29.xsl</input-file>
<output-file role="principal" compare="XML">numbering29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering30">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering30.xml</input-file>
<input-file role="principal-stylesheet">numbering30.xsl</input-file>
<output-file role="principal" compare="XML">numbering30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering31">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering31.xml</input-file>
<input-file role="principal-stylesheet">numbering31.xsl</input-file>
<output-file role="principal" compare="XML">numbering31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering32">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one, watching for confusion with default (.) separator.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[9]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[3]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering32.xml</input-file>
<input-file role="principal-stylesheet">numbering32.xsl</input-file>
<output-file role="principal" compare="XML">numbering32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering33">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering33.xml</input-file>
<input-file role="principal-stylesheet">numbering33.xsl</input-file>
<output-file role="principal" compare="XML">numbering33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering34">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one, with default (.) elsewhere in format.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[9]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[3]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering34.xml</input-file>
<input-file role="principal-stylesheet">numbering34.xsl</input-file>
<output-file role="principal" compare="XML">numbering34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering35">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering35.xml</input-file>
<input-file role="principal-stylesheet">numbering35.xsl</input-file>
<output-file role="principal" compare="XML">numbering35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering36">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering36.xml</input-file>
<input-file role="principal-stylesheet">numbering36.xsl</input-file>
<output-file role="principal" compare="XML">numbering36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering37">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, with extra characters that look the same.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering37.xml</input-file>
<input-file role="principal-stylesheet">numbering37.xsl</input-file>
<output-file role="principal" compare="XML">numbering37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering38">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, with extra characters that look the same.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[5]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering38.xml</input-file>
<input-file role="principal-stylesheet">numbering38.xsl</input-file>
<output-file role="principal" compare="XML">numbering38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering39">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one, with extra characters that look the same.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering39.xml</input-file>
<input-file role="principal-stylesheet">numbering39.xsl</input-file>
<output-file role="principal" compare="XML">numbering39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering40">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[9]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering40.xml</input-file>
<input-file role="principal-stylesheet">numbering40.xsl</input-file>
<output-file role="principal" compare="XML">numbering40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering41">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one (which is the last one between).</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[3]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering41.xml</input-file>
<input-file role="principal-stylesheet">numbering41.xsl</input-file>
<output-file role="principal" compare="XML">numbering41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering42">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering42.xml</input-file>
<input-file role="principal-stylesheet">numbering42.xsl</input-file>
<output-file role="principal" compare="XML">numbering42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering43">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering43.xml</input-file>
<input-file role="principal-stylesheet">numbering43.xsl</input-file>
<output-file role="principal" compare="XML">numbering43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering44">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, propagating last one.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering44.xml</input-file>
<input-file role="principal-stylesheet">numbering44.xsl</input-file>
<output-file role="principal" compare="XML">numbering44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering45">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test more than one xsl:number counter active at the same time.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering45.xml</input-file>
<input-file role="principal-stylesheet">numbering45.xsl</input-file>
<output-file role="principal" compare="XML">numbering45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering46">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number formatting separators, with multiple characters in between numbering tokens.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering46.xml</input-file>
<input-file role="principal-stylesheet">numbering46.xsl</input-file>
<output-file role="principal" compare="XML">numbering46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering47">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Establish that the default for level is single.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering47.xml</input-file>
<input-file role="principal-stylesheet">numbering47.xsl</input-file>
<output-file role="principal" compare="XML">numbering47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering48">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Count only top-level changes but number all the way down, level=single.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering48.xml</input-file>
<input-file role="principal-stylesheet">numbering48.xsl</input-file>
<output-file role="principal" compare="XML">numbering48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering49">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Count only bottom-level changes but number all the way down, level=any.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering49.xml</input-file>
<input-file role="principal-stylesheet">numbering49.xsl</input-file>
<output-file role="principal" compare="XML">numbering49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering50">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Allow level to default to single and count top-level items all the way down.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering50.xml</input-file>
<input-file role="principal-stylesheet">numbering50.xsl</input-file>
<output-file role="principal" compare="XML">numbering50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering51">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with from and count defaulted but level=any.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering51.xml</input-file>
<input-file role="principal-stylesheet">numbering51.xsl</input-file>
<output-file role="principal" compare="XML">numbering51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering52">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with a filtered count pattern, from defaulted, level=single.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering52.xml</input-file>
<input-file role="principal-stylesheet">numbering52.xsl</input-file>
<output-file role="principal" compare="XML">numbering52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering53">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with from and count defaulted, level=single.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering53.xml</input-file>
<input-file role="principal-stylesheet">numbering53.xsl</input-file>
<output-file role="principal" compare="XML">numbering53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering54">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with from and count defaulted, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering54.xml</input-file>
<input-file role="principal-stylesheet">numbering54.xsl</input-file>
<output-file role="principal" compare="XML">numbering54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering55">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with count on same level, from defaulted, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering55.xml</input-file>
<input-file role="principal-stylesheet">numbering55.xsl</input-file>
<output-file role="principal" compare="XML">numbering55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering56">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with count from higher level, from defaulted, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering56.xml</input-file>
<input-file role="principal-stylesheet">numbering56.xsl</input-file>
<output-file role="principal" compare="XML">numbering56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering57">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with count specifying same and higher level, from defaulted, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering57.xml</input-file>
<input-file role="principal-stylesheet">numbering57.xsl</input-file>
<output-file role="principal" compare="XML">numbering57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering58">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with a filtered count pattern, from defaulted, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering58.xml</input-file>
<input-file role="principal-stylesheet">numbering58.xsl</input-file>
<output-file role="principal" compare="XML">numbering58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering59">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (any) and counting only some nodes, with from defaulted.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering59.xml</input-file>
<input-file role="principal-stylesheet">numbering59.xsl</input-file>
<output-file role="principal" compare="XML">numbering59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering60">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (any) and counting only some nodes, from specifies next-higher level.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering60.xml</input-file>
<input-file role="principal-stylesheet">numbering60.xsl</input-file>
<output-file role="principal" compare="XML">numbering60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering61">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document, level=any, from specifies middle level.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering61.xml</input-file>
<input-file role="principal-stylesheet">numbering61.xsl</input-file>
<output-file role="principal" compare="XML">numbering61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering62">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Count one level of changes and number below there, level=single.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering62.xml</input-file>
<input-file role="principal-stylesheet">numbering62.xsl</input-file>
<output-file role="principal" compare="XML">numbering62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering63">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Count all levels of changes and number by level, level=single.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering63.xml</input-file>
<input-file role="principal-stylesheet">numbering63.xsl</input-file>
<output-file role="principal" compare="XML">numbering63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering64">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with count on same level, from is next higher level, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering64.xml</input-file>
<input-file role="principal-stylesheet">numbering64.xsl</input-file>
<output-file role="principal" compare="XML">numbering64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering65">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document with specified from level, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering65.xml</input-file>
<input-file role="principal-stylesheet">numbering65.xsl</input-file>
<output-file role="principal" compare="XML">numbering65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering66">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document with specified from level, count filtered.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[3]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering66.xml</input-file>
<input-file role="principal-stylesheet">numbering66.xsl</input-file>
<output-file role="principal" compare="XML">numbering66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering67">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with with from set for two levels, level=any, count defaulted.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering67.xml</input-file>
<input-file role="principal-stylesheet">numbering67.xsl</input-file>
<output-file role="principal" compare="XML">numbering67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering68">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with from set for two levels, level=any.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering68.xml</input-file>
<input-file role="principal-stylesheet">numbering68.xsl</input-file>
<output-file role="principal" compare="XML">numbering68.out</output-file>
</scenario>
</test-case>
<!--
MS bug in <xsl:number level='any' ... />


<test-case category="XSLT-Result-Tree" id="numbering_numbering69">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with from set for two levels, level=any, counting two levels.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering69.xml</input-file>
<input-file role="principal-stylesheet">numbering69.xsl</input-file>
<output-file role="principal" compare="XML">numbering69.out</output-file>
</scenario>
</test-case>

<test-case category="XSLT-Result-Tree" id="numbering_numbering70">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (any) and counting only some nodes, from specifies two higher levels.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering70.xml</input-file>
<input-file role="principal-stylesheet">numbering70.xsl</input-file>
<output-file role="principal" compare="XML">numbering70.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="numbering_numbering71">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (single) and counting only some nodes, from specifies two higher levels.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering71.xml</input-file>
<input-file role="principal-stylesheet">numbering71.xsl</input-file>
<output-file role="principal" compare="XML">numbering71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering72">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (single), from specifies two higher levels, count defaulted.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering72.xml</input-file>
<input-file role="principal-stylesheet">numbering72.xsl</input-file>
<output-file role="principal" compare="XML">numbering72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering73">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (single), from specifies two higher levels.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering73.xml</input-file>
<input-file role="principal-stylesheet">numbering73.xsl</input-file>
<output-file role="principal" compare="XML">numbering73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering74">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of level (single) and counting two types of nodes, from specifies two higher levels.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering74.xml</input-file>
<input-file role="principal-stylesheet">numbering74.xsl</input-file>
<output-file role="principal" compare="XML">numbering74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering75">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with level=multiple, from specifies two levels.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering75.xml</input-file>
<input-file role="principal-stylesheet">numbering75.xsl</input-file>
<output-file role="principal" compare="XML">numbering75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering76">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:number with count on same level, from is two higher levels, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering76.xml</input-file>
<input-file role="principal-stylesheet">numbering76.xsl</input-file>
<output-file role="principal" compare="XML">numbering76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering77">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document with two from levels, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering77.xml</input-file>
<input-file role="principal-stylesheet">numbering77.xsl</input-file>
<output-file role="principal" compare="XML">numbering77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering78">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of numbering of multi-level document with two from levels and filtering the lowest count level.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[7]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering78.xml</input-file>
<input-file role="principal-stylesheet">numbering78.xsl</input-file>
<output-file role="principal" compare="XML">numbering78.out</output-file>
</scenario>
</test-case>
<!--
MS bug result

<test-case category="XSLT-Result-Tree" id="numbering_numbering79">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of non-numeric assignment to value attribute.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<discretionary>
<discretionary-choice name="number-not-positive" behavior="pass-through"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">numbering79.xml</input-file>
<input-file role="principal-stylesheet">numbering79.xsl</input-file>
<output-file role="principal" compare="XML">numbering79.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="numbering_numbering80">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of grouping attributes. If only one of the two is present, it is ignored.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[6]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering80.xml</input-file>
<input-file role="principal-stylesheet">numbering80.xsl</input-file>
<output-file role="principal" compare="XML">numbering80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering81">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of grouping attributes. If only one of the two is present, it is ignored.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[2]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[6]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering81.xml</input-file>
<input-file role="principal-stylesheet">numbering81.xsl</input-file>
<output-file role="principal" compare="XML">numbering81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering82">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Count non-existant nodes, level=single.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering82.xml</input-file>
<input-file role="principal-stylesheet">numbering82.xsl</input-file>
<output-file role="principal" compare="XML">numbering82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering83">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Count non-existant nodes, level=any.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering83.xml</input-file>
<input-file role="principal-stylesheet">numbering83.xsl</input-file>
<output-file role="principal" compare="XML">numbering83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering84">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Count non-existant nodes, level=multiple.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering84.xml</input-file>
<input-file role="principal-stylesheet">numbering84.xsl</input-file>
<output-file role="principal" compare="XML">numbering84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering85">
<file-path>numbering</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test that value attribute gets rounded correctly w/various formats.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[4]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering85.xml</input-file>
<input-file role="principal-stylesheet">numbering85.xsl</input-file>
<output-file role="principal" compare="XML">numbering85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering86">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Namespaced elements should work just like non-namespaced ones.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[3]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering86.xml</input-file>
<input-file role="principal-stylesheet">numbering86.xsl</input-file>
<output-file role="principal" compare="XML">numbering86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering87">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Number the namespaced elements when mixed with non-namespaced ones.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[3]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering87.xml</input-file>
<input-file role="principal-stylesheet">numbering87.xsl</input-file>
<output-file role="principal" compare="XML">numbering87.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering88">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show discrepancies between number and position.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[3]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering88.xml</input-file>
<input-file role="principal-stylesheet">numbering88.xsl</input-file>
<output-file role="principal" compare="XML">numbering88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering89">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show discrepancies between number and position.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[3]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering89.xml</input-file>
<input-file role="principal-stylesheet">numbering89.xsl</input-file>
<output-file role="principal" compare="XML">numbering89.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering90">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test counting only some nodes, with key() in count pattern.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering90.xml</input-file>
<input-file role="principal-stylesheet">numbering90.xsl</input-file>
<output-file role="principal" compare="XML">numbering90.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering91">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test counting only some nodes, with id() in count pattern.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering91.xml</input-file>
<input-file role="principal-stylesheet">numbering91.xsl</input-file>
<output-file role="principal" compare="XML">numbering91.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering92">
<file-path>numbering</file-path>
<creator>Ilene Seelemann</creator>
<date>2001-11-08</date>
<purpose>If the source document has a named default namespace, the counting (on xsl:number) should still work.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[3]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering92.xml</input-file>
<input-file role="principal-stylesheet">numbering92.xsl</input-file>
<output-file role="principal" compare="XML">numbering92.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering93">
<file-path>numbering</file-path>
<creator>Ilene Seelemann</creator>
<date>2001-11-08</date>
<purpose>Namespaced elements should work just like non-namespaced ones even when prefixes in source document and stylesheet are different.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[2]/p[1]/text()[3]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[3]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering93.xml</input-file>
<input-file role="principal-stylesheet">numbering93.xsl</input-file>
<output-file role="principal" compare="XML">numbering93.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering94">
<file-path>numbering</file-path>
<creator>Ilene Seelemann</creator>
<date>2001-11-08</date>
<purpose>Test of grouping attributes. Use a grouping-separator that is not likely to be in the environment's locale settings.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[2]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering94.xml</input-file>
<input-file role="principal-stylesheet">numbering94.xsl</input-file>
<output-file role="principal" compare="XML">numbering94.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="numbering_numbering95">
<file-path>numbering</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of grouping attributes. Ensure that grouping-separator can be a space.</purpose>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[2]/text()[5]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/ulist[1]/item[1]/p[1]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[1]"/>
<spec-citation spec="XSLT" version="1.0" type="XPointer" place="id(convert)/p[6]/text()[2]"/>
<scenario operation="standard">
<input-file role="principal-data">numbering95.xml</input-file>
<input-file role="principal-stylesheet">numbering95.xsl</input-file>
<output-file role="principal" compare="XML">numbering95.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="output_output01">
<file-path>output</file-path>
<purpose>Test for SCRIPT handling</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output01.xml</input-file>
<input-file role="principal-stylesheet">output01.xsl</input-file>
<output-file role="principal" compare="XML">output01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output02">
<file-path>output</file-path>
<purpose>Test for STYLE handling</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output02.xml</input-file>
<input-file role="principal-stylesheet">output02.xsl</input-file>
<output-file role="principal" compare="XML">output02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output03">
<file-path>output</file-path>
<purpose>Test for disabling output escaping in xsl:text</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output03.xml</input-file>
<input-file role="principal-stylesheet">output03.xsl</input-file>
<output-file role="principal" compare="XML">output03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output04">
<file-path>output</file-path>
<purpose>Test for numbered character entities</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output04.xml</input-file>
<input-file role="principal-stylesheet">output04.xsl</input-file>
<output-file role="principal" compare="XML">output04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output05">
<file-path>output</file-path>
<purpose>Test for "whitespace sensitive" html tags; &lt;img&gt;, &lt;applet&gt;, &lt;object&gt;</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output05.xml</input-file>
<input-file role="principal-stylesheet">output05.xsl</input-file>
<output-file role="principal" compare="XML">output05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output06">
<file-path>output</file-path>
<purpose>Test for disabling output escaping in xsl:value-of</purpose>
<spec-citation place="7.6.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output06.xml</input-file>
<input-file role="principal-stylesheet">output06.xsl</input-file>
<output-file role="principal" compare="XML">output06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output07">
<file-path>output</file-path>
<purpose>Test for enabling output escaping in xsl:value-of, XML output</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output07.xml</input-file>
<input-file role="principal-stylesheet">output07.xsl</input-file>
<output-file role="principal" compare="XML">output07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output08">
<file-path>output</file-path>
<purpose>Test for enabling output escaping in xsl:text, HTML output</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output08.xml</input-file>
<input-file role="principal-stylesheet">output08.xsl</input-file>
<output-file role="principal" compare="XML">output08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output09">
<file-path>output</file-path>
<purpose>Test for disabling output escaping in a variable with xsl:text, HTML output</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output09.xml</input-file>
<input-file role="principal-stylesheet">output09.xsl</input-file>
<output-file role="principal" compare="XML">output09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output10">
<file-path>output</file-path>
<purpose>test for disabling output escaping in a variable with xsl:value-of</purpose>
<spec-citation place="7.6.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output10.xml</input-file>
<input-file role="principal-stylesheet">output10.xsl</input-file>
<output-file role="principal" compare="XML">output10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output11">
<file-path>output</file-path>
<purpose>Test for the xml output method by itself</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output11.xml</input-file>
<input-file role="principal-stylesheet">output11.xsl</input-file>
<output-file role="principal" compare="XML">output11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output12">
<file-path>output</file-path>
<purpose>Test for the xml output method by itself with omit-xml-declaration</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output12.xml</input-file>
<input-file role="principal-stylesheet">output12.xsl</input-file>
<output-file role="principal" compare="XML">output12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output13">
<file-path>output</file-path>
<purpose>Test for doctype-system</purpose>
<spec-citation place="16" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output13.xml</input-file>
<input-file role="principal-stylesheet">output13.xsl</input-file>
<output-file role="principal" compare="XML">output13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output14">
<file-path>output</file-path>
<purpose>Test for doctype-public only</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output14.xml</input-file>
<input-file role="principal-stylesheet">output14.xsl</input-file>
<output-file role="principal" compare="XML">output14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output15">
<file-path>output</file-path>
<purpose>Test for doctype-system and doctype-public</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output15.xml</input-file>
<input-file role="principal-stylesheet">output15.xsl</input-file>
<output-file role="principal" compare="XML">output15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output16">
<file-path>output</file-path>
<purpose>Test for doctype-system with html method</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output16.xml</input-file>
<input-file role="principal-stylesheet">output16.xsl</input-file>
<output-file role="principal" compare="XML">output16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output17">
<file-path>output</file-path>
<purpose>Test for doctype-public only with html method</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output17.xml</input-file>
<input-file role="principal-stylesheet">output17.xsl</input-file>
<output-file role="principal" compare="XML">output17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output18">
<file-path>output</file-path>
<purpose>Test for doctype-system and doctype-public with html method</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output18.xml</input-file>
<input-file role="principal-stylesheet">output18.xsl</input-file>
<output-file role="principal" compare="XML">output18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output19">
<file-path>output</file-path>
<purpose>Test US-ASCII encoding.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output19.xml</input-file>
<input-file role="principal-stylesheet">output19.xsl</input-file>
<output-file role="principal" compare="XML">output19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output20">
<file-path>output</file-path>
<purpose>Test SHIFT_JIS encoding.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output20.xml</input-file>
<input-file role="principal-stylesheet">output20.xsl</input-file>
<output-file role="principal" compare="XML">output20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output21">
<file-path>output</file-path>
<purpose>Test BIG5 encoding.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output21.xml</input-file>
<input-file role="principal-stylesheet">output21.xsl</input-file>
<output-file role="principal" compare="XML">output21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output22">
<file-path>output</file-path>
<purpose>Test EBCDIC-CP-IT encoding. Avoid new-lines in output until XML 1.1 addresses the EBCDIC-specific new-line issue. It all looks like gibberish on an ASCII/ISO/UTF platform anyway, so you won't notice the lack of an XML decl.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output22.xml</input-file>
<input-file role="principal-stylesheet">output22.xsl</input-file>
<output-file role="principal" compare="XML">output22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output23">
<file-path>output</file-path>
<purpose>Test ISO-2022-JP encoding.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output23.xml</input-file>
<input-file role="principal-stylesheet">output23.xsl</input-file>
<output-file role="principal" compare="XML">output23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output24">
<file-path>output</file-path>
<purpose>Escape of non-ASCII chars in URI attribute values using method cited in Section B.2.1 of HTML 4.0 Spec. This test is a duplicate of output31, except that the output is XML.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output24.xml</input-file>
<input-file role="principal-stylesheet">output24.xsl</input-file>
<output-file role="principal" compare="XML">output24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output25">
<file-path>output</file-path>
<purpose>???</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output25.xml</input-file>
<input-file role="principal-stylesheet">output25.xsl</input-file>
<output-file role="principal" compare="XML">output25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output26">
<file-path>output</file-path>
<purpose>Text output of characters encoded between 128 and 255</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output26.xml</input-file>
<input-file role="principal-stylesheet">output26.xsl</input-file>
<output-file role="principal" compare="XML">output26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output28">
<file-path>output</file-path>
<purpose>Result tree here defaults to XML Test for cdata-section-elements with nonrepresentable character.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output28.xml</input-file>
<input-file role="principal-stylesheet">output28.xsl</input-file>
<output-file role="principal" compare="XML">output28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output29">
<file-path>output</file-path>
<purpose>Test cdata-section-elements.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output29.xml</input-file>
<input-file role="principal-stylesheet">output29.xsl</input-file>
<output-file role="principal" compare="XML">output29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output30">
<file-path>output</file-path>
<purpose>Test cdata-section-elements that looks like end of CDATA.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output30.xml</input-file>
<input-file role="principal-stylesheet">output30.xsl</input-file>
<output-file role="principal" compare="XML">output30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output32">
<file-path>output</file-path>
<purpose>ESC of non-ASCII chars in URI attribute values using method sited in Section B.2.1 of HTML 4.0 Spec.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output32.xml</input-file>
<input-file role="principal-stylesheet">output32.xsl</input-file>
<output-file role="principal" compare="XML">output32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output33">
<file-path>output</file-path>
<purpose>html output method should not output an end-tag for designated empty elements.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output33.xml</input-file>
<input-file role="principal-stylesheet">output33.xsl</input-file>
<output-file role="principal" compare="XML">output33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output34">
<file-path>output</file-path>
<purpose>Names of HTML elements should be recognized regardless of case.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output34.xml</input-file>
<input-file role="principal-stylesheet">output34.xsl</input-file>
<output-file role="principal" compare="XML">output34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output35">
<file-path>output</file-path>
<purpose>Boolean attributes should be output in minimized form.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output35.xml</input-file>
<input-file role="principal-stylesheet">output35.xsl</input-file>
<output-file role="principal" compare="XML">output35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output36">
<file-path>output</file-path>
<purpose>Processing instructions should be terminated with "&gt;".</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output36.xml</input-file>
<input-file role="principal-stylesheet">output36.xsl</input-file>
<output-file role="principal" compare="XML">output36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output37">
<file-path>output</file-path>
<purpose>"&amp;" should not be escaped when occuring in an attribute value immediately followed by a "{". See to Section B.7.1 HTML 4.0 Recommendation.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output37.xml</input-file>
<input-file role="principal-stylesheet">output37.xsl</input-file>
<output-file role="principal" compare="XML">output37.out</output-file>
</scenario>
</test-case>
<!--
Output encoding should be iso-8859-1

<test-case category="XSLT-Result-Tree" id="output_output38">
<file-path>output</file-path>
<purpose>Meta should be added immediately after after the start-tag of the HEAD element specifying the character encoding actually used.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output38.xml</input-file>
<input-file role="principal-stylesheet">output38.xsl</input-file>
<output-file role="principal" compare="XML">output38.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="output_output39">
<file-path>output</file-path>
<purpose>Test of indent</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output39.xml</input-file>
<input-file role="principal-stylesheet">output39.xsl</input-file>
<output-file role="principal" compare="XML">output39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output40">
<file-path>output</file-path>
<purpose>Test of indent</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output40.xml</input-file>
<input-file role="principal-stylesheet">output40.xsl</input-file>
<output-file role="principal" compare="XML">output40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output41">
<file-path>output</file-path>
<purpose>Text node containing "]]&gt;" and closure of CDATA section.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output41.xml</input-file>
<input-file role="principal-stylesheet">output41.xsl</input-file>
<output-file role="principal" compare="XML">output41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output42">
<file-path>output</file-path>
<purpose>Test of cdata-section-elements processing.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output42.xml</input-file>
<input-file role="principal-stylesheet">output42.xsl</input-file>
<output-file role="principal" compare="XML">output42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output43">
<file-path>output</file-path>
<purpose>Test of cdata-section-elements processing. &lt;example&gt; should not be processed.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output43.xml</input-file>
<input-file role="principal-stylesheet">output43.xsl</input-file>
<output-file role="principal" compare="XML">output43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output44">
<file-path>output</file-path>
<purpose>xml method should output XML declaration.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output44.xml</input-file>
<input-file role="principal-stylesheet">output44.xsl</input-file>
<output-file role="principal" compare="XML">output44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output45">
<file-path>output</file-path>
<purpose>xml method should not output XML declaration if omit-xml-declaration="yes".</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output45.xml</input-file>
<input-file role="principal-stylesheet">output45.xsl</input-file>
<output-file role="principal" compare="XML">output45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output46">
<file-path>output</file-path>
<purpose>All xsl:output elements are merged into a single element. While repeats of most attributes are just tested for conflicts, cdata-section-elements will contain the union of the specified values. Both example and test should be wrapped by CDATA, and the output should be XML (since cdata-section-elements only applies to XML).</purpose>
<spec-citation place="16" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output46.xml</input-file>
<input-file role="principal-stylesheet">output46.xsl</input-file>
<output-file role="principal" compare="XML">output46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output47">
<file-path>output</file-path>
<purpose>Illegal use of disable-output-escaping.</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output47.xml</input-file>
<input-file role="principal-stylesheet">output47.xsl</input-file>
<output-file role="principal" compare="XML">output47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output48">
<file-path>output</file-path>
<purpose>... html output method should output a DTD immediately before the first element.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output48.xml</input-file>
<input-file role="principal-stylesheet">output48.xsl</input-file>
<output-file role="principal" compare="XML">output48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output49">
<file-path>output</file-path>
<purpose>HTML output method should not escape '&lt;' in attribute values.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output49.xml</input-file>
<input-file role="principal-stylesheet">output49.xsl</input-file>
<output-file role="principal" compare="XML">output49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output50">
<file-path>output</file-path>
<purpose>Valid use of disable-output-escaping.</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output50.xml</input-file>
<input-file role="principal-stylesheet">output50.xsl</input-file>
<output-file role="principal" compare="XML">output50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output51">
<file-path>output</file-path>
<purpose>Test of indent attribute by itself.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output51.xml</input-file>
<input-file role="principal-stylesheet">output51.xsl</input-file>
<output-file role="principal" compare="XML">output51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output52">
<file-path>output</file-path>
<purpose>html output method should not output white space after the image tag within the anchor tag.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output52.xml</input-file>
<input-file role="principal-stylesheet">output52.xsl</input-file>
<output-file role="principal" compare="XML">output52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output53">
<file-path>output</file-path>
<purpose>Basic test for creating a comment.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output53.xml</input-file>
<input-file role="principal-stylesheet">output53.xsl</input-file>
<output-file role="principal" compare="XML">output53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output54">
<file-path>output</file-path>
<purpose>Test for creating a comment using a formula.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output54.xml</input-file>
<input-file role="principal-stylesheet">output54.xsl</input-file>
<output-file role="principal" compare="XML">output54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output55">
<file-path>output</file-path>
<purpose>Test creating a comment from a path expression.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output55.xml</input-file>
<input-file role="principal-stylesheet">output55.xsl</input-file>
<output-file role="principal" compare="XML">output55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output56">
<file-path>output</file-path>
<purpose>Test creating a comment from a variable.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output56.xml</input-file>
<input-file role="principal-stylesheet">output56.xsl</input-file>
<output-file role="principal" compare="XML">output56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output57">
<file-path>output</file-path>
<purpose>Test use of xsl:if and xsl:text inside xsl:comment.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output57.xml</input-file>
<input-file role="principal-stylesheet">output57.xsl</input-file>
<output-file role="principal" compare="XML">output57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output58">
<file-path>output</file-path>
<purpose>Test creation of a top-level comment.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output58.xml</input-file>
<input-file role="principal-stylesheet">output58.xsl</input-file>
<output-file role="principal" compare="XML">output58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output59">
<file-path>output</file-path>
<purpose>Test creation of a top-level processing-instruction before the document element.</purpose>
<spec-citation place="7.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output59.xml</input-file>
<input-file role="principal-stylesheet">output59.xsl</input-file>
<output-file role="principal" compare="XML">output59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output60">
<file-path>output</file-path>
<purpose>Do everything inside an HTML element. Note first item in this file.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output60.xml</input-file>
<input-file role="principal-stylesheet">output60.xsl</input-file>
<output-file role="principal" compare="XML">output60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output61">
<file-path>output</file-path>
<purpose>Test for disabling output escaping in xsl:value-of on ., which has special code. XML method.</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output61.xml</input-file>
<input-file role="principal-stylesheet">output61.xsl</input-file>
<output-file role="principal" compare="XML">output61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output62">
<file-path>output</file-path>
<purpose>Test for disabling output escaping in xsl:value-of on ., which has special code. HTML method.</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output62.xml</input-file>
<input-file role="principal-stylesheet">output62.xsl</input-file>
<output-file role="principal" compare="XML">output62.out</output-file>
</scenario>
</test-case>
<!--
This test treats as if jsp namespace is alive, but this is excluded. So this setProperty should be treated as null namespace element.


<test-case category="XSLT-Result-Tree" id="output_output63">
<file-path>output</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>The html output method should not output an element differently from the xml output method unless the expanded-name of the element has a null namespace URI; an element whose expanded-name has a non-null namespace URI should be output as XML. So the html tags &lt;p&gt;, &lt;hr&gt; and &lt;br&gt; in this case, due to the default html namespace will be output as xml not html.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output63.xml</input-file>
<input-file role="principal-stylesheet">output63.xsl</input-file>
<output-file role="principal" compare="XML">output63.out</output-file>
</scenario>
</test-case>
-->
<test-case category="XSLT-Result-Tree" id="output_output64">
<file-path>output</file-path>
<purpose>Generate output tagged for WML</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output64.xml</input-file>
<input-file role="principal-stylesheet">output64.xsl</input-file>
<output-file role="principal" compare="XML">output64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output65">
<file-path>output</file-path>
<purpose>Test for special case for XHTML</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output65.xml</input-file>
<input-file role="principal-stylesheet">output65.xsl</input-file>
<output-file role="principal" compare="XML">output65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output66">
<file-path>output</file-path>
<purpose>Verify standalone attribute set to "no".</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output66.xml</input-file>
<input-file role="principal-stylesheet">output66.xsl</input-file>
<output-file role="principal" compare="XML">output66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output67">
<file-path>output</file-path>
<purpose>Verify standalone attribute set to "yes".</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output67.xml</input-file>
<input-file role="principal-stylesheet">output67.xsl</input-file>
<output-file role="principal" compare="XML">output67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output68">
<file-path>output</file-path>
<purpose>Test for-each inside xsl:comment.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output68.xml</input-file>
<input-file role="principal-stylesheet">output68.xsl</input-file>
<output-file role="principal" compare="XML">output68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output69">
<file-path>output</file-path>
<purpose>Test for-each inside xsl:processing-instruction.</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output69.xml</input-file>
<input-file role="principal-stylesheet">output69.xsl</input-file>
<output-file role="principal" compare="XML">output69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output70">
<file-path>output</file-path>
<purpose>Quotes and apostrophes can be used inside themselves, without terminating the string, if entered as entities.</purpose>
<spec-citation place="1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">output70.xml</input-file>
<input-file role="principal-stylesheet">output70.xsl</input-file>
<output-file role="principal" compare="XML">output70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output71">
<file-path>output</file-path>
<purpose>Test that implied HTML output assumes indent=yes.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output71.xml</input-file>
<input-file role="principal-stylesheet">output71.xsl</input-file>
<output-file role="principal" compare="XML">output71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output72">
<file-path>output</file-path>
<purpose>Test the generation of Processing instructions.</purpose>
<spec-citation place="7.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output72.xml</input-file>
<input-file role="principal-stylesheet">output72.xsl</input-file>
<output-file role="principal" compare="XML">output72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output73">
<file-path>output</file-path>
<purpose>Test SHIFT_JIS encoding on HTML output.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output73.xml</input-file>
<input-file role="principal-stylesheet">output73.xsl</input-file>
<output-file role="principal" compare="XML">output73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output74">
<file-path>output</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Spec states:It is an error for output escaping to be disabled for a text node that is used for something other than a text node in the result tree. Thus, it is an error to disable output escaping for an xsl:value-of or xsl:text element that is used to generate the string-value of a comment, processing instruction or attribute node;. OUTPUT = HTML</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output74.xml</input-file>
<input-file role="principal-stylesheet">output74.xsl</input-file>
<output-file role="principal" compare="XML">output74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output75">
<file-path>output</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Spec states:It is an error for output escaping to be disabled for a text node that is used for something other than a text node in the result tree. Thus, it is an error to disable output escaping for an xsl:value-of or xsl:text element that is used to generate the string-value of a comment, processing instruction or attribute node; OUTPUT = XML</purpose>
<spec-citation place="16.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output75.xml</input-file>
<input-file role="principal-stylesheet">output75.xsl</input-file>
<output-file role="principal" compare="XML">output75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output76">
<file-path>output</file-path>
<purpose>Test for text output with special characters.</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output76.xml</input-file>
<input-file role="principal-stylesheet">output76.xsl</input-file>
<output-file role="principal" compare="XML">output76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output77">
<file-path>output</file-path>
<purpose>Test of ficticous encoding. This is generating an Illegal argument exception, with other known encodings such as "ISO-8859-11" too</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output77.xml</input-file>
<input-file role="principal-stylesheet">output77.xsl</input-file>
<output-file role="principal" compare="XML">output77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output80">
<file-path>output</file-path>
<purpose>Test UTF-16 encoding.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output80.xml</input-file>
<input-file role="principal-stylesheet">output80.xsl</input-file>
<output-file role="principal" compare="XML">output80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output81">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test use of leading underscore in names of Processing instructions.</purpose>
<spec-citation place="7.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output81.xml</input-file>
<input-file role="principal-stylesheet">output81.xsl</input-file>
<output-file role="principal" compare="XML">output81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output82">
<file-path>output</file-path>
<creator>Ito Kazumitsu</creator>
<date>2001-11-08</date>
<purpose>Generic test, verifies that DOCTYPE gets generated correctly, and that the default namespace xml is in scope for LRE use.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output82.xml</input-file>
<input-file role="principal-stylesheet">output82.xsl</input-file>
<output-file role="principal" compare="XML">output82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output84">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check that xml:lang is properly emitted in XML output.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output84.xml</input-file>
<input-file role="principal-stylesheet">output84.xsl</input-file>
<output-file role="principal" compare="XML">output84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output85">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check that xml:lang is properly copied from literal attribute.</purpose>
<spec-citation place="16.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output85.xml</input-file>
<input-file role="principal-stylesheet">output85.xsl</input-file>
<output-file role="principal" compare="XML">output85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output86">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Text output of characters encoded between 128 and 255</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output86.xml</input-file>
<input-file role="principal-stylesheet">output86.xsl</input-file>
<output-file role="principal" compare="XML">output86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output87">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check merging of multiple declarations of xsl:output.</purpose>
<spec-citation place="16" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="two-output-same-attribute" behavior="choose-last"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">output87.xml</input-file>
<input-file role="principal-stylesheet">output87.xsl</input-file>
<output-file role="principal" compare="XML">output87.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output88">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check effect of import precedence on merging of xsl:output.</purpose>
<spec-citation place="16" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output88.xml</input-file>
<input-file role="principal-stylesheet">output88.xsl</input-file>
<output-file role="principal" compare="XML">output88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output89">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check recovery when requested comment string contains two hyphens together</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="comment-content-contains-delimiter" behavior="add-space"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">output89.xml</input-file>
<input-file role="principal-stylesheet">output89.xsl</input-file>
<output-file role="principal" compare="XML">output89.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output90">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Check recovery when requested comment string ends with a hyphen</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<discretionary>
<discretionary-choice name="comment-content-contains-delimiter" behavior="add-space"/>
</discretionary>
<scenario operation="standard">
<input-file role="principal-data">output90.xml</input-file>
<input-file role="principal-stylesheet">output90.xsl</input-file>
<output-file role="principal" compare="XML">output90.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output91">
<file-path>output</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Test effect of cdata-section-elements on xsl:copy.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output91.xml</input-file>
<input-file role="principal-stylesheet">output91.xsl</input-file>
<output-file role="principal" compare="XML">output91.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output92">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test effect of cdata-section-elements on xsl:element.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output92.xml</input-file>
<input-file role="principal-stylesheet">output92.xsl</input-file>
<output-file role="principal" compare="XML">output92.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output93">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test effect of cdata-section-elements when text-node children are created by xsl:text.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output93.xml</input-file>
<input-file role="principal-stylesheet">output93.xsl</input-file>
<output-file role="principal" compare="XML">output93.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output94">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test effect of cdata-section-elements on multiple text-node children, created by xsl:text.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output94.xml</input-file>
<input-file role="principal-stylesheet">output94.xsl</input-file>
<output-file role="principal" compare="XML">output94.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output95">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test effect of cdata-section-elements when text-node children are created by xsl:value-of.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output95.xml</input-file>
<input-file role="principal-stylesheet">output95.xsl</input-file>
<output-file role="principal" compare="XML">output95.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output96">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that cdata-section-elements applies to text-node children, not descendants.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output96.xml</input-file>
<input-file role="principal-stylesheet">output96.xsl</input-file>
<output-file role="principal" compare="XML">output96.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output97">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test effect of cdata-section-elements on xsl:copy, with descendants in tree.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output97.xml</input-file>
<input-file role="principal-stylesheet">output97.xsl</input-file>
<output-file role="principal" compare="XML">output97.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output98">
<file-path>output</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Test of QName for cdata-section-elements attribute of xsl:output.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output98.xml</input-file>
<input-file role="principal-stylesheet">output98.xsl</input-file>
<output-file role="principal" compare="XML">output98.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output99">
<file-path>output</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Show that namespaced LRE does not match unprefixed element in cdata-section-elements list.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output99.xml</input-file>
<input-file role="principal-stylesheet">output99.xsl</input-file>
<output-file role="principal" compare="XML">output99.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output100">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that non-namespaced LRE does not match namespaced element in cdata-section-elements list.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output100.xml</input-file>
<input-file role="principal-stylesheet">output100.xsl</input-file>
<output-file role="principal" compare="XML">output100.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output101">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that LRE in default namespace can match namespaced element in cdata-section-elements list.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output101.xml</input-file>
<input-file role="principal-stylesheet">output101.xsl</input-file>
<output-file role="principal" compare="XML">output101.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output102">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that namespaced LRE can match element in cdata-section-elements list when default is set.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output102.xml</input-file>
<input-file role="principal-stylesheet">output102.xsl</input-file>
<output-file role="principal" compare="XML">output102.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output103">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that namespaced LRE can match differently-prefixed element in cdata-section-elements.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output103.xml</input-file>
<input-file role="principal-stylesheet">output103.xsl</input-file>
<output-file role="principal" compare="XML">output103.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output104">
<file-path>output</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Use cdata-section-elements with xsl:copy-of, namespaces match.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output104.xml</input-file>
<input-file role="principal-stylesheet">output104.xsl</input-file>
<output-file role="principal" compare="XML">output104.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output105">
<file-path>output</file-path>
<creator>David Bertoni</creator>
<date>2001-11-08</date>
<purpose>Use cdata-section-elements with xsl:copy-of, default in input matches prefixed here.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output105.xml</input-file>
<input-file role="principal-stylesheet">output105.xsl</input-file>
<output-file role="principal" compare="XML">output105.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output106">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use cdata-section-elements with xsl:copy-of, prefix in input matches default here.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output106.xml</input-file>
<input-file role="principal-stylesheet">output106.xsl</input-file>
<output-file role="principal" compare="XML">output106.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output107">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use cdata-section-elements with xsl:copy-of, namespaces match URIs but prefixes are different.</purpose>
<spec-citation place="16.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output107.xml</input-file>
<input-file role="principal-stylesheet">output107.xsl</input-file>
<output-file role="principal" compare="XML">output107.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output109">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Attempt to create comment under text output method</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output109.xml</input-file>
<input-file role="principal-stylesheet">output109.xsl</input-file>
<output-file role="principal" compare="XML">output109.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output110">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Attempt to create element (LRE) under text output method. Should get just its text-node descendant.</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output110.xml</input-file>
<input-file role="principal-stylesheet">output110.xsl</input-file>
<output-file role="principal" compare="XML">output110.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output111">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Attempt to create element under text output method. Should get just its text-node descendant.</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output111.xml</input-file>
<input-file role="principal-stylesheet">output111.xsl</input-file>
<output-file role="principal" compare="XML">output111.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output112">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Attempt to create attribute under text output method</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output112.xml</input-file>
<input-file role="principal-stylesheet">output112.xsl</input-file>
<output-file role="principal" compare="XML">output112.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output113">
<file-path>output</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Attempt to create processing instruction under text output method</purpose>
<spec-citation place="16.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output113.xml</input-file>
<input-file role="principal-stylesheet">output113.xsl</input-file>
<output-file role="principal" compare="XML">output113.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="output_output114">
<file-path>output</file-path>
<creator>Gordon Chiu</creator>
<date>2001-11-08</date>
<purpose>Check that empty comments are created correctly</purpose>
<spec-citation place="7.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">output114.xml</input-file>
<input-file role="principal-stylesheet">output114.xsl</input-file>
<output-file role="principal" compare="XML">output114.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="position_position01">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function in value-of select. Look for 1.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position01.xml</input-file>
<input-file role="principal-stylesheet">position01.xsl</input-file>
<output-file role="principal" compare="XML">position01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position02">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function in predicate on wildcard. Look for last item.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position02.xml</input-file>
<input-file role="principal-stylesheet">position02.xsl</input-file>
<output-file role="principal" compare="XML">position02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position03">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function anded with attribute test.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position03.xml</input-file>
<input-file role="principal-stylesheet">position03.xsl</input-file>
<output-file role="principal" compare="XML">position03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position04">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() in 2nd predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position04.xml</input-file>
<input-file role="principal-stylesheet">position04.xsl</input-file>
<output-file role="principal" compare="XML">position04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position05">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() predicate on node-set from key(). Look for item 4.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position05.xml</input-file>
<input-file role="principal-stylesheet">position05.xsl</input-file>
<output-file role="principal" compare="XML">position05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position06">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of count() on wildcard.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position06.xml</input-file>
<input-file role="principal-stylesheet">position06.xsl</input-file>
<output-file role="principal" compare="XML">position06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position07">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() in predicate, all spelled out.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position07.xml</input-file>
<input-file role="principal-stylesheet">position07.xsl</input-file>
<output-file role="principal" compare="XML">position07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position08">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() in match pattern. Used in predicate of name. Look for 1, last, others.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position08.xml</input-file>
<input-file role="principal-stylesheet">position08.xsl</input-file>
<output-file role="principal" compare="XML">position08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position09">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position in match pattern predicates, both long and short versions.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position09.xml</input-file>
<input-file role="principal-stylesheet">position09.xsl</input-file>
<output-file role="principal" compare="XML">position09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position10">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function and sorting.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position10.xml</input-file>
<input-file role="principal-stylesheet">position10.xsl</input-file>
<output-file role="principal" compare="XML">position10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position11">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() and last() in xsl:if test.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position11.xml</input-file>
<input-file role="principal-stylesheet">position11.xsl</input-file>
<output-file role="principal" compare="XML">position11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position12">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function in value-of select.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position12.xml</input-file>
<input-file role="principal-stylesheet">position12.xsl</input-file>
<output-file role="principal" compare="XML">position12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position13">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() function in value-of select.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position13.xml</input-file>
<input-file role="principal-stylesheet">position13.xsl</input-file>
<output-file role="principal" compare="XML">position13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position14">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() function in a numeric equality.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position14.xml</input-file>
<input-file role="principal-stylesheet">position14.xsl</input-file>
<output-file role="principal" compare="XML">position14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position15">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function in predicate. Look for last item.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position15.xml</input-file>
<input-file role="principal-stylesheet">position15.xsl</input-file>
<output-file role="principal" compare="XML">position15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position16">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function in a predicate. Look for item 3.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position16.xml</input-file>
<input-file role="principal-stylesheet">position16.xsl</input-file>
<output-file role="principal" compare="XML">position16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position17">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function in a predicate. Look for first.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position17.xml</input-file>
<input-file role="principal-stylesheet">position17.xsl</input-file>
<output-file role="principal" compare="XML">position17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position18">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() function and a variable in a predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position18.xml</input-file>
<input-file role="principal-stylesheet">position18.xsl</input-file>
<output-file role="principal" compare="XML">position18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position19">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of positional indexing (shorthand) in select. Look for last item.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position19.xml</input-file>
<input-file role="principal-stylesheet">position19.xsl</input-file>
<output-file role="principal" compare="XML">position19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position20">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing. Look for middle item.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position20.xml</input-file>
<input-file role="principal-stylesheet">position20.xsl</input-file>
<output-file role="principal" compare="XML">position20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position21">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing. Look for first.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position21.xml</input-file>
<input-file role="principal-stylesheet">position21.xsl</input-file>
<output-file role="principal" compare="XML">position21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position22">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of positional indexing on the text() nodes. Look for first.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position22.xml</input-file>
<input-file role="principal-stylesheet">position22.xsl</input-file>
<output-file role="principal" compare="XML">position22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position23">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of positional indexing on the text() nodes. Look for middle item.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position23.xml</input-file>
<input-file role="principal-stylesheet">position23.xsl</input-file>
<output-file role="principal" compare="XML">position23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position24">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() function with current context position.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position24.xml</input-file>
<input-file role="principal-stylesheet">position24.xsl</input-file>
<output-file role="principal" compare="XML">position24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position25">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function in predicate of wildcard. Look for middle item.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position25.xml</input-file>
<input-file role="principal-stylesheet">position25.xsl</input-file>
<output-file role="principal" compare="XML">position25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position26">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() function on predicate of wildcard. Look for first.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position26.xml</input-file>
<input-file role="principal-stylesheet">position26.xsl</input-file>
<output-file role="principal" compare="XML">position26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position27">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of positional capabilities with choose.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position27.xml</input-file>
<input-file role="principal-stylesheet">position27.xsl</input-file>
<output-file role="principal" compare="XML">position27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position28">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing with wildcard. Look for last item.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position28.xml</input-file>
<input-file role="principal-stylesheet">position28.xsl</input-file>
<output-file role="principal" compare="XML">position28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position29">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of positional indexing with wildcard. Look for middle item.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position29.xml</input-file>
<input-file role="principal-stylesheet">position29.xsl</input-file>
<output-file role="principal" compare="XML">position29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position30">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing with wildcard. Look for first.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position30.xml</input-file>
<input-file role="principal-stylesheet">position30.xsl</input-file>
<output-file role="principal" compare="XML">position30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position31">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() with a sibling axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position31.xml</input-file>
<input-file role="principal-stylesheet">position31.xsl</input-file>
<output-file role="principal" compare="XML">position31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position32">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() on predicate of wildcard, anded with attribute test.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position32.xml</input-file>
<input-file role="principal-stylesheet">position32.xsl</input-file>
<output-file role="principal" compare="XML">position32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position33">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() on predicate of wildcard, anded with attribute test. Look for first.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position33.xml</input-file>
<input-file role="principal-stylesheet">position33.xsl</input-file>
<output-file role="principal" compare="XML">position33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position34">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() on predicate of wildcard, anded with attribute test.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position34.xml</input-file>
<input-file role="principal-stylesheet">position34.xsl</input-file>
<output-file role="principal" compare="XML">position34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position35">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() in 2nd predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position35.xml</input-file>
<input-file role="principal-stylesheet">position35.xsl</input-file>
<output-file role="principal" compare="XML">position35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position36">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() in 2nd predicate. Look for first.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position36.xml</input-file>
<input-file role="principal-stylesheet">position36.xsl</input-file>
<output-file role="principal" compare="XML">position36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position37">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() in a for-each node set.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position37.xml</input-file>
<input-file role="principal-stylesheet">position37.xsl</input-file>
<output-file role="principal" compare="XML">position37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position38">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of positional indexing (shorthand) in 2nd predicate. Look for last item.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position38.xml</input-file>
<input-file role="principal-stylesheet">position38.xsl</input-file>
<output-file role="principal" compare="XML">position38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position39">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing in 2nd predicate.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position39.xml</input-file>
<input-file role="principal-stylesheet">position39.xsl</input-file>
<output-file role="principal" compare="XML">position39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position40">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of positional indexing in 2nd predicate. Look for first.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position40.xml</input-file>
<input-file role="principal-stylesheet">position40.xsl</input-file>
<output-file role="principal" compare="XML">position40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position41">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() in a for-each node set involving parent axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position41.xml</input-file>
<input-file role="principal-stylesheet">position41.xsl</input-file>
<output-file role="principal" compare="XML">position41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position42">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() on node-set from key().</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position42.xml</input-file>
<input-file role="principal-stylesheet">position42.xsl</input-file>
<output-file role="principal" compare="XML">position42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position43">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() on node-set from key(). Look for first.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position43.xml</input-file>
<input-file role="principal-stylesheet">position43.xsl</input-file>
<output-file role="principal" compare="XML">position43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position44">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() on node-set from key(). Look for first.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position44.xml</input-file>
<input-file role="principal-stylesheet">position44.xsl</input-file>
<output-file role="principal" compare="XML">position44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position45">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing on node-set from key().</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position45.xml</input-file>
<input-file role="principal-stylesheet">position45.xsl</input-file>
<output-file role="principal" compare="XML">position45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position46">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing on node-set from key().</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position46.xml</input-file>
<input-file role="principal-stylesheet">position46.xsl</input-file>
<output-file role="principal" compare="XML">position46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position47">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of shorthand positional indexing on node-set from key(). Look for first.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position47.xml</input-file>
<input-file role="principal-stylesheet">position47.xsl</input-file>
<output-file role="principal" compare="XML">position47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position48">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test position predicate on sort key.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">position48.xml</input-file>
<input-file role="principal-stylesheet">position48.xsl</input-file>
<output-file role="principal" compare="XML">position48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position49">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of positional indexing when used with key() in xsl:apply-templates. Look for last.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position49.xml</input-file>
<input-file role="principal-stylesheet">position49.xsl</input-file>
<output-file role="principal" compare="XML">position49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position50">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() when used with key() in xsl:apply-templates.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position50.xml</input-file>
<input-file role="principal-stylesheet">position50.xsl</input-file>
<output-file role="principal" compare="XML">position50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position51">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of position() when used with key() in xsl:apply-templates. Look for first.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position51.xml</input-file>
<input-file role="principal-stylesheet">position51.xsl</input-file>
<output-file role="principal" compare="XML">position51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position52">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of count() on a set filtered by position.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position52.xml</input-file>
<input-file role="principal-stylesheet">position52.xsl</input-file>
<output-file role="principal" compare="XML">position52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position53">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of count() with attribute wildcard.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position53.xml</input-file>
<input-file role="principal-stylesheet">position53.xsl</input-file>
<output-file role="principal" compare="XML">position53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position54">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of count() of wildcarded attribute axis, long-form notation.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position54.xml</input-file>
<input-file role="principal-stylesheet">position54.xsl</input-file>
<output-file role="principal" compare="XML">position54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position55">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() by itself in a predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position55.xml</input-file>
<input-file role="principal-stylesheet">position55.xsl</input-file>
<output-file role="principal" compare="XML">position55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position56">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() with node-set from key(). Long-form predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position56.xml</input-file>
<input-file role="principal-stylesheet">position56.xsl</input-file>
<output-file role="principal" compare="XML">position56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position57">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() in predicate of node-set from key().</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position57.xml</input-file>
<input-file role="principal-stylesheet">position57.xsl</input-file>
<output-file role="principal" compare="XML">position57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position58">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() in second predicate, in long form.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position58.xml</input-file>
<input-file role="principal-stylesheet">position58.xsl</input-file>
<output-file role="principal" compare="XML">position58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position59">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of last() in second predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position59.xml</input-file>
<input-file role="principal-stylesheet">position59.xsl</input-file>
<output-file role="principal" compare="XML">position59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position60">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of greater-than with position().</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position60.xml</input-file>
<input-file role="principal-stylesheet">position60.xsl</input-file>
<output-file role="principal" compare="XML">position60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position61">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of less-than with position().</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position61.xml</input-file>
<input-file role="principal-stylesheet">position61.xsl</input-file>
<output-file role="principal" compare="XML">position61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position62">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of greater-than-or-equal-to with position().</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position62.xml</input-file>
<input-file role="principal-stylesheet">position62.xsl</input-file>
<output-file role="principal" compare="XML">position62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position63">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of less-than-or-equal-to with position().</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position63.xml</input-file>
<input-file role="principal-stylesheet">position63.xsl</input-file>
<output-file role="principal" compare="XML">position63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position64">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of not-equal-to with position().</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position64.xml</input-file>
<input-file role="principal-stylesheet">position64.xsl</input-file>
<output-file role="principal" compare="XML">position64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position65">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of a numeric formula in positional indexing.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position65.xml</input-file>
<input-file role="principal-stylesheet">position65.xsl</input-file>
<output-file role="principal" compare="XML">position65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position66">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of zero in positional indexing.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position66.xml</input-file>
<input-file role="principal-stylesheet">position66.xsl</input-file>
<output-file role="principal" compare="XML">position66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position67">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of number function to make positional indexing definite.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position67.xml</input-file>
<input-file role="principal-stylesheet">position67.xsl</input-file>
<output-file role="principal" compare="XML">position67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position68">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test positional indexing with for-each loop and all-but-last xsl:if for comma.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position68.xml</input-file>
<input-file role="principal-stylesheet">position68.xsl</input-file>
<output-file role="principal" compare="XML">position68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position69">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test positional indexing with for-each loop and apply-templates.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position69.xml</input-file>
<input-file role="principal-stylesheet">position69.xsl</input-file>
<output-file role="principal" compare="XML">position69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position70">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that set of nodes changes when strip-space is in effect.</purpose>
<spec-citation place="5.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">position70.xml</input-file>
<input-file role="principal-stylesheet">position70.xsl</input-file>
<output-file role="principal" compare="XML">position70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position71">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that position test can be applied to PI nodes.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position71.xml</input-file>
<input-file role="principal-stylesheet">position71.xsl</input-file>
<output-file role="principal" compare="XML">position71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position72">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() and the ancestor-or-self axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position72.xml</input-file>
<input-file role="principal-stylesheet">position72.xsl</input-file>
<output-file role="principal" compare="XML">position72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position73">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() and for-each resetting the frame of reference of a node-set.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position73.xml</input-file>
<input-file role="principal-stylesheet">position73.xsl</input-file>
<output-file role="principal" compare="XML">position73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position74">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() and for-each resetting the frame of reference of a node-set. Show position via value-of before going into for-each loop.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position74.xml</input-file>
<input-file role="principal-stylesheet">position74.xsl</input-file>
<output-file role="principal" compare="XML">position74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position75">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of last() on various sets of children.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position75.xml</input-file>
<input-file role="principal-stylesheet">position75.xsl</input-file>
<output-file role="principal" compare="XML">position75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position76">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() with namespace axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position76.xml</input-file>
<input-file role="principal-stylesheet">position76.xsl</input-file>
<output-file role="principal" compare="XML">position76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position77">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test positional indexing in current node list passed via apply-templates with select that has predicate.</purpose>
<spec-citation place="5.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">position77.xml</input-file>
<input-file role="principal-stylesheet">position77.xsl</input-file>
<output-file role="principal" compare="XML">position77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position78">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Look at preceding axis (reverse document order) filtered by node test.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position78.xml</input-file>
<input-file role="principal-stylesheet">position78.xsl</input-file>
<output-file role="principal" compare="XML">position78.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position79">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Look at preceding axis filtered by node test. Use of apply-templates causes document-order processing.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position79.xml</input-file>
<input-file role="principal-stylesheet">position79.xsl</input-file>
<output-file role="principal" compare="XML">position79.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position80">
<file-path>position</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Ensure last() is working with unionpaths of ancestors.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position80.xml</input-file>
<input-file role="principal-stylesheet">position80.xsl</input-file>
<output-file role="principal" compare="XML">position80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position81">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of count() on a set filtered by the last() function.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position81.xml</input-file>
<input-file role="principal-stylesheet">position81.xsl</input-file>
<output-file role="principal" compare="XML">position81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position82">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of count() on a set filtered by the last() function.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position82.xml</input-file>
<input-file role="principal-stylesheet">position82.xsl</input-file>
<output-file role="principal" compare="XML">position82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position83">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try count() and last() on unionpaths that aren't sequential.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position83.xml</input-file>
<input-file role="principal-stylesheet">position83.xsl</input-file>
<output-file role="principal" compare="XML">position83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position83">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try positional filter on unionpaths that aren't sequential.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position83.xml</input-file>
<input-file role="principal-stylesheet">position83.xsl</input-file>
<output-file role="principal" compare="XML">position83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position85">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that () grouping can be applied multiple times.</purpose>
<spec-citation place="3.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position85.xml</input-file>
<input-file role="principal-stylesheet">position85.xsl</input-file>
<output-file role="principal" compare="XML">position85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position86">
<file-path>position</file-path>
<creator>Mukund Raghavachari</creator>
<date>2001-11-08</date>
<purpose>"The Predicate filters the node-set with respect to the child axis" means that the descendant(-or-self) axes must be internally segregated so that the position is among one group of children.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position86.xml</input-file>
<input-file role="principal-stylesheet">position86.xsl</input-file>
<output-file role="principal" compare="XML">position86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position87">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that predicate applies along child axis, not descendant-or-self.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position87.xml</input-file>
<input-file role="principal-stylesheet">position87.xsl</input-file>
<output-file role="principal" compare="XML">position87.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position88">
<file-path>position</file-path>
<creator>David Marston, from remarks of Mukund Raghavachari (who read Mike Kay)</creator>
<date>2001-11-08</date>
<purpose>Test () grouping around // (descendant-or-self) axis.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position88.xml</input-file>
<input-file role="principal-stylesheet">position88.xsl</input-file>
<output-file role="principal" compare="XML">position88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position89">
<file-path>position</file-path>
<creator>David Marston, from remarks of Mukund Raghavachari (who read Mike Kay)</creator>
<date>2001-11-08</date>
<purpose>Test () grouping with expanded version of // axis. This test attempts to give an explicit representation of one possible fallacious interpretation of chapter//footnote[2].</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position89.xml</input-file>
<input-file role="principal-stylesheet">position89.xsl</input-file>
<output-file role="principal" compare="XML">position89.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position90">
<file-path>position</file-path>
<creator>David Marston, from remarks of Mukund Raghavachari (who read Mike Kay)</creator>
<date>2001-11-08</date>
<purpose>Test () grouping with expanded version of // axis. This test attempts to give an explicit representation of one possible fallacious interpretation of chapter//footnote[6].</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position90.xml</input-file>
<input-file role="principal-stylesheet">position90.xsl</input-file>
<output-file role="principal" compare="XML">position90.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position91">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Apply a predicate to a node-set full of attribute nodes. If there were no parentheses, we would be asking for the 7th attribute named "title" on each element, but there can only be one attribute of a particular name on each, so we'd get the empty set.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position91.xml</input-file>
<input-file role="principal-stylesheet">position91.xsl</input-file>
<output-file role="principal" compare="XML">position91.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position92">
<file-path>position</file-path>
<creator>John Howard</creator>
<date>2001-11-08</date>
<purpose>Test retrieving correct values from node-set variables by positional predicate.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position92.xml</input-file>
<input-file role="principal-stylesheet">position92.xsl</input-file>
<output-file role="principal" compare="XML">position92.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position93">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() in match pattern. Nodes are sorted.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position93.xml</input-file>
<input-file role="principal-stylesheet">position93.xsl</input-file>
<output-file role="principal" compare="XML">position93.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position94">
<file-path>position</file-path>
<creator>Sergei Ivanov, adapted by David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of position() and last() in xsl:with-param.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">position94.xml</input-file>
<input-file role="principal-stylesheet">position94.xsl</input-file>
<output-file role="principal" compare="XML">position94.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position95">
<file-path>position</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test position in a union in a match pattern</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position95.xml</input-file>
<input-file role="principal-stylesheet">position95.xsl</input-file>
<output-file role="principal" compare="XML">position95.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position96">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use just a (number-valued) global variable in a predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position96.xml</input-file>
<input-file role="principal-stylesheet">position96.xsl</input-file>
<output-file role="principal" compare="XML">position96.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position97">
<file-path>position</file-path>
<creator>Joerg Heinicke, trimmed by David Marston</creator>
<date>2001-11-08</date>
<purpose>Use a (number-valued) variable in a predicate, but inside a for-each.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position97.xml</input-file>
<input-file role="principal-stylesheet">position97.xsl</input-file>
<output-file role="principal" compare="XML">position97.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position98">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test count() starting on an attribute and going upward.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position98.xml</input-file>
<input-file role="principal-stylesheet">position98.xsl</input-file>
<output-file role="principal" compare="XML">position98.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position99">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test count() starting on an element and going upward.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position99.xml</input-file>
<input-file role="principal-stylesheet">position99.xsl</input-file>
<output-file role="principal" compare="XML">position99.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position100">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test count() starting on a text node and going upward.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position100.xml</input-file>
<input-file role="principal-stylesheet">position100.xsl</input-file>
<output-file role="principal" compare="XML">position100.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position101">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test count() starting on a comment and going upward.</purpose>
<spec-citation place="2.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position101.xml</input-file>
<input-file role="principal-stylesheet">position101.xsl</input-file>
<output-file role="principal" compare="XML">position101.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position102">
<file-path>position</file-path>
<creator>David Marston, from an idea by Kai Ojansuu</creator>
<date>2001-11-08</date>
<purpose>Test position() when template is imported.</purpose>
<spec-citation place="5.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">position102.xml</input-file>
<input-file role="principal-stylesheet">position102.xsl</input-file>
<output-file role="principal" compare="XML">position102.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position103">
<file-path>position</file-path>
<creator>Igor Hersht</creator>
<date>2001-11-08</date>
<purpose>Ensure that last() takes on new value when context changes</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position103.xml</input-file>
<input-file role="principal-stylesheet">position103.xsl</input-file>
<output-file role="principal" compare="XML">position103.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position104">
<file-path>position</file-path>
<creator>Igor Hersht</creator>
<date>2001-11-08</date>
<purpose>Try double positional predicates to ensure they at least raise no error</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position104.xml</input-file>
<input-file role="principal-stylesheet">position104.xsl</input-file>
<output-file role="principal" compare="XML">position104.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position105">
<file-path>position</file-path>
<creator>Ilene Seelemann</creator>
<date>2001-11-08</date>
<purpose>Test last() in a numeric expression and double predicate.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position105.xml</input-file>
<input-file role="principal-stylesheet">position105.xsl</input-file>
<output-file role="principal" compare="XML">position105.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position106">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for last() on 'ancestor-or-self::' axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position106.xml</input-file>
<input-file role="principal-stylesheet">position106.xsl</input-file>
<output-file role="principal" compare="XML">position106.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position107">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for last() on 'preceding-sibling::' axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position107.xml</input-file>
<input-file role="principal-stylesheet">position107.xsl</input-file>
<output-file role="principal" compare="XML">position107.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position108">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for last() on 'following-sibling::' axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position108.xml</input-file>
<input-file role="principal-stylesheet">position108.xsl</input-file>
<output-file role="principal" compare="XML">position108.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position109">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for last() on 'preceding::' axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position109.xml</input-file>
<input-file role="principal-stylesheet">position109.xsl</input-file>
<output-file role="principal" compare="XML">position109.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position101">
<file-path>position</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for last() on 'following::' axis.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position101.xml</input-file>
<input-file role="principal-stylesheet">position101.xsl</input-file>
<output-file role="principal" compare="XML">position101.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="position_position111">
<file-path>position</file-path>
<creator>David Bertoni, amended by David Marston</creator>
<date>2001-11-08</date>
<purpose>Data Model requires that namespace nodes precede attribute nodes.</purpose>
<spec-citation place="5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">position111.xml</input-file>
<input-file role="principal-stylesheet">position111.xsl</input-file>
<output-file role="principal" compare="XML">position111.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="predicate_predicate01">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion to boolean.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate01.xml</input-file>
<input-file role="principal-stylesheet">predicate01.xsl</input-file>
<output-file role="principal" compare="XML">predicate01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate02">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion to boolean.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate02.xml</input-file>
<input-file role="principal-stylesheet">predicate02.xsl</input-file>
<output-file role="principal" compare="XML">predicate02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate03">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to boolean.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate03.xml</input-file>
<input-file role="principal-stylesheet">predicate03.xsl</input-file>
<output-file role="principal" compare="XML">predicate03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate04">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion to number.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate04.xml</input-file>
<input-file role="principal-stylesheet">predicate04.xsl</input-file>
<output-file role="principal" compare="XML">predicate04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate05">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate05.xml</input-file>
<input-file role="principal-stylesheet">predicate05.xsl</input-file>
<output-file role="principal" compare="XML">predicate05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate06">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to string.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate06.xml</input-file>
<input-file role="principal-stylesheet">predicate06.xsl</input-file>
<output-file role="principal" compare="XML">predicate06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate07">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion to number for an inequality test.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate07.xml</input-file>
<input-file role="principal-stylesheet">predicate07.xsl</input-file>
<output-file role="principal" compare="XML">predicate07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate08">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion to number for an inequality test.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate08.xml</input-file>
<input-file role="principal-stylesheet">predicate08.xsl</input-file>
<output-file role="principal" compare="XML">predicate08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate09">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate09.xml</input-file>
<input-file role="principal-stylesheet">predicate09.xsl</input-file>
<output-file role="principal" compare="XML">predicate09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate10">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of association of inequality symbols.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate10.xml</input-file>
<input-file role="principal-stylesheet">predicate10.xsl</input-file>
<output-file role="principal" compare="XML">predicate10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate11">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of comparison of 2 node-sets.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate11.xml</input-file>
<input-file role="principal-stylesheet">predicate11.xsl</input-file>
<output-file role="principal" compare="XML">predicate11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate12">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean or.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate12.xml</input-file>
<input-file role="principal-stylesheet">predicate12.xsl</input-file>
<output-file role="principal" compare="XML">predicate12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate13">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean not compounded with or.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate13.xml</input-file>
<input-file role="principal-stylesheet">predicate13.xsl</input-file>
<output-file role="principal" compare="XML">predicate13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate14">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean and, or with parens retaining usual precedence.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate14.xml</input-file>
<input-file role="principal-stylesheet">predicate14.xsl</input-file>
<output-file role="principal" compare="XML">predicate14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate15">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean and, or with parens overriding precedence.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate15.xml</input-file>
<input-file role="principal-stylesheet">predicate15.xsl</input-file>
<output-file role="principal" compare="XML">predicate15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate16">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean and, or without parens.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate16.xml</input-file>
<input-file role="principal-stylesheet">predicate16.xsl</input-file>
<output-file role="principal" compare="XML">predicate16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate17">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of boolean not with @* to test for lack of attributes.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate17.xml</input-file>
<input-file role="principal-stylesheet">predicate17.xsl</input-file>
<output-file role="principal" compare="XML">predicate17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate18">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of starts-with on node name.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate18.xml</input-file>
<input-file role="principal-stylesheet">predicate18.xsl</input-file>
<output-file role="principal" compare="XML">predicate18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate19">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of string-length on node name.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate19.xml</input-file>
<input-file role="principal-stylesheet">predicate19.xsl</input-file>
<output-file role="principal" compare="XML">predicate19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate20">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to string, ensure = is symmetric.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate20.xml</input-file>
<input-file role="principal-stylesheet">predicate20.xsl</input-file>
<output-file role="principal" compare="XML">predicate20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate21">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to string on != predicate.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate21.xml</input-file>
<input-file role="principal-stylesheet">predicate21.xsl</input-file>
<output-file role="principal" compare="XML">predicate21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate22">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to string, and that != is symmetric.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate22.xml</input-file>
<input-file role="principal-stylesheet">predicate22.xsl</input-file>
<output-file role="principal" compare="XML">predicate22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate23">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to boolean, ensure = is symmetric.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate23.xml</input-file>
<input-file role="principal-stylesheet">predicate23.xsl</input-file>
<output-file role="principal" compare="XML">predicate23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate24">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to boolean with !=, boolean first.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate24.xml</input-file>
<input-file role="principal-stylesheet">predicate24.xsl</input-file>
<output-file role="principal" compare="XML">predicate24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate25">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to boolean with !=, boolean last.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate25.xml</input-file>
<input-file role="principal-stylesheet">predicate25.xsl</input-file>
<output-file role="principal" compare="XML">predicate25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate26">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number, ensure = is symmetric.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate26.xml</input-file>
<input-file role="principal-stylesheet">predicate26.xsl</input-file>
<output-file role="principal" compare="XML">predicate26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate27">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with a != relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate27.xml</input-file>
<input-file role="principal-stylesheet">predicate27.xsl</input-file>
<output-file role="principal" compare="XML">predicate27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate28">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with a != relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate28.xml</input-file>
<input-file role="principal-stylesheet">predicate28.xsl</input-file>
<output-file role="principal" compare="XML">predicate28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate29">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate29.xml</input-file>
<input-file role="principal-stylesheet">predicate29.xsl</input-file>
<output-file role="principal" compare="XML">predicate29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate30">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate30.xml</input-file>
<input-file role="principal-stylesheet">predicate30.xsl</input-file>
<output-file role="principal" compare="XML">predicate30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate31">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate31.xml</input-file>
<input-file role="principal-stylesheet">predicate31.xsl</input-file>
<output-file role="principal" compare="XML">predicate31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate32">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate32.xml</input-file>
<input-file role="principal-stylesheet">predicate32.xsl</input-file>
<output-file role="principal" compare="XML">predicate32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate33">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate33.xml</input-file>
<input-file role="principal-stylesheet">predicate33.xsl</input-file>
<output-file role="principal" compare="XML">predicate33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate34">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate34.xml</input-file>
<input-file role="principal-stylesheet">predicate34.xsl</input-file>
<output-file role="principal" compare="XML">predicate34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate35">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate35.xml</input-file>
<input-file role="principal-stylesheet">predicate35.xsl</input-file>
<output-file role="principal" compare="XML">predicate35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate36">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of association of inequality symbols.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate36.xml</input-file>
<input-file role="principal-stylesheet">predicate36.xsl</input-file>
<output-file role="principal" compare="XML">predicate36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate37">
<file-path>predicate</file-path>
<purpose>Show that we can limit match to non-empty elements.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate37.xml</input-file>
<input-file role="principal-stylesheet">predicate37.xsl</input-file>
<output-file role="principal" compare="XML">predicate37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate38">
<file-path>predicate</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Stress test of nested and multiple predicates. The production rules allow such nesting.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate38.xml</input-file>
<input-file role="principal-stylesheet">predicate38.xsl</input-file>
<output-file role="principal" compare="XML">predicate38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate39">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses the "child" axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate39.xml</input-file>
<input-file role="principal-stylesheet">predicate39.xsl</input-file>
<output-file role="principal" compare="XML">predicate39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate40">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses the "ancestor" axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate40.xml</input-file>
<input-file role="principal-stylesheet">predicate40.xsl</input-file>
<output-file role="principal" compare="XML">predicate40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate41">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses the "ancestor-or-self" axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate41.xml</input-file>
<input-file role="principal-stylesheet">predicate41.xsl</input-file>
<output-file role="principal" compare="XML">predicate41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate42">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses the "attribute" axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate42.xml</input-file>
<input-file role="principal-stylesheet">predicate42.xsl</input-file>
<output-file role="principal" compare="XML">predicate42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate43">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses the "descendant-or-self" axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate43.xml</input-file>
<input-file role="principal-stylesheet">predicate43.xsl</input-file>
<output-file role="principal" compare="XML">predicate43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate44">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses the "parent" axis.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate44.xml</input-file>
<input-file role="principal-stylesheet">predicate44.xsl</input-file>
<output-file role="principal" compare="XML">predicate44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate45">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses elaborate complex expressions</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate45.xml</input-file>
<input-file role="principal-stylesheet">predicate45.xsl</input-file>
<output-file role="principal" compare="XML">predicate45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate46">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that uses math functions.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate46.xml</input-file>
<input-file role="principal-stylesheet">predicate46.xsl</input-file>
<output-file role="principal" compare="XML">predicate46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate47">
<file-path>predicate</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>Test a predicate that only has a math function call.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate47.xml</input-file>
<input-file role="principal-stylesheet">predicate47.xsl</input-file>
<output-file role="principal" compare="XML">predicate47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate48">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test (a and b) combination of logical expressions in a predicate.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate48.xml</input-file>
<input-file role="principal-stylesheet">predicate48.xsl</input-file>
<output-file role="principal" compare="XML">predicate48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate49">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test ((a or b) and c) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate49.xml</input-file>
<input-file role="principal-stylesheet">predicate49.xsl</input-file>
<output-file role="principal" compare="XML">predicate49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate50">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test (a and (b or c) and d) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate50.xml</input-file>
<input-file role="principal-stylesheet">predicate50.xsl</input-file>
<output-file role="principal" compare="XML">predicate50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate51">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test (a and b or c and d) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate51.xml</input-file>
<input-file role="principal-stylesheet">predicate51.xsl</input-file>
<output-file role="principal" compare="XML">predicate51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate52">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test ((a and b) or (c and d)) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate52.xml</input-file>
<input-file role="principal-stylesheet">predicate52.xsl</input-file>
<output-file role="principal" compare="XML">predicate52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate53">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test (a or (b and c) or d) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate53.xml</input-file>
<input-file role="principal-stylesheet">predicate53.xsl</input-file>
<output-file role="principal" compare="XML">predicate53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate54">
<file-path>predicate</file-path>
<purpose>Test ((a or b) and (c or d)) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate54.xml</input-file>
<input-file role="principal-stylesheet">predicate54.xsl</input-file>
<output-file role="principal" compare="XML">predicate54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate55">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test (a or b and c or d) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate55.xml</input-file>
<input-file role="principal-stylesheet">predicate55.xsl</input-file>
<output-file role="principal" compare="XML">predicate55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate56">
<file-path>predicate</file-path>
<creator>Morten Jorgensen</creator>
<date>2001-11-08</date>
<purpose>Test (a or b or c) combination of logical expressions in a predicate</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate56.xml</input-file>
<input-file role="principal-stylesheet">predicate56.xsl</input-file>
<output-file role="principal" compare="XML">predicate56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate57">
<file-path>predicate</file-path>
<creator>David Marston, based on an idea by Mukund Raghavachari</creator>
<date>2001-11-08</date>
<purpose>Test use of count() in a predicate to count children.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate57.xml</input-file>
<input-file role="principal-stylesheet">predicate57.xsl</input-file>
<output-file role="principal" compare="XML">predicate57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="predicate_predicate58">
<file-path>predicate</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Compare non-existent attributes to ones containing the null string.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">predicate58.xml</input-file>
<input-file role="principal-stylesheet">predicate58.xsl</input-file>
<output-file role="principal" compare="XML">predicate58.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="processorinfo_processorinfo03">
<file-path>processorinfo</file-path>
<purpose>Test the xsl:vendor-url system property</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">processorinfo03.xml</input-file>
<input-file role="principal-stylesheet">processorinfo03.xsl</input-file>
<output-file role="principal" compare="XML">processorinfo03.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="reluri_reluri01">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri01.xml</input-file>
<input-file role="principal-stylesheet">reluri01.xsl</input-file>
<output-file role="principal" compare="XML">reluri01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri02">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri02.xml</input-file>
<input-file role="principal-stylesheet">reluri02.xsl</input-file>
<output-file role="principal" compare="XML">reluri02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri03">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri03.xml</input-file>
<input-file role="principal-stylesheet">reluri03.xsl</input-file>
<output-file role="principal" compare="XML">reluri03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri04">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri04.xml</input-file>
<input-file role="principal-stylesheet">reluri04.xsl</input-file>
<output-file role="principal" compare="XML">reluri04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri05">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri05.xml</input-file>
<input-file role="principal-stylesheet">reluri05.xsl</input-file>
<output-file role="principal" compare="XML">reluri05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri06">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri06.xml</input-file>
<input-file role="principal-stylesheet">reluri06.xsl</input-file>
<output-file role="principal" compare="XML">reluri06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri07">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri07.xml</input-file>
<input-file role="principal-stylesheet">reluri07.xsl</input-file>
<output-file role="principal" compare="XML">reluri07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri08">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>This test verifies correct URI resolution with relative URI's.</purpose>
<spec-citation place="3.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri08.xml</input-file>
<input-file role="principal-stylesheet">reluri08.xsl</input-file>
<output-file role="principal" compare="XML">reluri08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri09">
<file-path>reluri</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Testing document() function with two arguments: string, node-set: verifying that a relative URL specified in first argument is resolved based on base URI of document in second argument nodeset.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri09.xml</input-file>
<input-file role="principal-stylesheet">reluri09.xsl</input-file>
<output-file role="principal" compare="XML">reluri09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="reluri_reluri10">
<file-path>reluri</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Testing document() function with two arguments: node-set, node-set: verifying that a relative URL specified in first argument is resolved based on base URI of document in second argument nodeset.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri10.xml</input-file>
<input-file role="principal-stylesheet">reluri10.xsl</input-file>
<output-file role="principal" compare="XML">reluri10.out</output-file>
</scenario>
</test-case>
<!--
This test case expects wrong result.

    <xsl:copy-of select="document(document('level1/level2/xreluri11b.xml')/*/filename)/*/body"/>

XSLT spec 12.1:

If the second argument is omitted, then it defaults to the node ***in the stylesheet*** that contains the expression that includes the call to the document function.

<test-case category="XSLT-Result-Tree" id="reluri_reluri11">
<file-path>reluri</file-path>
<creator>Myriam Midy</creator>
<date>2001-11-08</date>
<purpose>Testing how a relative URI specified in document() is resolved by default.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">reluri11.xml</input-file>
<input-file role="principal-stylesheet">reluri11.xsl</input-file>
<output-file role="principal" compare="XML">reluri11.out</output-file>
</scenario>
</test-case>
-->
	<test-case category="XSLT-Result-Tree" id="select_select01">
<file-path>select</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for absolute path selection.</purpose>
<spec-citation place="2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select01.xml</input-file>
<input-file role="principal-stylesheet">select01.xsl</input-file>
<output-file role="principal" compare="XML">select01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select02">
<file-path>select</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of current() function - just select it.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select02.xml</input-file>
<input-file role="principal-stylesheet">select02.xsl</input-file>
<output-file role="principal" compare="XML">select02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select03">
<file-path>select</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for select in for-each and current().</purpose>
<spec-citation place="2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select03.xml</input-file>
<input-file role="principal-stylesheet">select03.xsl</input-file>
<output-file role="principal" compare="XML">select03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select04">
<file-path>select</file-path>
<purpose>Test of unions, returned in document order.</purpose>
<spec-citation place="2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select04.xml</input-file>
<input-file role="principal-stylesheet">select04.xsl</input-file>
<output-file role="principal" compare="XML">select04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select05">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for selecting parent nodes.</purpose>
<spec-citation place="2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select05.xml</input-file>
<input-file role="principal-stylesheet">select05.xsl</input-file>
<output-file role="principal" compare="XML">select05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select06">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test nesting of for-each.</purpose>
<spec-citation place="8" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select06.xml</input-file>
<input-file role="principal-stylesheet">select06.xsl</input-file>
<output-file role="principal" compare="XML">select06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select07">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to put out computed text without any tags.</purpose>
<spec-citation place="7.1.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select07.xml</input-file>
<input-file role="principal-stylesheet">select07.xsl</input-file>
<output-file role="principal" compare="XML">select07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select08">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test assignment of a node-set to a parameter, then use in select.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select08.xml</input-file>
<input-file role="principal-stylesheet">select08.xsl</input-file>
<output-file role="principal" compare="XML">select08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select09">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test assignment of a node-set to a local parameter, then use in select.</purpose>
<spec-citation place="11" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select09.xml</input-file>
<input-file role="principal-stylesheet">select09.xsl</input-file>
<output-file role="principal" compare="XML">select09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select10">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each with select expression in a global variable.</purpose>
<spec-citation place="8" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select10.xml</input-file>
<input-file role="principal-stylesheet">select10.xsl</input-file>
<output-file role="principal" compare="XML">select10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select11">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each with select expression in a local variable.</purpose>
<spec-citation place="8" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select11.xml</input-file>
<input-file role="principal-stylesheet">select11.xsl</input-file>
<output-file role="principal" compare="XML">select11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select12">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for select that comes up empty.</purpose>
<spec-citation place="2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select12.xml</input-file>
<input-file role="principal-stylesheet">select12.xsl</input-file>
<output-file role="principal" compare="XML">select12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select13">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that for-each doesn't care about current node</purpose>
<spec-citation place="8" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select13.xml</input-file>
<input-file role="principal-stylesheet">select13.xsl</input-file>
<output-file role="principal" compare="XML">select13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select14">
<file-path>select</file-path>
<creator>Carmelo Montanez, adapted by David Marston</creator>
<date>2001-11-08</date>
<purpose>Node-set union using mixed axes</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select14.xml</input-file>
<input-file role="principal-stylesheet">select14.xsl</input-file>
<output-file role="principal" compare="XML">select14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select15">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName followed by :: must be recognized as an AxisName.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select15.xml</input-file>
<input-file role="principal-stylesheet">select15.xsl</input-file>
<output-file role="principal" compare="XML">select15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select16">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName followed by :: must be recognized as an AxisName, even if there is intervening whitespace.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select16.xml</input-file>
<input-file role="principal-stylesheet">select16.xsl</input-file>
<output-file role="principal" compare="XML">select16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select17">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName followed by ( must be recognized as a NodeType or FunctionName.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select17.xml</input-file>
<input-file role="principal-stylesheet">select17.xsl</input-file>
<output-file role="principal" compare="XML">select17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select18">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName followed by ( must be recognized as a NodeType or FunctionName, even if there is intervening whitespace.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select18.xml</input-file>
<input-file role="principal-stylesheet">select18.xsl</input-file>
<output-file role="principal" compare="XML">select18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select19">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName followed by ( must be recognized as a NodeType or FunctionName.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select19.xml</input-file>
<input-file role="principal-stylesheet">select19.xsl</input-file>
<output-file role="principal" compare="XML">select19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select20">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName followed by ( must be recognized as a NodeType or FunctionName, even if there is intervening whitespace.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select20.xml</input-file>
<input-file role="principal-stylesheet">select20.xsl</input-file>
<output-file role="principal" compare="XML">select20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select21">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName as first item must not be treated as an operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select21.xml</input-file>
<input-file role="principal-stylesheet">select21.xsl</input-file>
<output-file role="principal" compare="XML">select21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select22">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>* as first item must not be treated as an operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select22.xml</input-file>
<input-file role="principal-stylesheet">select22.xsl</input-file>
<output-file role="principal" compare="XML">select22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select23">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after @ must not be treated as an operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select23.xml</input-file>
<input-file role="principal-stylesheet">select23.xsl</input-file>
<output-file role="principal" compare="XML">select23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select24">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after @ must not be treated as an operator; space after is questionable.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select24.xml</input-file>
<input-file role="principal-stylesheet">select24.xsl</input-file>
<output-file role="principal" compare="XML">select24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select25">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after @ must not be treated as an operator; lack of spaces around hyphen makes it part of name.</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select25.xml</input-file>
<input-file role="principal-stylesheet">select25.xsl</input-file>
<output-file role="principal" compare="XML">select25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select26">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>* after @ must be treated as all attributes</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select26.xml</input-file>
<input-file role="principal-stylesheet">select26.xsl</input-file>
<output-file role="principal" compare="XML">select26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select27">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after :: must be treated as part of path</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select27.xml</input-file>
<input-file role="principal-stylesheet">select27.xsl</input-file>
<output-file role="principal" compare="XML">select27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select28">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after :: must be treated as part of path</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select28.xml</input-file>
<input-file role="principal-stylesheet">select28.xsl</input-file>
<output-file role="principal" compare="XML">select28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select29">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after ( must not be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select29.xml</input-file>
<input-file role="principal-stylesheet">select29.xsl</input-file>
<output-file role="principal" compare="XML">select29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select30">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>* after ( must not be treated as operator, but * after ) is, and being tokenized means following * is not (because it follows an operator)</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select30.xml</input-file>
<input-file role="principal-stylesheet">select30.xsl</input-file>
<output-file role="principal" compare="XML">select30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select31">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after [ must not be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select31.xml</input-file>
<input-file role="principal-stylesheet">select31.xsl</input-file>
<output-file role="principal" compare="XML">select31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select32">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>* after [ must not be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select32.xml</input-file>
<input-file role="principal-stylesheet">select32.xsl</input-file>
<output-file role="principal" compare="XML">select32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select33">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NCName after operator must not be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select33.xml</input-file>
<input-file role="principal-stylesheet">select33.xsl</input-file>
<output-file role="principal" compare="XML">select33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select34">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>* after (ambiguous) operator must not be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select34.xml</input-file>
<input-file role="principal-stylesheet">select34.xsl</input-file>
<output-file role="principal" compare="XML">select34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select35">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>* after (named) operator must not be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select35.xml</input-file>
<input-file role="principal-stylesheet">select35.xsl</input-file>
<output-file role="principal" compare="XML">select35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select36">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>name after ) must be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select36.xml</input-file>
<input-file role="principal-stylesheet">select36.xsl</input-file>
<output-file role="principal" compare="XML">select36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select37">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>name after literal should be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select37.xml</input-file>
<input-file role="principal-stylesheet">select37.xsl</input-file>
<output-file role="principal" compare="XML">select37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select38">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>name after * should not be treated as operator</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select38.xml</input-file>
<input-file role="principal-stylesheet">select38.xsl</input-file>
<output-file role="principal" compare="XML">select38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select39">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>. after operator should be treated as path</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select39.xml</input-file>
<input-file role="principal-stylesheet">select39.xsl</input-file>
<output-file role="principal" compare="XML">select39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select40">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>* after operator should be treated as path</purpose>
<spec-citation place="3.7" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select40.xml</input-file>
<input-file role="principal-stylesheet">select40.xsl</input-file>
<output-file role="principal" compare="XML">select40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select41">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using two absolute location paths</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select41.xml</input-file>
<input-file role="principal-stylesheet">select41.xsl</input-file>
<output-file role="principal" compare="XML">select41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select42">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using absolute and relative location paths</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select42.xml</input-file>
<input-file role="principal-stylesheet">select42.xsl</input-file>
<output-file role="principal" compare="XML">select42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select43">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using the ancestor axis</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select43.xml</input-file>
<input-file role="principal-stylesheet">select43.xsl</input-file>
<output-file role="principal" compare="XML">select43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select44">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using the ancestor-or-self axis</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select44.xml</input-file>
<input-file role="principal-stylesheet">select44.xsl</input-file>
<output-file role="principal" compare="XML">select44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select45">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator using two paths with predicates.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select45.xml</input-file>
<input-file role="principal-stylesheet">select45.xsl</input-file>
<output-file role="principal" compare="XML">select45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select47">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using the child axis</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select47.xml</input-file>
<input-file role="principal-stylesheet">select47.xsl</input-file>
<output-file role="principal" compare="XML">select47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select48">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator on two paths, each with complex predicate.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select48.xml</input-file>
<input-file role="principal-stylesheet">select48.xsl</input-file>
<output-file role="principal" compare="XML">select48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select49">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using the descendant axis</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select49.xml</input-file>
<input-file role="principal-stylesheet">select49.xsl</input-file>
<output-file role="principal" compare="XML">select49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select50">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using the descendant-or-self axis</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select50.xml</input-file>
<input-file role="principal-stylesheet">select50.xsl</input-file>
<output-file role="principal" compare="XML">select50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select51">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator using predicates testing element and attribute nodes.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select51.xml</input-file>
<input-file role="principal-stylesheet">select51.xsl</input-file>
<output-file role="principal" compare="XML">select51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select52">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator where union yields empty set.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select52.xml</input-file>
<input-file role="principal-stylesheet">select52.xsl</input-file>
<output-file role="principal" compare="XML">select52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select53">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using the following-sibling and preceding-sibling axes</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select53.xml</input-file>
<input-file role="principal-stylesheet">select53.xsl</input-file>
<output-file role="principal" compare="XML">select53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select54">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using a function that returns a node set (key) and an axis.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select54.xml</input-file>
<input-file role="principal-stylesheet">select54.xsl</input-file>
<output-file role="principal" compare="XML">select54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select55">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using a function that returns a node set (key) as each term.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select55.xml</input-file>
<input-file role="principal-stylesheet">select55.xsl</input-file>
<output-file role="principal" compare="XML">select55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select56">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator at different nesting levels (same element)</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select56.xml</input-file>
<input-file role="principal-stylesheet">select56.xsl</input-file>
<output-file role="principal" compare="XML">select56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select57">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator at different nesting levels (different elements)</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select57.xml</input-file>
<input-file role="principal-stylesheet">select57.xsl</input-file>
<output-file role="principal" compare="XML">select57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select58">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator where one of the members is empty</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select58.xml</input-file>
<input-file role="principal-stylesheet">select58.xsl</input-file>
<output-file role="principal" compare="XML">select58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select59">
<file-path>select</file-path>
<creator>Carmelo Montanez (original)</creator>
<date>2001-11-08</date>
<creator>Paul Dick (this version)</creator>
<date>2001-11-08</date>
<purpose>test union operator using overlapping node-sets. Results should always be output in doc order regardless of order of select attribute.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select59.xml</input-file>
<input-file role="principal-stylesheet">select59.xsl</input-file>
<output-file role="principal" compare="XML">select59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select60">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using two relative location paths</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select60.xml</input-file>
<input-file role="principal-stylesheet">select60.xsl</input-file>
<output-file role="principal" compare="XML">select60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select61">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using the self axis</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select61.xml</input-file>
<input-file role="principal-stylesheet">select61.xsl</input-file>
<output-file role="principal" compare="XML">select61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select62">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>union of two absolute (//) paths</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select62.xml</input-file>
<input-file role="principal-stylesheet">select62.xsl</input-file>
<output-file role="principal" compare="XML">select62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select63">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator used three times in an expression</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select63.xml</input-file>
<input-file role="principal-stylesheet">select63.xsl</input-file>
<output-file role="principal" compare="XML">select63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select64">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator using a variable and a function.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select64.xml</input-file>
<input-file role="principal-stylesheet">select64.xsl</input-file>
<output-file role="principal" compare="XML">select64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select65">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator using a variable and an axis.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select65.xml</input-file>
<input-file role="principal-stylesheet">select65.xsl</input-file>
<output-file role="principal" compare="XML">select65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select66">
<file-path>select</file-path>
<creator>Carmelo Montanez</creator>
<date>2001-11-08</date>
<purpose>test union operator using variables.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select66.xml</input-file>
<input-file role="principal-stylesheet">select66.xsl</input-file>
<output-file role="principal" compare="XML">select66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select67">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that document('') refers to this stylesheet, and exploit that fact to choose a template dynamically. Idea from Mike Kay.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select67.xml</input-file>
<input-file role="principal-stylesheet">select67.xsl</input-file>
<output-file role="principal" compare="XML">select67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select68">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that document('') refers to this stylesheet, and exploit that fact to have data file select which template to use.</purpose>
<spec-citation place="12.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select68.xml</input-file>
<input-file role="principal-stylesheet">select68.xsl</input-file>
<output-file role="principal" compare="XML">select68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select69">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test whether null string as attribute value causes selection problem.</purpose>
<spec-citation place="2.4" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select69.xml</input-file>
<input-file role="principal-stylesheet">select69.xsl</input-file>
<output-file role="principal" compare="XML">select69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select70">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that current() produces a node-set.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select70.xml</input-file>
<input-file role="principal-stylesheet">select70.xsl</input-file>
<output-file role="principal" compare="XML">select70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select71">
<file-path>select</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test union operator using overlapping node-sets. Results should always be output in doc order regardless of order of select attribute.</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select71.xml</input-file>
<input-file role="principal-stylesheet">select71.xsl</input-file>
<output-file role="principal" compare="XML">select71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select72">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>NodeSet union using two copies of same node, and variables</purpose>
<spec-citation place="3.3" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">select72.xml</input-file>
<input-file role="principal-stylesheet">select72.xsl</input-file>
<output-file role="principal" compare="XML">select72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select73">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that entity does not cause splitting of one text node into many.</purpose>
<spec-citation place="2.3" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select73.xml</input-file>
<input-file role="principal-stylesheet">select73.xsl</input-file>
<output-file role="principal" compare="XML">select73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select74">
<file-path>select</file-path>
<purpose>Test for-each example from XSLT spec.</purpose>
<spec-citation place="8" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select74.xml</input-file>
<input-file role="principal-stylesheet">select74.xsl</input-file>
<output-file role="principal" compare="XML">select74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select75">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that select='/' gets what it should.</purpose>
<spec-citation place="5.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select75.xml</input-file>
<input-file role="principal-stylesheet">select75.xsl</input-file>
<output-file role="principal" compare="XML">select75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select76">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try /{name} to match the document element.</purpose>
<spec-citation place="5.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select76.xml</input-file>
<input-file role="principal-stylesheet">select76.xsl</input-file>
<output-file role="principal" compare="XML">select76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select77">
<file-path>select</file-path>
<creator>Chris McCabe</creator>
<date>2001-11-08</date>
<purpose>Try to select a non-existent attribute out of a node-set variable</purpose>
<spec-citation place="5.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select77.xml</input-file>
<input-file role="principal-stylesheet">select77.xsl</input-file>
<output-file role="principal" compare="XML">select77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select78">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Simple test of current() in for-each.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select78.xml</input-file>
<input-file role="principal-stylesheet">select78.xsl</input-file>
<output-file role="principal" compare="XML">select78.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select79">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Simple test of current() in apply-templates.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select79.xml</input-file>
<input-file role="principal-stylesheet">select79.xsl</input-file>
<output-file role="principal" compare="XML">select79.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select80">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try a positional predicate on descendants of a node-set variable</purpose>
<spec-citation place="8" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select80.xml</input-file>
<input-file role="principal-stylesheet">select80.xsl</input-file>
<output-file role="principal" compare="XML">select80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select81">
<file-path>select</file-path>
<creator>Joe Kesselman</creator>
<date>2001-11-08</date>
<purpose>Try absolute path when current node is in middle of tree</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select81.xml</input-file>
<input-file role="principal-stylesheet">select81.xsl</input-file>
<output-file role="principal" compare="XML">select81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select82">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test //* to get all elements</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select82.xml</input-file>
<input-file role="principal-stylesheet">select82.xsl</input-file>
<output-file role="principal" compare="XML">select82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select83">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test //@x to get all attributes of a certain name</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select83.xml</input-file>
<input-file role="principal-stylesheet">select83.xsl</input-file>
<output-file role="principal" compare="XML">select83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select84">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test //@* to get all attributes in the tree</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">select84.xml</input-file>
<input-file role="principal-stylesheet">select84.xsl</input-file>
<output-file role="principal" compare="XML">select84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select85">
<file-path>select</file-path>
<creator>Henry Zongaro</creator>
<date>2001-11-08</date>
<purpose>Test current() by itself in a predicate.</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select85.xml</input-file>
<input-file role="principal-stylesheet">select85.xsl</input-file>
<output-file role="principal" compare="XML">select85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="select_select86">
<file-path>select</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that current() returns a node-set suitable for count().</purpose>
<spec-citation place="12.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">select86.xml</input-file>
<input-file role="principal-stylesheet">select86.xsl</input-file>
<output-file role="principal" compare="XML">select86.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="sort_sort01">
<file-path>sort</file-path>
<purpose>Simple test for xsl:sort on numbers, default order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort01.xml</input-file>
<input-file role="principal-stylesheet">sort01.xsl</input-file>
<output-file role="principal" compare="XML">sort01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort02">
<file-path>sort</file-path>
<purpose>Test for xsl:sort on strings without specifying data-type or order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort02.xml</input-file>
<input-file role="principal-stylesheet">sort02.xsl</input-file>
<output-file role="principal" compare="XML">sort02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort03">
<file-path>sort</file-path>
<purpose>Test for xsl:sort on a descendant element.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort03.xml</input-file>
<input-file role="principal-stylesheet">sort03.xsl</input-file>
<output-file role="principal" compare="XML">sort03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort04">
<file-path>sort</file-path>
<purpose>Test for xsl:sort and value-of the same element in the same loop.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort04.xml</input-file>
<input-file role="principal-stylesheet">sort04.xsl</input-file>
<output-file role="principal" compare="XML">sort04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort05">
<file-path>sort</file-path>
<purpose>Test for xsl:sort on a descendant element with no order specified.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort05.xml</input-file>
<input-file role="principal-stylesheet">sort05.xsl</input-file>
<output-file role="principal" compare="XML">sort05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort06">
<file-path>sort</file-path>
<purpose>Test for 2 xsl:sort elements with different sequence than SORT05.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort06.xml</input-file>
<input-file role="principal-stylesheet">sort06.xsl</input-file>
<output-file role="principal" compare="XML">sort06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort07">
<file-path>sort</file-path>
<purpose>Test for xsl:sort on a different element (not always present) which should have tie-breakers.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort07.xml</input-file>
<input-file role="principal-stylesheet">sort07.xsl</input-file>
<output-file role="principal" compare="XML">sort07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort08">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on letters and spaces.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort08.xml</input-file>
<input-file role="principal-stylesheet">sort08.xsl</input-file>
<output-file role="principal" compare="XML">sort08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort09">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Simple test for xsl:sort on numbers, descending order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort09.xml</input-file>
<input-file role="principal-stylesheet">sort09.xsl</input-file>
<output-file role="principal" compare="XML">sort09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort10">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on strings without specifying data-type, descending order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort10.xml</input-file>
<input-file role="principal-stylesheet">sort10.xsl</input-file>
<output-file role="principal" compare="XML">sort10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort11">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Sort strings that all can be numbers without specifying data-type or order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort11.xml</input-file>
<input-file role="principal-stylesheet">sort11.xsl</input-file>
<output-file role="principal" compare="XML">sort11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort12">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Sort numbers with leading zeroes and decimal points.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort12.xml</input-file>
<input-file role="principal-stylesheet">sort12.xsl</input-file>
<output-file role="principal" compare="XML">sort12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort13">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Numeric sort, all items that aren't true numbers should cluster together.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort13.xml</input-file>
<input-file role="principal-stylesheet">sort13.xsl</input-file>
<output-file role="principal" compare="XML">sort13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort14">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on strings without specifying case-order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort14.xml</input-file>
<input-file role="principal-stylesheet">sort14.xsl</input-file>
<output-file role="principal" compare="XML">sort14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort15">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on strings, upper-first case-order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort15.xml</input-file>
<input-file role="principal-stylesheet">sort15.xsl</input-file>
<output-file role="principal" compare="XML">sort15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort16">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on strings, lower-first case-order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort16.xml</input-file>
<input-file role="principal-stylesheet">sort16.xsl</input-file>
<output-file role="principal" compare="XML">sort16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort20">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test that lang has no effect on numeric data.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort20.xml</input-file>
<input-file role="principal-stylesheet">sort20.xsl</input-file>
<output-file role="principal" compare="XML">sort20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort21">
<file-path>sort</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort using a numeric expression for the select.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort21.xml</input-file>
<input-file role="principal-stylesheet">sort21.xsl</input-file>
<output-file role="principal" compare="XML">sort21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort22">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort using a string function for the select.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort22.xml</input-file>
<input-file role="principal-stylesheet">sort22.xsl</input-file>
<output-file role="principal" compare="XML">sort22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort23">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort using a numeric expression for the select.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort23.xml</input-file>
<input-file role="principal-stylesheet">sort23.xsl</input-file>
<output-file role="principal" compare="XML">sort23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort24">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort using a numeric expression for the select.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort24.xml</input-file>
<input-file role="principal-stylesheet">sort24.xsl</input-file>
<output-file role="principal" compare="XML">sort24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort25">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Reverse the order of the nodes using an expression that is reliable.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort25.xml</input-file>
<input-file role="principal-stylesheet">sort25.xsl</input-file>
<output-file role="principal" compare="XML">sort25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort26">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on apply-templates that does not have a select attribute.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort26.xml</input-file>
<input-file role="principal-stylesheet">sort26.xsl</input-file>
<output-file role="principal" compare="XML">sort26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort27">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on apply-templates that will get text and element children.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort27.xml</input-file>
<input-file role="principal-stylesheet">sort27.xsl</input-file>
<output-file role="principal" compare="XML">sort27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort28">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort on apply-templates without select, numeric sort.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort28.xml</input-file>
<input-file role="principal-stylesheet">sort28.xsl</input-file>
<output-file role="principal" compare="XML">sort28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort29">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort using a variable in the select, for-each loop.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort29.xml</input-file>
<input-file role="principal-stylesheet">sort29.xsl</input-file>
<output-file role="principal" compare="XML">sort29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort30">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort using a local variable in the select, apply-templates.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort30.xml</input-file>
<input-file role="principal-stylesheet">sort30.xsl</input-file>
<output-file role="principal" compare="XML">sort30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort31">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for xsl:sort using a global variable in the select, apply-templates.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort31.xml</input-file>
<input-file role="principal-stylesheet">sort31.xsl</input-file>
<output-file role="principal" compare="XML">sort31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort32">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to set data-type from a variable.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort32.xml</input-file>
<input-file role="principal-stylesheet">sort32.xsl</input-file>
<output-file role="principal" compare="XML">sort32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort33">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to set order from a variable.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort33.xml</input-file>
<input-file role="principal-stylesheet">sort33.xsl</input-file>
<output-file role="principal" compare="XML">sort33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort34">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to set case-order from a variable.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort34.xml</input-file>
<input-file role="principal-stylesheet">sort34.xsl</input-file>
<output-file role="principal" compare="XML">sort34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort35">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test the famous technique for choosing the sort key dynamically.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort35.xml</input-file>
<input-file role="principal-stylesheet">sort35.xsl</input-file>
<output-file role="principal" compare="XML">sort35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort36">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test the famous technique for sorting with conditionals. In this case, we want to sort strings with and without "Re: " prefix by the rest of the string. Technique from Oliver Becker (obecker@informatik.hu-berlin.de).</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort36.xml</input-file>
<input-file role="principal-stylesheet">sort36.xsl</input-file>
<output-file role="principal" compare="XML">sort36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort37">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>If nothing comes through select, should get document order.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort37.xml</input-file>
<input-file role="principal-stylesheet">sort37.xsl</input-file>
<output-file role="principal" compare="XML">sort37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort38">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Numeric sort, but no items are true numbers.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort38.xml</input-file>
<input-file role="principal-stylesheet">sort38.xsl</input-file>
<output-file role="principal" compare="XML">sort38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort39">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to set lang from an expression.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort39.xml</input-file>
<input-file role="principal-stylesheet">sort39.xsl</input-file>
<output-file role="principal" compare="XML">sort39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="sort_sort40">
<file-path>sort</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Loop over a node-set in for-each and sort the nodes.</purpose>
<spec-citation place="10" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">sort40.xml</input-file>
<input-file role="principal-stylesheet">sort40.xsl</input-file>
<output-file role="principal" compare="XML">sort40.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="string_string01">
<file-path>string</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of string-length() on literal string.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string01.xml</input-file>
<input-file role="principal-stylesheet">string01.xsl</input-file>
<output-file role="principal" compare="XML">string01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string02">
<file-path>string</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of string-length() of element node</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string02.xml</input-file>
<input-file role="principal-stylesheet">string02.xsl</input-file>
<output-file role="principal" compare="XML">string02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string04">
<file-path>string</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of string-length() without arguments, and with node path.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string04.xml</input-file>
<input-file role="principal-stylesheet">string04.xsl</input-file>
<output-file role="principal" compare="XML">string04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string05">
<file-path>string</file-path>
<purpose>Test of 'string()' conversion w/ element node</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string05.xml</input-file>
<input-file role="principal-stylesheet">string05.xsl</input-file>
<output-file role="principal" compare="XML">string05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string06">
<file-path>string</file-path>
<purpose>Test of 'starts-with()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string06.xml</input-file>
<input-file role="principal-stylesheet">string06.xsl</input-file>
<output-file role="principal" compare="XML">string06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string07">
<file-path>string</file-path>
<purpose>Test of 'contains()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string07.xml</input-file>
<input-file role="principal-stylesheet">string07.xsl</input-file>
<output-file role="principal" compare="XML">string07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string08">
<file-path>string</file-path>
<purpose>Test of 'substring-before()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string08.xml</input-file>
<input-file role="principal-stylesheet">string08.xsl</input-file>
<output-file role="principal" compare="XML">string08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string09">
<file-path>string</file-path>
<purpose>Test of 'substring-after()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string09.xml</input-file>
<input-file role="principal-stylesheet">string09.xsl</input-file>
<output-file role="principal" compare="XML">string09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string10">
<file-path>string</file-path>
<purpose>Test of 'normalize-space()' function</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string10.xml</input-file>
<input-file role="principal-stylesheet">string10.xsl</input-file>
<output-file role="principal" compare="XML">string10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string11">
<file-path>string</file-path>
<purpose>Test of 'translate()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string11.xml</input-file>
<input-file role="principal-stylesheet">string11.xsl</input-file>
<output-file role="principal" compare="XML">string11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string12">
<file-path>string</file-path>
<purpose>Test of 'concat()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string12.xml</input-file>
<input-file role="principal-stylesheet">string12.xsl</input-file>
<output-file role="principal" compare="XML">string12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string13">
<file-path>string</file-path>
<purpose>Test of 'format-number()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string13.xml</input-file>
<input-file role="principal-stylesheet">string13.xsl</input-file>
<output-file role="principal" compare="XML">string13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string14">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of string() conversion on a variable containing a node-set</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string14.xml</input-file>
<input-file role="principal-stylesheet">string14.xsl</input-file>
<output-file role="principal" compare="XML">string14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string15">
<file-path>string</file-path>
<purpose>Test of 'substring()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string15.xml</input-file>
<input-file role="principal-stylesheet">string15.xsl</input-file>
<output-file role="principal" compare="XML">string15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string16">
<file-path>string</file-path>
<purpose>Test of 'substring()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string16.xml</input-file>
<input-file role="principal-stylesheet">string16.xsl</input-file>
<output-file role="principal" compare="XML">string16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string17">
<file-path>string</file-path>
<purpose>Test of 'substring()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string17.xml</input-file>
<input-file role="principal-stylesheet">string17.xsl</input-file>
<output-file role="principal" compare="XML">string17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string18">
<file-path>string</file-path>
<purpose>Test of 'substring()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string18.xml</input-file>
<input-file role="principal-stylesheet">string18.xsl</input-file>
<output-file role="principal" compare="XML">string18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string19">
<file-path>string</file-path>
<purpose>Test of 'substring()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string19.xml</input-file>
<input-file role="principal-stylesheet">string19.xsl</input-file>
<output-file role="principal" compare="XML">string19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string20">
<file-path>string</file-path>
<purpose>Test of 'substring()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string20.xml</input-file>
<input-file role="principal-stylesheet">string20.xsl</input-file>
<output-file role="principal" compare="XML">string20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string21">
<file-path>string</file-path>
<purpose>Test of 'substring()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string21.xml</input-file>
<input-file role="principal-stylesheet">string21.xsl</input-file>
<output-file role="principal" compare="XML">string21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string22">
<file-path>string</file-path>
<purpose>Test of 'substring()' function on non-existent node</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string22.xml</input-file>
<input-file role="principal-stylesheet">string22.xsl</input-file>
<output-file role="principal" compare="XML">string22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string30">
<file-path>string</file-path>
<purpose>Test of 'namespace-uri()'.</purpose>
<spec-citation place="4.1" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string30.xml</input-file>
<input-file role="principal-stylesheet">string30.xsl</input-file>
<output-file role="principal" compare="XML">string30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string31">
<file-path>string</file-path>
<spec-citation place="" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">string31.xml</input-file>
<input-file role="principal-stylesheet">string31.xsl</input-file>
<output-file role="principal" compare="XML">string31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string32">
<file-path>string</file-path>
<spec-citation place="" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">string32.xml</input-file>
<input-file role="principal-stylesheet">string32.xsl</input-file>
<output-file role="principal" compare="XML">string32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string33">
<file-path>string</file-path>
<spec-citation place="" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">string33.xml</input-file>
<input-file role="principal-stylesheet">string33.xsl</input-file>
<output-file role="principal" compare="XML">string33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string34">
<file-path>string</file-path>
<spec-citation place="" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">string34.xml</input-file>
<input-file role="principal-stylesheet">string34.xsl</input-file>
<output-file role="principal" compare="XML">string34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string35">
<file-path>string</file-path>
<spec-citation place="" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">string35.xml</input-file>
<input-file role="principal-stylesheet">string35.xsl</input-file>
<output-file role="principal" compare="XML">string35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string36">
<file-path>string</file-path>
<spec-citation place="" type="section" version="1.0" spec="ooops!"/>
<scenario operation="standard">
<input-file role="principal-data">string36.xml</input-file>
<input-file role="principal-stylesheet">string36.xsl</input-file>
<output-file role="principal" compare="XML">string36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string37">
<file-path>string</file-path>
<purpose>Test of 'string()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string37.xml</input-file>
<input-file role="principal-stylesheet">string37.xsl</input-file>
<output-file role="principal" compare="XML">string37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string38">
<file-path>string</file-path>
<purpose>Test of 'string()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string38.xml</input-file>
<input-file role="principal-stylesheet">string38.xsl</input-file>
<output-file role="principal" compare="XML">string38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string39">
<file-path>string</file-path>
<purpose>Test of 'string()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string39.xml</input-file>
<input-file role="principal-stylesheet">string39.xsl</input-file>
<output-file role="principal" compare="XML">string39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string40">
<file-path>string</file-path>
<purpose>Test of 'string()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string40.xml</input-file>
<input-file role="principal-stylesheet">string40.xsl</input-file>
<output-file role="principal" compare="XML">string40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string41">
<file-path>string</file-path>
<purpose>Test of 'string()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string41.xml</input-file>
<input-file role="principal-stylesheet">string41.xsl</input-file>
<output-file role="principal" compare="XML">string41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string42">
<file-path>string</file-path>
<purpose>Test of 'string()' function on a simple RTF.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string42.xml</input-file>
<input-file role="principal-stylesheet">string42.xsl</input-file>
<output-file role="principal" compare="XML">string42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string43">
<file-path>string</file-path>
<purpose>Test of 'string()' function with empty RTF.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string43.xml</input-file>
<input-file role="principal-stylesheet">string43.xsl</input-file>
<output-file role="principal" compare="XML">string43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string44">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string44.xml</input-file>
<input-file role="principal-stylesheet">string44.xsl</input-file>
<output-file role="principal" compare="XML">string44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string45">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string45.xml</input-file>
<input-file role="principal-stylesheet">string45.xsl</input-file>
<output-file role="principal" compare="XML">string45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string46">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string46.xml</input-file>
<input-file role="principal-stylesheet">string46.xsl</input-file>
<output-file role="principal" compare="XML">string46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string47">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string47.xml</input-file>
<input-file role="principal-stylesheet">string47.xsl</input-file>
<output-file role="principal" compare="XML">string47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string48">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string48.xml</input-file>
<input-file role="principal-stylesheet">string48.xsl</input-file>
<output-file role="principal" compare="XML">string48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string49">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string49.xml</input-file>
<input-file role="principal-stylesheet">string49.xsl</input-file>
<output-file role="principal" compare="XML">string49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string50">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string50.xml</input-file>
<input-file role="principal-stylesheet">string50.xsl</input-file>
<output-file role="principal" compare="XML">string50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string51">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function with node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string51.xml</input-file>
<input-file role="principal-stylesheet">string51.xsl</input-file>
<output-file role="principal" compare="XML">string51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string52">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function with node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string52.xml</input-file>
<input-file role="principal-stylesheet">string52.xsl</input-file>
<output-file role="principal" compare="XML">string52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string53">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function w/ attribute.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string53.xml</input-file>
<input-file role="principal-stylesheet">string53.xsl</input-file>
<output-file role="principal" compare="XML">string53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string54">
<file-path>string</file-path>
<purpose>Test of 'starts-with()' function with attribute.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string54.xml</input-file>
<input-file role="principal-stylesheet">string54.xsl</input-file>
<output-file role="principal" compare="XML">string54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string55">
<file-path>string</file-path>
<purpose>Test of 'contains()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string55.xml</input-file>
<input-file role="principal-stylesheet">string55.xsl</input-file>
<output-file role="principal" compare="XML">string55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string56">
<file-path>string</file-path>
<purpose>Test of 'contains()' function using variables.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string56.xml</input-file>
<input-file role="principal-stylesheet">string56.xsl</input-file>
<output-file role="principal" compare="XML">string56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string57">
<file-path>string</file-path>
<purpose>Test of 'contains()' function using expressions.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string57.xml</input-file>
<input-file role="principal-stylesheet">string57.xsl</input-file>
<output-file role="principal" compare="XML">string57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string58">
<file-path>string</file-path>
<purpose>Test of 'contains()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string58.xml</input-file>
<input-file role="principal-stylesheet">string58.xsl</input-file>
<output-file role="principal" compare="XML">string58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string59">
<file-path>string</file-path>
<purpose>Test of 'contains()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string59.xml</input-file>
<input-file role="principal-stylesheet">string59.xsl</input-file>
<output-file role="principal" compare="XML">string59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string60">
<file-path>string</file-path>
<purpose>Test of 'contains()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string60.xml</input-file>
<input-file role="principal-stylesheet">string60.xsl</input-file>
<output-file role="principal" compare="XML">string60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string61">
<file-path>string</file-path>
<purpose>Test of 'contains()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string61.xml</input-file>
<input-file role="principal-stylesheet">string61.xsl</input-file>
<output-file role="principal" compare="XML">string61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string62">
<file-path>string</file-path>
<purpose>Test of 'contains()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string62.xml</input-file>
<input-file role="principal-stylesheet">string62.xsl</input-file>
<output-file role="principal" compare="XML">string62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string63">
<file-path>string</file-path>
<purpose>Test of 'contains()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string63.xml</input-file>
<input-file role="principal-stylesheet">string63.xsl</input-file>
<output-file role="principal" compare="XML">string63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string64">
<file-path>string</file-path>
<purpose>Test of 'contains()' function with node as 1st argument, string is in it.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string64.xml</input-file>
<input-file role="principal-stylesheet">string64.xsl</input-file>
<output-file role="principal" compare="XML">string64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string65">
<file-path>string</file-path>
<purpose>Test of 'contains()' function with node as 1st argument, string is not in it.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string65.xml</input-file>
<input-file role="principal-stylesheet">string65.xsl</input-file>
<output-file role="principal" compare="XML">string65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string66">
<file-path>string</file-path>
<purpose>Test of 'contains()' function with attribute as 1st argument, string is in it.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string66.xml</input-file>
<input-file role="principal-stylesheet">string66.xsl</input-file>
<output-file role="principal" compare="XML">string66.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string67">
<file-path>string</file-path>
<purpose>Test of 'contains()' function with attribute as 1st argument, string is not in it.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string67.xml</input-file>
<input-file role="principal-stylesheet">string67.xsl</input-file>
<output-file role="principal" compare="XML">string67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string68">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string68.xml</input-file>
<input-file role="principal-stylesheet">string68.xsl</input-file>
<output-file role="principal" compare="XML">string68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string69">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string69.xml</input-file>
<input-file role="principal-stylesheet">string69.xsl</input-file>
<output-file role="principal" compare="XML">string69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string70">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string70.xml</input-file>
<input-file role="principal-stylesheet">string70.xsl</input-file>
<output-file role="principal" compare="XML">string70.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string71">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function with node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string71.xml</input-file>
<input-file role="principal-stylesheet">string71.xsl</input-file>
<output-file role="principal" compare="XML">string71.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string72">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function with empty node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string72.xml</input-file>
<input-file role="principal-stylesheet">string72.xsl</input-file>
<output-file role="principal" compare="XML">string72.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string73">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function with attribute.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string73.xml</input-file>
<input-file role="principal-stylesheet">string73.xsl</input-file>
<output-file role="principal" compare="XML">string73.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string74">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function with attribute.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string74.xml</input-file>
<input-file role="principal-stylesheet">string74.xsl</input-file>
<output-file role="principal" compare="XML">string74.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string75">
<file-path>string</file-path>
<purpose>Test of 'substring-before()' function with attribute.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string75.xml</input-file>
<input-file role="principal-stylesheet">string75.xsl</input-file>
<output-file role="principal" compare="XML">string75.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string76">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string76.xml</input-file>
<input-file role="principal-stylesheet">string76.xsl</input-file>
<output-file role="principal" compare="XML">string76.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string77">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string77.xml</input-file>
<input-file role="principal-stylesheet">string77.xsl</input-file>
<output-file role="principal" compare="XML">string77.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string78">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string78.xml</input-file>
<input-file role="principal-stylesheet">string78.xsl</input-file>
<output-file role="principal" compare="XML">string78.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string79">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string79.xml</input-file>
<input-file role="principal-stylesheet">string79.xsl</input-file>
<output-file role="principal" compare="XML">string79.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string80">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function with node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string80.xml</input-file>
<input-file role="principal-stylesheet">string80.xsl</input-file>
<output-file role="principal" compare="XML">string80.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string81">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function with empty node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string81.xml</input-file>
<input-file role="principal-stylesheet">string81.xsl</input-file>
<output-file role="principal" compare="XML">string81.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string82">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function with attribute</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string82.xml</input-file>
<input-file role="principal-stylesheet">string82.xsl</input-file>
<output-file role="principal" compare="XML">string82.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string83">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function with attribute.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string83.xml</input-file>
<input-file role="principal-stylesheet">string83.xsl</input-file>
<output-file role="principal" compare="XML">string83.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string84">
<file-path>string</file-path>
<purpose>Test of 'substring-after()' function with attribute.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string84.xml</input-file>
<input-file role="principal-stylesheet">string84.xsl</input-file>
<output-file role="principal" compare="XML">string84.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string85">
<file-path>string</file-path>
<purpose>Test of 'normalize-space()' function with node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string85.xml</input-file>
<input-file role="principal-stylesheet">string85.xsl</input-file>
<output-file role="principal" compare="XML">string85.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string86">
<file-path>string</file-path>
<purpose>Test of 'normaliz-space()' function with empty node.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string86.xml</input-file>
<input-file role="principal-stylesheet">string86.xsl</input-file>
<output-file role="principal" compare="XML">string86.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string87">
<file-path>string</file-path>
<purpose>Test of 'translate()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string87.xml</input-file>
<input-file role="principal-stylesheet">string87.xsl</input-file>
<output-file role="principal" compare="XML">string87.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string88">
<file-path>string</file-path>
<purpose>Test of 'translate()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string88.xml</input-file>
<input-file role="principal-stylesheet">string88.xsl</input-file>
<output-file role="principal" compare="XML">string88.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string89">
<file-path>string</file-path>
<purpose>Test of 'translate()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string89.xml</input-file>
<input-file role="principal-stylesheet">string89.xsl</input-file>
<output-file role="principal" compare="XML">string89.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string90">
<file-path>string</file-path>
<purpose>Test of 'translate()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string90.xml</input-file>
<input-file role="principal-stylesheet">string90.xsl</input-file>
<output-file role="principal" compare="XML">string90.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string91">
<file-path>string</file-path>
<purpose>Test of 'translate()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string91.xml</input-file>
<input-file role="principal-stylesheet">string91.xsl</input-file>
<output-file role="principal" compare="XML">string91.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string92">
<file-path>string</file-path>
<purpose>Test of 'translate()' function with attributes.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string92.xml</input-file>
<input-file role="principal-stylesheet">string92.xsl</input-file>
<output-file role="principal" compare="XML">string92.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string93">
<file-path>string</file-path>
<purpose>Test of 'translate()' function with attributes.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string93.xml</input-file>
<input-file role="principal-stylesheet">string93.xsl</input-file>
<output-file role="principal" compare="XML">string93.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string94">
<file-path>string</file-path>
<purpose>Test of 'translate()' function with attributes.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string94.xml</input-file>
<input-file role="principal-stylesheet">string94.xsl</input-file>
<output-file role="principal" compare="XML">string94.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string95">
<file-path>string</file-path>
<purpose>Test of 'translate()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string95.xml</input-file>
<input-file role="principal-stylesheet">string95.xsl</input-file>
<output-file role="principal" compare="XML">string95.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string96">
<file-path>string</file-path>
<purpose>Test of 'translate()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string96.xml</input-file>
<input-file role="principal-stylesheet">string96.xsl</input-file>
<output-file role="principal" compare="XML">string96.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string97">
<file-path>string</file-path>
<purpose>Test of 'concat()' function.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string97.xml</input-file>
<input-file role="principal-stylesheet">string97.xsl</input-file>
<output-file role="principal" compare="XML">string97.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string98">
<file-path>string</file-path>
<purpose>Test of 'concat()' function with nodes.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string98.xml</input-file>
<input-file role="principal-stylesheet">string98.xsl</input-file>
<output-file role="principal" compare="XML">string98.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string99">
<file-path>string</file-path>
<purpose>Test of 'concat()' function with nodes.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string99.xml</input-file>
<input-file role="principal-stylesheet">string99.xsl</input-file>
<output-file role="principal" compare="XML">string99.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string100">
<file-path>string</file-path>
<purpose>Test of 'concat()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string100.xml</input-file>
<input-file role="principal-stylesheet">string100.xsl</input-file>
<output-file role="principal" compare="XML">string100.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string101">
<file-path>string</file-path>
<purpose>Test of 'concat()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string101.xml</input-file>
<input-file role="principal-stylesheet">string101.xsl</input-file>
<output-file role="principal" compare="XML">string101.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string102">
<file-path>string</file-path>
<purpose>Test of concat() on entities and expressions</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string102.xml</input-file>
<input-file role="principal-stylesheet">string102.xsl</input-file>
<output-file role="principal" compare="XML">string102.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string103">
<file-path>string</file-path>
<purpose>Test of 'concat()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string103.xml</input-file>
<input-file role="principal-stylesheet">string103.xsl</input-file>
<output-file role="principal" compare="XML">string103.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string104">
<file-path>string</file-path>
<purpose>Test of 'concat()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string104.xml</input-file>
<input-file role="principal-stylesheet">string104.xsl</input-file>
<output-file role="principal" compare="XML">string104.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string105">
<file-path>string</file-path>
<purpose>Special case of concat() with one argument. Strictly speaking, this should fail just like STRerr14.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string105.xml</input-file>
<input-file role="principal-stylesheet">string105.xsl</input-file>
<output-file role="principal" compare="XML">string105.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string106">
<file-path>string</file-path>
<purpose>Test of 'format-number()'</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">string106.xml</input-file>
<input-file role="principal-stylesheet">string106.xsl</input-file>
<output-file role="principal" compare="XML">string106.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string107">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of string() function on an RTF with sub-nodes.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string107.xml</input-file>
<input-file role="principal-stylesheet">string107.xsl</input-file>
<output-file role="principal" compare="XML">string107.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string108">
<file-path>string</file-path>
<purpose>Test of 'format-number()'</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">string108.xml</input-file>
<input-file role="principal-stylesheet">string108.xsl</input-file>
<output-file role="principal" compare="XML">string108.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string109">
<file-path>string</file-path>
<purpose>Test of 'format-number()'</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">string109.xml</input-file>
<input-file role="principal-stylesheet">string109.xsl</input-file>
<output-file role="principal" compare="XML">string109.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string110">
<file-path>string</file-path>
<purpose>Test of 'format-number()'</purpose>
<spec-citation place="12.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">string110.xml</input-file>
<input-file role="principal-stylesheet">string110.xsl</input-file>
<output-file role="principal" compare="XML">string110.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string111">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string111.xml</input-file>
<input-file role="principal-stylesheet">string111.xsl</input-file>
<output-file role="principal" compare="XML">string111.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string112">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string112.xml</input-file>
<input-file role="principal-stylesheet">string112.xsl</input-file>
<output-file role="principal" compare="XML">string112.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string113">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string113.xml</input-file>
<input-file role="principal-stylesheet">string113.xsl</input-file>
<output-file role="principal" compare="XML">string113.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string114">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string114.xml</input-file>
<input-file role="principal-stylesheet">string114.xsl</input-file>
<output-file role="principal" compare="XML">string114.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string115">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string115.xml</input-file>
<input-file role="principal-stylesheet">string115.xsl</input-file>
<output-file role="principal" compare="XML">string115.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string116">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string116.xml</input-file>
<input-file role="principal-stylesheet">string116.xsl</input-file>
<output-file role="principal" compare="XML">string116.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string117">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string117.xml</input-file>
<input-file role="principal-stylesheet">string117.xsl</input-file>
<output-file role="principal" compare="XML">string117.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string118">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string118.xml</input-file>
<input-file role="principal-stylesheet">string118.xsl</input-file>
<output-file role="principal" compare="XML">string118.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string119">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string119.xml</input-file>
<input-file role="principal-stylesheet">string119.xsl</input-file>
<output-file role="principal" compare="XML">string119.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string120">
<file-path>string</file-path>
<purpose>Test of 'substring()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string120.xml</input-file>
<input-file role="principal-stylesheet">string120.xsl</input-file>
<output-file role="principal" compare="XML">string120.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string121">
<file-path>string</file-path>
<purpose>Test of 'translate()'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string121.xml</input-file>
<input-file role="principal-stylesheet">string121.xsl</input-file>
<output-file role="principal" compare="XML">string121.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string122">
<file-path>string</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>string(nodeset) returns string value of the node in the node-set that is first in document order.'</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string122.xml</input-file>
<input-file role="principal-stylesheet">string122.xsl</input-file>
<output-file role="principal" compare="XML">string122.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string123">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of string() function with no arguments.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string123.xml</input-file>
<input-file role="principal-stylesheet">string123.xsl</input-file>
<output-file role="principal" compare="XML">string123.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string124">
<file-path>string</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test of contains() function searching for an entity.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string124.xml</input-file>
<input-file role="principal-stylesheet">string124.xsl</input-file>
<output-file role="principal" compare="XML">string124.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string125">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of contains() function with nodes for both arguments, string is not in it.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string125.xml</input-file>
<input-file role="principal-stylesheet">string125.xsl</input-file>
<output-file role="principal" compare="XML">string125.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string126">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of contains() function with nodes for both arguments, string is in it.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string126.xml</input-file>
<input-file role="principal-stylesheet">string126.xsl</input-file>
<output-file role="principal" compare="XML">string126.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string127">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of contains() function with two paths, first argument is multiple nodes, first of those nodes does NOT contain the string.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string127.xml</input-file>
<input-file role="principal-stylesheet">string127.xsl</input-file>
<output-file role="principal" compare="XML">string127.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string128">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of contains() function with two paths, second argument is multiple nodes, first of those nodes does NOT contain the string.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string128.xml</input-file>
<input-file role="principal-stylesheet">string128.xsl</input-file>
<output-file role="principal" compare="XML">string128.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string129">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of contains() function using a numbered entity.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string129.xml</input-file>
<input-file role="principal-stylesheet">string129.xsl</input-file>
<output-file role="principal" compare="XML">string129.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string130">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of contains() function using a numbered entity.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string130.xml</input-file>
<input-file role="principal-stylesheet">string130.xsl</input-file>
<output-file role="principal" compare="XML">string130.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string131">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of string() with zero arguments. Context node just has one text child.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string131.xml</input-file>
<input-file role="principal-stylesheet">string131.xsl</input-file>
<output-file role="principal" compare="XML">string131.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string132">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of default (no functions) conversion of integers.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string132.xml</input-file>
<input-file role="principal-stylesheet">string132.xsl</input-file>
<output-file role="principal" compare="XML">string132.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string133">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of default (no functions) conversion of decimal numbers with fractions.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string133.xml</input-file>
<input-file role="principal-stylesheet">string133.xsl</input-file>
<output-file role="principal" compare="XML">string133.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string134">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of default (no functions) conversion of decimal numbers with decimal point at all positions.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string134.xml</input-file>
<input-file role="principal-stylesheet">string134.xsl</input-file>
<output-file role="principal" compare="XML">string134.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string135">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of default (no functions) conversion of small decimal numbers.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string135.xml</input-file>
<input-file role="principal-stylesheet">string135.xsl</input-file>
<output-file role="principal" compare="XML">string135.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string136">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Ensure that 'translate()' doesn't loop on characters that get repositioned</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string136.xml</input-file>
<input-file role="principal-stylesheet">string136.xsl</input-file>
<output-file role="principal" compare="XML">string136.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string137">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use 'translate()' to map several characters to the same one.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string137.xml</input-file>
<input-file role="principal-stylesheet">string137.xsl</input-file>
<output-file role="principal" compare="XML">string137.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string138">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use 'translate()' to change quotes and apostrophes to other characters.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string138.xml</input-file>
<input-file role="principal-stylesheet">string138.xsl</input-file>
<output-file role="principal" compare="XML">string138.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string139">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use 'translate()' to change certain characters to quotes and apostrophes.</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string139.xml</input-file>
<input-file role="principal-stylesheet">string139.xsl</input-file>
<output-file role="principal" compare="XML">string139.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string140">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test of 'normalize-space()' function. Watch for space being removed when it shouldn't be</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string140.xml</input-file>
<input-file role="principal-stylesheet">string140.xsl</input-file>
<output-file role="principal" compare="XML">string140.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="string_string141">
<file-path>string</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test concat() with lots of arguments</purpose>
<spec-citation place="4.2" type="section" version="1.0" spec="xpath"/>
<scenario operation="standard">
<input-file role="principal-data">string141.xml</input-file>
<input-file role="principal-stylesheet">string141.xsl</input-file>
<output-file role="principal" compare="XML">string141.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="variable_variable01">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set top-level xsl:variable to a string</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable01.xml</input-file>
<input-file role="principal-stylesheet">variable01.xsl</input-file>
<output-file role="principal" compare="XML">variable01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable02">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test top-level xsl:variable set to be an RTF</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable02.xml</input-file>
<input-file role="principal-stylesheet">variable02.xsl</input-file>
<output-file role="principal" compare="XML">variable02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable03">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test xsl:variable inside a template set to be an RTF</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable03.xml</input-file>
<input-file role="principal-stylesheet">variable03.xsl</input-file>
<output-file role="principal" compare="XML">variable03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable04">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for passing variable into other template via with-param.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable04.xml</input-file>
<input-file role="principal-stylesheet">variable04.xsl</input-file>
<output-file role="principal" compare="XML">variable04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable05">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Verify top-level xsl:variable, HTML text RTF</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable05.xml</input-file>
<input-file role="principal-stylesheet">variable05.xsl</input-file>
<output-file role="principal" compare="XML">variable05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable06">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Set variable by name but no value, should get null string</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable06.xml</input-file>
<input-file role="principal-stylesheet">variable06.xsl</input-file>
<output-file role="principal" compare="XML">variable06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable07">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for handling of RTF used as positional index by setting variable as the content of the xsl:variable element. Reference as [$n]. This is the case that will NOT obtain what a naive person expects.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable07.xml</input-file>
<input-file role="principal-stylesheet">variable07.xsl</input-file>
<output-file role="principal" compare="XML">variable07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable08">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for handling of RTF used as positional index by setting variable as the content of the xsl:variable element. Reference as [position()=$n] This is the case that will NOT obtain what the naive person expects.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable08.xml</input-file>
<input-file role="principal-stylesheet">variable08.xsl</input-file>
<output-file role="principal" compare="XML">variable08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable09">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for handling of number used as positional index by setting variable using select attribute. Reference as [$n]</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable09.xml</input-file>
<input-file role="principal-stylesheet">variable09.xsl</input-file>
<output-file role="principal" compare="XML">variable09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable10">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for using xsl:copy-of with empty (null string) variable.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable10.xml</input-file>
<input-file role="principal-stylesheet">variable10.xsl</input-file>
<output-file role="principal" compare="XML">variable10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable11">
<file-path>variable</file-path>
<creator>Ed Blachman</creator>
<date>2001-11-08</date>
<purpose>Import precedence applies to top-level params (even when template referencing it is in the imported file)</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable11.xml</input-file>
<input-file role="principal-stylesheet">variable11.xsl</input-file>
<output-file role="principal" compare="XML">variable11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable12">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set top-level xsl:param to a string</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable12.xml</input-file>
<input-file role="principal-stylesheet">variable12.xsl</input-file>
<output-file role="principal" compare="XML">variable12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable13">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for setting a param using a choose</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable13.xml</input-file>
<input-file role="principal-stylesheet">variable13.xsl</input-file>
<output-file role="principal" compare="XML">variable13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable14">
<file-path>variable</file-path>
<creator>Paul Dick, based on posting to xalan-dev list</creator>
<date>2001-11-08</date>
<purpose>Verify that a variable defined within a xsl:with-param content is scoped correctly. Idea sent in on xalan-dev list. We should recognize 'test' within the with-param statement. The named template 'foo' really plays no part here.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable14.xml</input-file>
<input-file role="principal-stylesheet">variable14.xsl</input-file>
<output-file role="principal" compare="XML">variable14.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable15">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each inside xsl:variable</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable15.xml</input-file>
<input-file role="principal-stylesheet">variable15.xsl</input-file>
<output-file role="principal" compare="XML">variable15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable16">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for-each inside xsl:param</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable16.xml</input-file>
<input-file role="principal-stylesheet">variable16.xsl</input-file>
<output-file role="principal" compare="XML">variable16.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable17">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that there is always a current node</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable17.xml</input-file>
<input-file role="principal-stylesheet">variable17.xsl</input-file>
<output-file role="principal" compare="XML">variable17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable18">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test param being set to default in a named template.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable18.xml</input-file>
<input-file role="principal-stylesheet">variable18.xsl</input-file>
<output-file role="principal" compare="XML">variable18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable19">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Verify that a variable in an inner template can take on a new value</purpose>
<spec-citation place="11" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable19.xml</input-file>
<input-file role="principal-stylesheet">variable19.xsl</input-file>
<output-file role="principal" compare="XML">variable19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable20">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Verify that a variable in a for-each can take on a new value</purpose>
<spec-citation place="11" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable20.xml</input-file>
<input-file role="principal-stylesheet">variable20.xsl</input-file>
<output-file role="principal" compare="XML">variable20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable21">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test setting several parameters locally</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable21.xml</input-file>
<input-file role="principal-stylesheet">variable21.xsl</input-file>
<output-file role="principal" compare="XML">variable21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable22">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Import precedence applies to top-level params (testing references from various import levels)</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable22.xml</input-file>
<input-file role="principal-stylesheet">variable22.xsl</input-file>
<output-file role="principal" compare="XML">variable22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable23">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test how big a string can be passed to a template.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable23.xml</input-file>
<input-file role="principal-stylesheet">variable23.xsl</input-file>
<output-file role="principal" compare="XML">variable23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable24">
<file-path>variable</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test the ability of variable to hold the result of document()</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable24.xml</input-file>
<input-file role="principal-stylesheet">variable24.xsl</input-file>
<output-file role="principal" compare="XML">variable24.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable25">
<file-path>variable</file-path>
<creator>Tommy Burglund</creator>
<date>2001-11-08</date>
<purpose>Variable name is a QName.</purpose>
<spec-citation place="11" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable25.xml</input-file>
<input-file role="principal-stylesheet">variable25.xsl</input-file>
<output-file role="principal" compare="XML">variable25.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable26">
<file-path>variable</file-path>
<creator>Ed Blachman</creator>
<date>2001-11-08</date>
<purpose>It is not an error to pass a parameter to a template that does not have an element for it, the parameter is simpily ignored.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable26.xml</input-file>
<input-file role="principal-stylesheet">variable26.xsl</input-file>
<output-file role="principal" compare="XML">variable26.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable27">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Import precedence applies to top-level params (testing references from various import levels)</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable27.xml</input-file>
<input-file role="principal-stylesheet">variable27.xsl</input-file>
<output-file role="principal" compare="XML">variable27.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable28">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Import precedence applies to top-level params (first template from middle, then up/down/up)</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable28.xml</input-file>
<input-file role="principal-stylesheet">variable28.xsl</input-file>
<output-file role="principal" compare="XML">variable28.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable29">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Import precedence applies to top-level params (order of imports in this sheet matters)</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable29.xml</input-file>
<input-file role="principal-stylesheet">variable29.xsl</input-file>
<output-file role="principal" compare="XML">variable29.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable30">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Import precedence applies to top-level params (start at bottom; all use variable set in middle)</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable30.xml</input-file>
<input-file role="principal-stylesheet">variable30.xsl</input-file>
<output-file role="principal" compare="XML">variable30.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable31">
<file-path>variable</file-path>
<creator>Benoit Cerrina, adapted by David Marston</creator>
<date>2001-11-08</date>
<purpose>Test passing value from top-level param to top-level variable via value-of.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable31.xml</input-file>
<input-file role="principal-stylesheet">variable31.xsl</input-file>
<output-file role="principal" compare="XML">variable31.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable32">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test passing value from top-level param to top-level variable via value-of.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable32.xml</input-file>
<input-file role="principal-stylesheet">variable32.xsl</input-file>
<output-file role="principal" compare="XML">variable32.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable33">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set top-level variable with a forward reference to see what happens.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable33.xml</input-file>
<input-file role="principal-stylesheet">variable33.xsl</input-file>
<output-file role="principal" compare="XML">variable33.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable34">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set cascaded top-level variables in arbitrary order.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable34.xml</input-file>
<input-file role="principal-stylesheet">variable34.xsl</input-file>
<output-file role="principal" compare="XML">variable34.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable35">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Try to catch lazy-evaluation scheme picking up local instead of global.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable35.xml</input-file>
<input-file role="principal-stylesheet">variable35.xsl</input-file>
<output-file role="principal" compare="XML">variable35.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable36">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set variable to null string explicitly and implicitly, compare.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable36.xml</input-file>
<input-file role="principal-stylesheet">variable36.xsl</input-file>
<output-file role="principal" compare="XML">variable36.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable37">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set a variable to a boolean, and show it being used in xsl:if</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable37.xml</input-file>
<input-file role="principal-stylesheet">variable37.xsl</input-file>
<output-file role="principal" compare="XML">variable37.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable38">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for using xsl:copy-of with variable set to a number.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable38.xml</input-file>
<input-file role="principal-stylesheet">variable38.xsl</input-file>
<output-file role="principal" compare="XML">variable38.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable39">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Build an RTF from instructions, then use xsl:copy-of.</purpose>
<spec-citation place="11.3" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable39.xml</input-file>
<input-file role="principal-stylesheet">variable39.xsl</input-file>
<output-file role="principal" compare="XML">variable39.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable40">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test top-level xsl:variable set using apply-templates</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable40.xml</input-file>
<input-file role="principal-stylesheet">variable40.xsl</input-file>
<output-file role="principal" compare="XML">variable40.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable41">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Because root node is current when top-level param is set, can get top-level comment.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable41.xml</input-file>
<input-file role="principal-stylesheet">variable41.xsl</input-file>
<output-file role="principal" compare="XML">variable41.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable42">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use copy to set a variable to an RTF. REMINDER: we won't get the whole sub-tree, just the 'doc' element node.</purpose>
<spec-citation place="11.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable42.xml</input-file>
<input-file role="principal-stylesheet">variable42.xsl</input-file>
<output-file role="principal" compare="XML">variable42.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable43">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test xsl:variable inside xsl:copy</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable43.xml</input-file>
<input-file role="principal-stylesheet">variable43.xsl</input-file>
<output-file role="principal" compare="XML">variable43.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable44">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Set a variable inside a template based on variable defined earlier in that template.</purpose>
<spec-citation place="11.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable44.xml</input-file>
<input-file role="principal-stylesheet">variable44.xsl</input-file>
<output-file role="principal" compare="XML">variable44.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable45">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Use param whose name is a QName in with-param passing.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable45.xml</input-file>
<input-file role="principal-stylesheet">variable45.xsl</input-file>
<output-file role="principal" compare="XML">variable45.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable46">
<file-path>variable</file-path>
<creator>Felix Garcia Romero (felixgr@tdi.tudistrito.es)</creator>
<date>2001-11-08</date>
<purpose>Test proper construction of an RTF containing multiple top level nodes.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable46.xml</input-file>
<input-file role="principal-stylesheet">variable46.xsl</input-file>
<output-file role="principal" compare="XML">variable46.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable47">
<file-path>variable</file-path>
<creator>Matthew Hanson (matthew.hanson@wcom.com</creator>
<date>2001-11-08</date>
<purpose>Evaluation of params with repeated use of imported stylesheet.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable47.xml</input-file>
<input-file role="principal-stylesheet">variable47.xsl</input-file>
<output-file role="principal" compare="XML">variable47.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable48">
<file-path>variable</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Check propagation of params down into templates</purpose>
<spec-citation place="11.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable48.xml</input-file>
<input-file role="principal-stylesheet">variable48.xsl</input-file>
<output-file role="principal" compare="XML">variable48.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable49">
<file-path>variable</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Show that one param (p2) can be set to value of another (p1) equally well in apply and call template invocations.</purpose>
<spec-citation place="11.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable49.xml</input-file>
<input-file role="principal-stylesheet">variable49.xsl</input-file>
<output-file role="principal" compare="XML">variable49.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable50">
<file-path>variable</file-path>
<creator>Scott Boag</creator>
<date>2001-11-08</date>
<purpose>Ensure that we can find descendants of the nodes in a node-set stored in a variable.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable50.xml</input-file>
<input-file role="principal-stylesheet">variable50.xsl</input-file>
<output-file role="principal" compare="XML">variable50.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable51">
<file-path>variable</file-path>
<creator>John Howard/Tom Amiro</creator>
<date>2001-11-08</date>
<purpose>Set a variable within an if within a for-each.</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable51.xml</input-file>
<input-file role="principal-stylesheet">variable51.xsl</input-file>
<output-file role="principal" compare="XML">variable51.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable52">
<file-path>variable</file-path>
<creator>John Howard</creator>
<date>2001-11-08</date>
<purpose>test parameters call by reference and by value</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable52.xml</input-file>
<input-file role="principal-stylesheet">variable52.xsl</input-file>
<output-file role="principal" compare="XML">variable52.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable53">
<file-path>variable</file-path>
<creator>John Howard</creator>
<date>2001-11-08</date>
<purpose>test using recursion to traverse a node-set in a variable.</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable53.xml</input-file>
<input-file role="principal-stylesheet">variable53.xsl</input-file>
<output-file role="principal" compare="XML">variable53.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable54">
<file-path>variable</file-path>
<creator>John Howard</creator>
<date>2001-11-08</date>
<purpose>test using parameter names with '.' in them</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable54.xml</input-file>
<input-file role="principal-stylesheet">variable54.xsl</input-file>
<output-file role="principal" compare="XML">variable54.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable55">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Show that name of variable acts like a real QName.</purpose>
<spec-citation place="11" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable55.xml</input-file>
<input-file role="principal-stylesheet">variable55.xsl</input-file>
<output-file role="principal" compare="XML">variable55.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable56">
<file-path>variable</file-path>
<creator>darrylf@schemasoft.com</creator>
<date>2001-11-08</date>
<purpose>Use same-named variables in inner and outer scopes, where inner is a for-each loop.</purpose>
<spec-citation place="11.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable56.xml</input-file>
<input-file role="principal-stylesheet">variable56.xsl</input-file>
<output-file role="principal" compare="XML">variable56.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable57">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for passing param containing 1-element node-set via apply-templates</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable57.xml</input-file>
<input-file role="principal-stylesheet">variable57.xsl</input-file>
<output-file role="principal" compare="XML">variable57.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable58">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for passing param containing 4-element node-set via apply-templates</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable58.xml</input-file>
<input-file role="principal-stylesheet">variable58.xsl</input-file>
<output-file role="principal" compare="XML">variable58.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable59">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for passing param containing 0-element node-set via apply-templates</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable59.xml</input-file>
<input-file role="principal-stylesheet">variable59.xsl</input-file>
<output-file role="principal" compare="XML">variable59.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable60">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for passing param containing boolean via apply-templates</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable60.xml</input-file>
<input-file role="principal-stylesheet">variable60.xsl</input-file>
<output-file role="principal" compare="XML">variable60.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable61">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for passing param containing number via apply-templates</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable61.xml</input-file>
<input-file role="principal-stylesheet">variable61.xsl</input-file>
<output-file role="principal" compare="XML">variable61.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable62">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for passing numeric param via apply-templates, with sorting</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable62.xml</input-file>
<input-file role="principal-stylesheet">variable62.xsl</input-file>
<output-file role="principal" compare="XML">variable62.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable63">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>test using parameter names with leading underscore</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable63.xml</input-file>
<input-file role="principal-stylesheet">variable63.xsl</input-file>
<output-file role="principal" compare="XML">variable63.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable64">
<file-path>variable</file-path>
<creator>Joseph Kesselman</creator>
<date>2001-11-08</date>
<purpose>test with-param as RTF copied from global variable (also RTF)</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable64.xml</input-file>
<input-file role="principal-stylesheet">variable64.xsl</input-file>
<output-file role="principal" compare="XML">variable64.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable65">
<file-path>variable</file-path>
<creator>David Marston, from Joseph Kesselman's base test</creator>
<date>2001-11-08</date>
<purpose>test with-param as string copied from global variable (an RTF)</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable65.xml</input-file>
<input-file role="principal-stylesheet">variable65.xsl</input-file>
<output-file role="principal" compare="XML">variable65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable65">
<file-path>variable</file-path>
<creator>David Marston, from Joseph Kesselman's base test</creator>
<date>2001-11-08</date>
<purpose>test with-param as string copied from global variable (a locally-built RTF)</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable65.xml</input-file>
<input-file role="principal-stylesheet">variable65.xsl</input-file>
<output-file role="principal" compare="XML">variable65.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable67">
<file-path>variable</file-path>
<creator>David Marston, from Roman Stawski's bug report (#7118)</creator>
<date>2001-11-08</date>
<purpose>Setting a variable in the midst of setting another should not alter any others</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable67.xml</input-file>
<input-file role="principal-stylesheet">variable67.xsl</input-file>
<output-file role="principal" compare="XML">variable67.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable68">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Demonstrate various tests of nullness on local variables</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable68.xml</input-file>
<input-file role="principal-stylesheet">variable68.xsl</input-file>
<output-file role="principal" compare="XML">variable68.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable69">
<file-path>variable</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Demonstrate various tests of nullness on global variables</purpose>
<spec-citation place="11.6" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable69.xml</input-file>
<input-file role="principal-stylesheet">variable69.xsl</input-file>
<output-file role="principal" compare="XML">variable69.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="variable_variable70">
<file-path>variable</file-path>
<creator>Tom Amiro</creator>
<date>2001-11-08</date>
<purpose>Define global variable using a when with a dependency on a variable in an included file</purpose>
<spec-citation place="11.2" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">variable70.xml</input-file>
<input-file role="principal-stylesheet">variable70.xsl</input-file>
<output-file role="principal" compare="XML">variable70.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="ver_ver01">
<file-path>ver</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">ver01.xml</input-file>
<input-file role="principal-stylesheet">ver01.xsl</input-file>
<output-file role="principal" compare="XML">ver01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="ver_ver04">
<file-path>ver</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for explicit specification of version attribute in stylesheet declaration above.</purpose>
<spec-citation place="2.1" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">ver04.xml</input-file>
<input-file role="principal-stylesheet">ver04.xsl</input-file>
<output-file role="principal" compare="XML">ver04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="ver_ver05">
<file-path>ver</file-path>
<creator>Shane Curcuru</creator>
<date>2001-11-08</date>
<purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">ver05.xml</input-file>
<input-file role="principal-stylesheet">ver05.xsl</input-file>
<output-file role="principal" compare="XML">ver05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="ver_ver06">
<file-path>ver</file-path>
<creator>Shane Curcuru</creator>
<date>2001-11-08</date>
<purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">ver06.xml</input-file>
<input-file role="principal-stylesheet">ver06.xsl</input-file>
<output-file role="principal" compare="XML">ver06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="ver_ver07">
<file-path>ver</file-path>
<creator>Shane Curcuru</creator>
<date>2001-11-08</date>
<purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
<spec-citation place="2.5" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">ver07.xml</input-file>
<input-file role="principal-stylesheet">ver07.xsl</input-file>
<output-file role="principal" compare="XML">ver07.out</output-file>
</scenario>
</test-case>
	<test-case category="XSLT-Result-Tree" id="whitespace_whitespace01">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test strip-space directive.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace01.xml</input-file>
<input-file role="principal-stylesheet">whitespace01.xsl</input-file>
<output-file role="principal" compare="XML">whitespace01.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace02">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test strip-space on list of specified elements.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace02.xml</input-file>
<input-file role="principal-stylesheet">whitespace02.xsl</input-file>
<output-file role="principal" compare="XML">whitespace02.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace03">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test strip-space with wildcard element selector.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace03.xml</input-file>
<input-file role="principal-stylesheet">whitespace03.xsl</input-file>
<output-file role="principal" compare="XML">whitespace03.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace04">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test wildcard on strip-space overridden by preserve-space for one element.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace04.xml</input-file>
<input-file role="principal-stylesheet">whitespace04.xsl</input-file>
<output-file role="principal" compare="XML">whitespace04.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace05">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test stripping an element that has whitespace plus a comment containing whitespace.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace05.xml</input-file>
<input-file role="principal-stylesheet">whitespace05.xsl</input-file>
<output-file role="principal" compare="XML">whitespace05.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace06">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test element specifier that has a namespace qualifier.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace06.xml</input-file>
<input-file role="principal-stylesheet">whitespace06.xsl</input-file>
<output-file role="principal" compare="XML">whitespace06.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace07">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test for element specifier that is a wildcard but qualified by a namespace.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace07.xml</input-file>
<input-file role="principal-stylesheet">whitespace07.xsl</input-file>
<output-file role="principal" compare="XML">whitespace07.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace08">
<file-path>whitespace</file-path>
<purpose>Test default whitespace handling.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace08.xml</input-file>
<input-file role="principal-stylesheet">whitespace08.xsl</input-file>
<output-file role="principal" compare="XML">whitespace08.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace09">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test output of newline via CDATA section in template.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace09.xml</input-file>
<input-file role="principal-stylesheet">whitespace09.xsl</input-file>
<output-file role="principal" compare="XML">whitespace09.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace10">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test whitespace as LRE in template.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace10.xml</input-file>
<input-file role="principal-stylesheet">whitespace10.xsl</input-file>
<output-file role="principal" compare="XML">whitespace10.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace11">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test whitespace in template matched on root.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace11.xml</input-file>
<input-file role="principal-stylesheet">whitespace11.xsl</input-file>
<output-file role="principal" compare="XML">whitespace11.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace12">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test xsl:output with indent.</purpose>
<spec-citation place="16" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace12.xml</input-file>
<input-file role="principal-stylesheet">whitespace12.xsl</input-file>
<output-file role="principal" compare="XML">whitespace12.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace13">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test default whitespace handling where both source and template have space.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace13.xml</input-file>
<input-file role="principal-stylesheet">whitespace13.xsl</input-file>
<output-file role="principal" compare="XML">whitespace13.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace15">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test default whitespace handling.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace15.xml</input-file>
<input-file role="principal-stylesheet">whitespace15.xsl</input-file>
<output-file role="principal" compare="XML">whitespace15.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace17">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Test indent on xsl:output with copy-of.</purpose>
<spec-citation place="16" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace17.xml</input-file>
<input-file role="principal-stylesheet">whitespace17.xsl</input-file>
<output-file role="principal" compare="XML">whitespace17.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace18">
<file-path>whitespace</file-path>
<purpose>xsl:text node should not contribute any text nodes to the result tree.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace18.xml</input-file>
<input-file role="principal-stylesheet">whitespace18.xsl</input-file>
<output-file role="principal" compare="XML">whitespace18.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace19">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Stylesheet is whitespace stripped before processing.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace19.xml</input-file>
<input-file role="principal-stylesheet">whitespace19.xsl</input-file>
<output-file role="principal" compare="XML">whitespace19.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace20">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Simple case verifies use of xml:space to preserve whitespace, here a space and a tab.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace20.xml</input-file>
<input-file role="principal-stylesheet">whitespace20.xsl</input-file>
<output-file role="principal" compare="XML">whitespace20.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace21">
<file-path>whitespace</file-path>
<creator>David Marston</creator>
<date>2001-11-08</date>
<purpose>Test for whitespace handling with comments in literal sections</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace21.xml</input-file>
<input-file role="principal-stylesheet">whitespace21.xsl</input-file>
<output-file role="principal" compare="XML">whitespace21.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace22">
<file-path>whitespace</file-path>
<creator>Paul Dick</creator>
<date>2001-11-08</date>
<purpose>Testing the applicable match for a particular element, also verifying that preserve-space works with namespace-prefixed element. This generate an error, recovering with the match that occurs last in the stylesheet.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace22.xml</input-file>
<input-file role="principal-stylesheet">whitespace22.xsl</input-file>
<output-file role="principal" compare="XML">whitespace22.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace23">
<file-path>whitespace</file-path>
<creator>Scott Boag (in response to problem reported by "Carsten Ziegeler" &lt;cziegeler@sundn.de&gt;)</creator>
<date>2001-11-08</date>
<purpose>Another test for the normalize-space function, this one really testing handling of the newline.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace23.xml</input-file>
<input-file role="principal-stylesheet">whitespace23.xsl</input-file>
<output-file role="principal" compare="XML">whitespace23.out</output-file>
</scenario>
</test-case>
<test-case category="XSLT-Result-Tree" id="whitespace_whitespace35">
<file-path>whitespace</file-path>
<creator>Maynard Demmons (maynard@organic.com)</creator>
<date>2001-11-08</date>
<purpose>Test for whitespace stripping from source documents retrieved with the document() function. The spec is a little vague on this.</purpose>
<spec-citation place="3.4" type="section" version="1.0" spec="xslt"/>
<scenario operation="standard">
<input-file role="principal-data">whitespace35.xml</input-file>
<input-file role="principal-stylesheet">whitespace35.xsl</input-file>
<output-file role="principal" compare="XML">whitespace35.out</output-file>
</scenario>
</test-case>
</test-catalog>
</test-suite>
