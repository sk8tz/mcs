<?xml version="1.0"?>
<doc>
    <assembly>
        <name>C5</name>
    </assembly>
    <members>
        <member name="T:C5.EnumerationDirection">
            <summary>
            Direction of enumeration order relative to original collection.
            </summary>
        </member>
        <member name="F:C5.EnumerationDirection.Forwards">
            <summary>
            Same direction
            </summary>
        </member>
        <member name="F:C5.EnumerationDirection.Backwards">
            <summary>
            Opposite direction
            </summary>
        </member>
        <member name="T:C5.IComparer`1">
            <summary>
            The type of an item comparer
            <p>Implementations of this interface must asure that the method is self-consistent
            and defines a sorting order on items, or state precise conditions under which this is true.</p>
            <p>Implementations <b>must</b> assure that repeated calls of
            the method to the same (in reference or binary identity sense) arguments 
            will return values with the same sign (-1, 0 or +1), or state precise conditions
            under which the user 
            can be assured repeated calls will return the same sign.</p>
            <p>Implementations of this interface must always return values from the method
            and never throw exceptions.</p>
            <p>This interface is identical to System.Collections.Generic.IComparer&lt;T&gt;</p>
            </summary>
        </member>
        <member name="M:C5.IComparer`1.Compare(`0,`0)">
            <summary>
            Compare two items with respect to this item comparer
            </summary>
            <param name="a">First item</param>
            <param name="b">Second item</param>
            <returns>Positive if a is greater than b, 0 if they are equal, negative if a is less than b</returns>
        </member>
        <member name="T:C5.IntHasher">
            <summary>
            A hasher for int32
            </summary>
        </member>
        <member name="T:C5.IHasher`1">
            <summary>
            The type of an item hasher. 
            <p>Implementations of this interface <b>must</b> assure that the methods are 
            consistent, i.e. that whenever two items i1 and i2 satisfies that Equals(i1,i2)
            returns true, then GetHashCode returns the same values for i1 and i2.</p>
            <p>Implementations of this interface <b>must</b> assure that repeated calls of
            the methods to the same (in reference or binary identity sense) arguments 
            will return the same values, or state precise conditions under which the user 
            can be assured repeated calls will return the same values.</p>
            <p>Implementations of this interface must always return values from the methods
            and never throw exceptions.</p>
            <p>This interface is similar in function to System.IKeyComparer&lt;T&gt;</p>
            </summary>
        </member>
        <member name="M:C5.IHasher`1.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this item hasher
            </summary>
            <param name="item">The item</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.IHasher`1.Equals(`0,`0)">
            <summary>
            Check if two items are equal with respect to this item hasher
            </summary>
            <param name="i1">first item</param>
            <param name="i2">second item</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:C5.IntHasher.GetHashCode(System.Int32)">
            <summary>
            Get the hash code of this integer, i.e. itself
            </summary>
            <param name="item">The integer</param>
            <returns>The same</returns>
        </member>
        <member name="M:C5.IntHasher.Equals(System.Int32,System.Int32)">
            <summary>
            Check if two integers are equal
            </summary>
            <param name="i1">first integer</param>
            <param name="i2">second integer</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:C5.NaturalComparer`1">
            <summary>
            A natural generic IComparer for an IComparable&lt;T&gt; item type
            </summary>
        </member>
        <member name="M:C5.NaturalComparer`1.Compare(`0,`0)">
            <summary>
            Compare two items
            </summary>
            <param name="a">First item</param>
            <param name="b">Second item</param>
            <returns>a &lt;=&gt; b</returns>
        </member>
        <member name="T:C5.NaturalComparerO`1">
            <summary>
            A natural generic IComparer for a System.IComparable item type
            </summary>
        </member>
        <member name="M:C5.NaturalComparerO`1.Compare(`0,`0)">
            <summary>
            Compare two items
            </summary>
            <param name="a">First item</param>
            <param name="b">Second item</param>
            <returns>a &lt;=&gt; b</returns>
        </member>
        <member name="T:C5.DefaultReferenceTypeHasher`1">
             <summary>
             The default item hasher for a reference type. A trivial wrapper for calling 
             the GetHashCode and Equals methods inherited from object.
            
             <p>Should only be instantiated with a reference type as generic type parameter. 
             This is asserted at instatiation time in Debug builds.</p>
             </summary>
        </member>
        <member name="M:C5.DefaultReferenceTypeHasher`1.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this item hasher
            </summary>
            <param name="item">The item</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.DefaultReferenceTypeHasher`1.Equals(`0,`0)">
            <summary>
            Check if two items are equal with respect to this item hasher
            </summary>
            <param name="i1">first item</param>
            <param name="i2">second item</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:C5.DefaultValueTypeHasher`1">
             <summary>
             The default item hasher for a value type. A trivial wrapper for calling 
             the GetHashCode and Equals methods inherited from object.
            
             <p>Should only be instantiated with a value type as generic type parameter. 
             This is asserted at instatiation time in Debug builds.</p>
             <p>We cannot add the constraint "where T : struct" to get a compile time check
             because we need to instantiate this class in C5.HasherBuilder.ByPrototype[T].Examine()
             with a T that is only known at runtime to be a value type!</p>
             </summary>
        </member>
        <member name="M:C5.DefaultValueTypeHasher`1.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this item hasher
            </summary>
            <param name="item">The item</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.DefaultValueTypeHasher`1.Equals(`0,`0)">
            <summary>
            Check if two items are equal with respect to this item hasher
            </summary>
            <param name="i1">first item</param>
            <param name="i2">second item</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:C5.EnumerableBase`1">
            <summary>
            A base class for implementing an IEnumerable&lt;T&gt;
            </summary>
        </member>
        <member name="M:C5.EnumerableBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.EnumerableBase`1.countItems(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Count the number of items in an enumerable by enumeration
            </summary>
            <param name="items">The enumerable to count</param>
            <returns>The size of the enumerable</returns>
        </member>
        <member name="T:C5.CollectionValueBase`1">
            <summary>
            Base class for classes implementing ICollectionValue[T]
            </summary>
        </member>
        <member name="T:C5.ICollectionValue`1">
            <summary>
            A generic collection that may be enumerated and can answer
            efficiently how many items it contains. Like <code>IEnumerable&lt;T&gt;</code>,
            this interface does not prescribe any operations to initialize or update the 
            collection. The main usage for this interface is to be the return type of 
            query operations on generic collection.
            </summary>
        </member>
        <member name="M:C5.ICollectionValue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to a contiguous part of an array.
            </summary>
            <param name="a">The array to copy to</param>
            <param name="i">The index at which to copy the first item</param>
        </member>
        <member name="M:C5.ICollectionValue`1.ToArray">
            <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.ICollectionValue`1.Apply(C5.Applier{`0})">
            <summary>
            Apply a delegate to all items of this collection.
            </summary>
            <param name="a">The delegate to apply</param>
        </member>
        <member name="M:C5.ICollectionValue`1.Exists(C5.Filter{`0})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter!1"/>) defining the predicate</param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:C5.ICollectionValue`1.All(C5.Filter{`0})">
            <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter!1"/>) defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="P:C5.ICollectionValue`1.Count">
            <summary>
            
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="P:C5.ICollectionValue`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:C5.CollectionValueBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to part of an array.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if i is negative.
            <exception cref="T:System.ArgumentException"/> if the array does not have room for the items.
            </summary>
            <param name="a">The array to copy to</param>
            <param name="i">The starting index.</param>
        </member>
        <member name="M:C5.CollectionValueBase`1.ToArray">
            <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.Apply(C5.Applier{`0})">
            <summary>
            Apply an Applier&lt;T&gt; to this enumerable
            </summary>
            <param name="a">The applier delegate</param>
        </member>
        <member name="M:C5.CollectionValueBase`1.Exists(C5.Filter{`0})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter!1"/>) defining the predicate</param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.All(C5.Filter{`0})">
            <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter!1"/>) defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="M:C5.CollectionValueBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:C5.CollectionValueBase`1.Count">
            <summary>
            The number of items in this collection.
            </summary>
            <value></value>
        </member>
        <member name="P:C5.CollectionValueBase`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="T:C5.CollectionBase`1">
            <summary>
            Base class (abstract) for ICollection implementations.
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.isReadOnly">
            <summary>
            The underlying field of the ReadOnly property
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.stamp">
            <summary>
            The current stamp value
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.size">
            <summary>
            The number of items in the collection
            </summary>
        </member>
        <member name="F:C5.CollectionBase`1.itemhasher">
            <summary>
            The item hasher of the collection
            </summary>
        </member>
        <member name="M:C5.CollectionBase`1.checkRange(System.Int32,System.Int32)">
            <summary>
            Utility method for range checking.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the start or count is negative
            <exception cref="T:System.ArgumentException"/> if the range does not fit within collection size.
            </summary>
            <param name="start">start of range</param>
            <param name="count">size of range</param>
        </member>
        <member name="M:C5.CollectionBase`1.ComputeHashCode(C5.ICollectionValue{`0},C5.IHasher{`0})">
            <summary>
            Compute the unsequenced hash code of a collection
            </summary>
            <param name="items">The collection to compute hash code for</param>
            <param name="itemhasher">The item hasher</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.CollectionBase`1.StaticEquals(C5.ICollection{`0},C5.ICollection{`0},C5.IHasher{`0})">
            <summary>
            Examine if tit and tat are equal as unsequenced collections
            using the specified item hasher (assumed compatible with the two collections).
            </summary>
            <param name="tit">The first collection</param>
            <param name="tat">The second collection</param>
            <param name="itemhasher">The item hasher to use for comparison</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:C5.CollectionBase`1.unsequencedhashcode">
            <summary>
            Get the unsequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.CollectionBase`1.unsequencedequals(C5.ICollection{`0})">
            <summary>
            Check if the contents of that is equal to the contents of this
            in the unsequenced sense. Using the item hasher of this collection.
            </summary>
            <param name="that">The collection to compare to.</param>
            <returns>True if  equal</returns>
        </member>
        <member name="M:C5.CollectionBase`1.modifycheck(System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if this collection has been updated 
            since a target time
            </summary>
            <param name="thestamp">The stamp identifying the target time</param>
        </member>
        <member name="M:C5.CollectionBase`1.updatecheck">
            <summary>
            Check if it is valid to perform update operations, and if so increment stamp
            </summary>
        </member>
        <member name="M:C5.CollectionBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:C5.CollectionBase`1.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if this collection is read only</value>
        </member>
        <member name="P:C5.CollectionBase`1.Count">
            <summary>
            
            </summary>
            <value>The size of this collection</value>
        </member>
        <member name="P:C5.CollectionBase`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="P:C5.CollectionBase`1.SyncRoot">
            <summary>
            
            </summary>
            <value>A distinguished object to use for locking to synchronize multithreaded access</value>
        </member>
        <member name="P:C5.CollectionBase`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True is this collection is empty</value>
        </member>
        <member name="T:C5.SequencedBase`1">
            <summary>
            Base class (abstract) for sequenced collection implementations.
            </summary>
        </member>
        <member name="M:C5.SequencedBase`1.ComputeHashCode(C5.ISequenced{`0},C5.IHasher{`0})">
            <summary>
            Compute the unsequenced hash code of a collection
            </summary>
            <param name="items">The collection to compute hash code for</param>
            <param name="itemhasher">The item hasher</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.SequencedBase`1.StaticEquals(C5.ISequenced{`0},C5.ISequenced{`0},C5.IHasher{`0})">
            <summary>
            Examine if tit and tat are equal as sequenced collections
            using the specified item hasher (assumed compatible with the two collections).
            </summary>
            <param name="tit">The first collection</param>
            <param name="tat">The second collection</param>
            <param name="itemhasher">The item hasher to use for comparison</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:C5.SequencedBase`1.sequencedhashcode">
            <summary>
            Get the sequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.SequencedBase`1.sequencedequals(C5.ISequenced{`0})">
            <summary>
            Check if the contents of that is equal to the contents of this
            in the sequenced sense. Using the item hasher of this collection.
            </summary>
            <param name="that">The collection to compare to.</param>
            <returns>True if  equal</returns>
        </member>
        <member name="M:C5.SequencedBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:C5.SequencedBase`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.ArrayBase`1">
            <summary>
            Base class for collection classes of dynamic array type implementations.
            </summary>
        </member>
        <member name="F:C5.ArrayBase`1.array">
            <summary>
            The actual internal array container. Will be extended on demand.
            </summary>
        </member>
        <member name="F:C5.ArrayBase`1.offset">
            <summary>
            The offset into the internal array container of the first item. The offset is 0 for a 
            base dynamic array and may be positive for an updatable view into a base dynamic array.
            </summary>
        </member>
        <member name="M:C5.ArrayBase`1.expand">
            <summary>
            Double the size of the internal array.
            </summary>
        </member>
        <member name="M:C5.ArrayBase`1.expand(System.Int32,System.Int32)">
            <summary>
            Expand the internal array container.
            </summary>
            <param name="newcapacity">The new size of the internal array - 
            will be rounded upwards to a power of 2.</param>
            <param name="newsize">The (new) size of the (base) collection.</param>
        </member>
        <member name="M:C5.ArrayBase`1.insert(System.Int32,`0)">
            <summary>
            Insert an item at a specific index, moving items to the right
            upwards and expanding the array if necessary.
            </summary>
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayBase`1.#ctor(System.Int32,C5.IHasher{`0})">
            <summary>
            Create an empty ArrayBase object.
            </summary>
            <param name="capacity">The initial capacity of the internal array container.
            Will be rounded upwards to the nearest power of 2 greater than or equal to 8.</param>
            <param name="hasher">The item hasher to use, primarily for item equality</param>
        </member>
        <member name="M:C5.ArrayBase`1.Clear">
            <summary>
            Remove all items and reset size of internal array container.
            </summary>
        </member>
        <member name="M:C5.ArrayBase`1.ToArray">
            <summary>
            Create an array containing (copies) of the items of this collection in enumeration order.
            </summary>
            <returns>The new array</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Check">
            <summary>
            Perform an internal consistency (invariant) test on the array base.
            </summary>
            <returns>True if test succeeds.</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Backwards">
            <summary>
            Create a directed collection with the same contents as this one, but 
            opposite enumeration sequence.
            </summary>
            <returns>The mirrored collection.</returns>
        </member>
        <member name="M:C5.ArrayBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this array based collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:C5.ArrayBase`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="T:C5.ArrayBase`1.Range">
            <summary>
            A helper class for defining results of interval queries on array based collections.
            </summary>
        </member>
        <member name="T:C5.IDirectedCollectionValue`1">
            <summary>
            A sized generic collection, that can be enumerated backwards.
            </summary>
        </member>
        <member name="T:C5.IDirectedEnumerable`1">
            <summary>
            A generic collection, that can be enumerated backwards.
            </summary>
        </member>
        <member name="M:C5.IDirectedEnumerable`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.IDirectedEnumerable`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="M:C5.IDirectedCollectionValue`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Range.GetEnumerator">
            <summary>
            Create an enumerator for this range of an array based collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.ArrayBase`1.Range.Backwards">
            <summary>
            Create a araay collection range with the same contents as this one, but 
            opposite enumeration sequence.
            </summary>
            <returns>The mirrored collection.</returns>
        </member>
        <member name="P:C5.ArrayBase`1.Range.Count">
            <summary>
            
            </summary>
            <value>The number of items in the range</value>
        </member>
        <member name="P:C5.ArrayBase`1.Range.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="P:C5.ArrayBase`1.Range.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.Sorting">
            <summary>
            A utility class with functions for sorting arrays with respect to an IComparer&lt;T&gt;
            </summary>
        </member>
        <member name="M:C5.Sorting.IntroSort``1(``0[],System.Int32,System.Int32,C5.IComparer{``0})">
            <summary>
            Sort part of array in place using IntroSort
            </summary>
            <param name="a">Array to sort</param>
            <param name="f">Index of first position to sort</param>
            <param name="b">Index of first position beyond the part to sort</param>
            <param name="c">IComparer&lt;T&gt; to sort by</param>
        </member>
        <member name="M:C5.Sorting.InsertionSort``1(``0[],System.Int32,System.Int32,C5.IComparer{``0})">
            <summary>
            Sort part of array in place using Insertion Sort
            </summary>
            <param name="a">Array to sort</param>
            <param name="f">Index of first position to sort</param>
            <param name="b">Index of first position beyond the part to sort</param>
            <param name="c">IComparer&lt;T&gt; to sort by</param>
        </member>
        <member name="M:C5.Sorting.HeapSort``1(``0[],System.Int32,System.Int32,C5.IComparer{``0})">
            <summary>
            Sort part of array in place using Heap Sort
            </summary>
            <param name="a">Array to sort</param>
            <param name="f">Index of first position to sort</param>
            <param name="b">Index of first position beyond the part to sort</param>
            <param name="c">IComparer&lt;T&gt; to sort by</param>
        </member>
        <member name="T:C5.C5Random">
            <summary>
            A modern random number generator based on (whatever)
            </summary>
        </member>
        <member name="M:C5.C5Random.NextDouble">
            <summary>
            Get a new random System.Double value
            </summary>
            <returns>The random double</returns>
        </member>
        <member name="M:C5.C5Random.Sample">
            <summary>
            Get a new random System.Double value
            </summary>
            <returns>The random double</returns>
        </member>
        <member name="M:C5.C5Random.Next">
            <summary>
            Get a new random System.Int32 value
            </summary>
            <returns>The random int</returns>
        </member>
        <member name="M:C5.C5Random.Next(System.Int32)">
            <summary>
            Get a random non-negative integer less than a given upper bound
            </summary>
            <param name="max">The upper bound (exclusive)</param>
            <returns></returns>
        </member>
        <member name="M:C5.C5Random.Next(System.Int32,System.Int32)">
            <summary>
            Get a random integer between two given bounds
            </summary>
            <param name="min">The lower bound (inclusive)</param>
            <param name="max">The upper bound (exclusive)</param>
            <returns></returns>
        </member>
        <member name="M:C5.C5Random.NextBytes(System.Byte[])">
            <summary>
            Fill a array of byte with random bytes
            </summary>
            <param name="buffer">The array to fill</param>
        </member>
        <member name="M:C5.C5Random.#ctor">
            <summary>
            Create a random number generator seed by system time.
            </summary>
        </member>
        <member name="M:C5.C5Random.#ctor(System.Int64)">
            <summary>
            Create a random number generator with a given seed
            </summary>
            <param name="seed">The seed</param>
        </member>
        <member name="T:C5.TestedAttribute">
            <summary>
            A custom attribute to mark methods and properties as being tested 
            sufficiently in the regression test suite.
            </summary>
        </member>
        <member name="F:C5.TestedAttribute.via">
            <summary>
            Optional reference to test case
            </summary>
        </member>
        <member name="M:C5.TestedAttribute.ToString">
            <summary>
            Pretty print attribute value
            </summary>
            <returns>"Tested via " + via</returns>
        </member>
        <member name="T:C5.HashBag`1">
            <summary>
            A bag collection based on a hash table of (item,count) pairs. 
            </summary>
        </member>
        <member name="T:C5.ICollection`1">
            <summary>
            The simplest interface of a main stream generic collection
            with lookup, insertion and removal operations. 
            </summary>
        </member>
        <member name="T:C5.IExtensible`1">
            <summary>
            A generic collection to which one may add items. This is just the intersection
            of the main stream generic collection interfaces and the priority queue interface,
            <see cref="T:C5.ICollection!1"/> and <see cref="T:C5.IPriorityQueue!1"/>.
            </summary>
        </member>
        <member name="M:C5.IExtensible`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.IExtensible`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.IExtensible`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.IExtensible`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            <p>This is only relevant for developers of the library</p>
            </summary>
            <returns>True if check was passed.</returns>
        </member>
        <member name="P:C5.IExtensible`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>False if this collection has set semantics, true if bag semantics.</value>
        </member>
        <member name="P:C5.IExtensible`1.SyncRoot">
            <summary>
            
            </summary>
            <value>An object to be used for locking to enable multi threaded code
            to acces this collection safely.</value>
        </member>
        <member name="P:C5.IExtensible`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty.</value>
        </member>
        <member name="M:C5.ICollection`1.GetHashCode">
            <summary>
            The hashcode is defined as the sum of <code>h(item)</code> over the items
            of the collection, where the function <code>h</code> is??? 
            </summary>
            <returns>The unordered hashcode of this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.Equals(C5.ICollection{`0})">
            <summary>
            Compare the contents of this collection to another one without regards to
            the sequence order. The comparison will use this collection's itemhasher
            to compare individual items.
            </summary>
            <param name="that">The collection to compare to.</param>
            <returns>True if this collection and that contains the same items.</returns>
        </member>
        <member name="M:C5.ICollection`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.ICollection`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>NoDuplicates==false</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ICollection`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.ICollection`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            it is implementation dependent if this updates all equivalent copies in
            the collection or just one.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.ICollection`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.ICollection`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ICollection`1.RemoveWithReturn(`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ICollection`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.ICollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.ICollection`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.ICollection`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="P:C5.ICollection`1.IsReadOnly">
            <summary>
            If true any call of an updating operation will throw an
            <code>InvalidOperationException</code>
            </summary>
            <value>True if this collection is read only.</value>
        </member>
        <member name="P:C5.ICollection`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of lookup operations
            (<code>Contains()</code> etc.) of the implementation of this list.</value>
        </member>
        <member name="M:C5.HashBag`1.#ctor">
            <summary>
            Create a hash bag with the deafult item hasher.
            </summary>
        </member>
        <member name="M:C5.HashBag`1.#ctor(C5.IHasher{`0})">
            <summary>
            Create a hash bag with an external item hasher.
            </summary>
            <param name="h">The external hasher.</param>
        </member>
        <member name="M:C5.HashBag`1.Contains(`0)">
            <summary>
            Check if an item is in the bag 
            </summary>
            <param name="item">The item to look for</param>
            <returns>True if bag contains item</returns>
        </member>
        <member name="M:C5.HashBag`1.Find(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the bag and
            if so report the actual item object found.
            </summary>
            <param name="item">On entry, the item to look for.
            On exit the item found, if any</param>
            <returns>True if bag contains item</returns>
        </member>
        <member name="M:C5.HashBag`1.Update(`0)">
            <summary>
            Check if an item (collection equal to a given one) is in the bag and
            if so replace the item object in the bag with the supplied one.
            </summary>
            <param name="item">The item object to update with</param>
            <returns>True if item was found (and updated)</returns>
        </member>
        <member name="M:C5.HashBag`1.FindOrAdd(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the bag.
            If found, report the actual item object in the bag,
            else add the supplied one.
            </summary>
            <param name="item">On entry, the item to look for or add.
            On exit the actual object found, if any.</param>
            <returns>True if item was found</returns>
        </member>
        <member name="M:C5.HashBag`1.UpdateOrAdd(`0)">
            <summary>
            Check if an item (collection equal to a supplied one) is in the bag and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
            <param name="item">The item to look for and update or add</param>
            <returns>True if item was updated</returns>
        </member>
        <member name="M:C5.HashBag`1.Remove(`0)">
            <summary>
            Remove one copy af an item from the bag
            </summary>
            <param name="item">The item to remove</param>
            <returns>True if item was (found and) removed </returns>
        </member>
        <member name="M:C5.HashBag`1.RemoveWithReturn(`0@)">
            <summary>
            Remove one copy of an item from the bag, reporting the actual matching item object.
            </summary>
            <param name="item">On entry the item to remove.
            On exit, the actual removed item object.</param>
            <returns>True if item was found.</returns>
        </member>
        <member name="M:C5.HashBag`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a supplied collection from this bag, counting multiplicities.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashBag`1.Clear">
            <summary>
            Remove all items from the bag, resetting internal table to initial size.
            </summary>
        </member>
        <member name="M:C5.HashBag`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items *not* in a supplied collection from this bag,
            counting multiplicities.
            </summary>
            <param name="items">The items to retain</param>
        </member>
        <member name="M:C5.HashBag`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if all items in a supplied collection is in this bag
            (counting multiplicities). 
            </summary>
            <param name="items">The items to look for.</param>
            <returns>True if all items are found.</returns>
        </member>
        <member name="M:C5.HashBag`1.ToArray">
            <summary>
            Create an array containing all items in this bag (in enumeration order).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.HashBag`1.ContainsCount(`0)">
            <summary>
            Count the number of times an item is in this set.
            </summary>
            <param name="item">The item to look for.</param>
            <returns>The count</returns>
        </member>
        <member name="M:C5.HashBag`1.RemoveAllCopies(`0)">
            <summary>
            Remove all copies of item from this set.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:C5.HashBag`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this bag to part of an array.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if i is negative.
            <exception cref="T:System.ArgumentException"/> if the array does not have room for the items.
            </summary>
            <param name="a">The array to copy to</param>
            <param name="i">The starting index.</param>
        </member>
        <member name="M:C5.HashBag`1.Add(`0)">
            <summary>
            Add an item to this bag.
            </summary>
            <param name="item">The item to add.</param>
            <returns>Always true</returns>
        </member>
        <member name="M:C5.HashBag`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items of a collection to this set.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashBag`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashBag`1.GetEnumerator">
            <summary>
            Create an enumerator for this bag.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.HashBag`1.Check">
            <summary>
            Test internal structure of data (invariants)
            </summary>
            <returns>True if pass</returns>
        </member>
        <member name="P:C5.HashBag`1.ContainsSpeed">
            <summary>
            The complexity of the Contains operation
            </summary>
            <value>Always returns Speed.Constant</value>
        </member>
        <member name="P:C5.HashBag`1.AllowsDuplicates">
            <summary>
            Report if this is a set collection.
            </summary>
            <value>Always true</value>
        </member>
        <member name="T:C5.Applier`1">
            <summary>
            A generic delegate that when invoked performs some operation
            on it T argument.
            </summary>
        </member>
        <member name="T:C5.Mapper`2">
            <summary>
            A generic delegate whose invocation constitutes a map from T to V.
            </summary>
        </member>
        <member name="T:C5.Filter`1">
            <summary>
            A generic delegate that when invoked on a T item returns a boolean
            value -- i.e. a T predicate.
            </summary> 
        </member>
        <member name="T:C5.Speed">
            <summary>
            The symbolic characterization of the speed of lookups for a collection.
            The values may refer to worst-case, amortized and/or expected asymtotic 
            complexity wrt. the collection size.
            </summary>
        </member>
        <member name="F:C5.Speed.PotentiallyInfinite">
            <summary>
            Counting the collection with the <code>Count property</code> may not return
            (for a synthetic and potentially infinite collection).
            </summary>
        </member>
        <member name="F:C5.Speed.Linear">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property may take time O(n),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="F:C5.Speed.Log">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(log n),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="F:C5.Speed.Constant">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(1),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="T:C5.ISequenced`1">
             <summary>
             An editable collection maintaining a definite sequence order of the items.
            
             <p>Implementations of this interface must compute the hash code and 
             equality exactly as prescribed in the method definitions in order to
             be consistent with other collection classes implementing this interface.</p>
             <p>This interface is usually implemented by explicit interface implementation,
             not as ordinary virtual methods.</p>
             </summary>
        </member>
        <member name="M:C5.ISequenced`1.GetHashCode">
            <summary>
            The hashcode is defined as <code>h(...h(h(x1),x2)...,xn)</code> for
            <code>h(a,b)=31*a+b</code> and the x's the hash codes of 
            </summary>
            <returns>The sequence order hashcode of this collection.</returns>
        </member>
        <member name="M:C5.ISequenced`1.Equals(C5.ISequenced{`0})">
            <summary>
            Compare this sequenced collection to another one in sequence order.
            </summary>
            <param name="that">The sequenced collection to compare to.</param>
            <returns>True if this collection and that contains equal (according to
            this collection's itemhasher) in the same sequence order.</returns>
        </member>
        <member name="T:C5.IIndexed`1">
            <summary>
            A sequenced collection, where indices of items in the order are maintained
            </summary>
        </member>
        <member name="M:C5.IIndexed`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.IIndexed`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.IIndexed`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IIndexed`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="P:C5.IIndexed`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="P:C5.IIndexed`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="T:C5.IStack`1">
            <summary>
            The interface describing the operations of a LIFO stack data structure.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:C5.IStack`1.Push(`0)">
            <summary>
            Push an item to the top of the stack.
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.IStack`1.Pop">
            <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="T:C5.IQueue`1">
            <summary>
            The interface describing the operations of a FIFO queue data structure.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:C5.IQueue`1.EnQueue(`0)">
            <summary>
            Enqueue an item at the back of the queue. 
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.IQueue`1.DeQueue">
            <summary>
            Dequeue an item from the front of the queue.
            </summary>
            <returns>The item</returns>
        </member>
        <member name="T:C5.IList`1">
             <summary>
             This is an indexed collection, where the item order is chosen by 
             the user at insertion time.
            
             NBNBNB: we neeed a description of the view functionality here!
             </summary>
        </member>
        <member name="M:C5.IList`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.</summary>
            <exception cref="T:System.InvalidOperationException"/> if the list has
            <code>NoDuplicates=true</code> and the item is 
            already in the list.
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.IList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list.
            <exception cref="T:System.InvalidOperationException"/> if the list has
            <code>NoDuplicates=true</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.IList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            <exception cref="T:System.InvalidOperationException"/> if the list has
            <code>NoDuplicates=true</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.IList`1.InsertBefore(`0,`0)">
            <summary>
            Insert an item right before the first occurrence of some target item.
            <exception cref="T:System.InvalidOperationException"/> if target	is not found
            or if the list has <code>NoDuplicates=true</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target before which to insert.</param>
        </member>
        <member name="M:C5.IList`1.InsertAfter(`0,`0)">
            <summary>
            Insert an item right after the last(???) occurrence of some target item.
            <exception cref="T:System.InvalidOperationException"/> if target	is not found
            or if the list has <code>NoDuplicates=true</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target after which to insert.</param>
        </member>
        <member name="M:C5.IList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.
            <exception cref="T:System.InvalidOperationException"/> if the list has 
            <code>NoDuplicates=true</code> and one of the items to insert is
            already in the list.
            </summary>
            <param name="i">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.IList`1.FindAll(C5.Filter{`0})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.IList`1.Map``1(C5.Mapper{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default hasher for the item type V.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.IList`1.Map``1(C5.Mapper{`0,``0},C5.IHasher{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified hasher for the item type.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="hasher">The hasher to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.IList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IList`1.RemoveFirst">
            <summary>
            Remove one item from the fromnt of the list.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the view would not fit into
            this list.
            </summary>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.IList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            <exception cref="T:System.InvalidOperationException"/> if this list is not a view.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the operation
            would bring either end of the view outside the underlying list.
            </summary>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.IList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, changing its size.
            <exception cref="T:System.InvalidOperationException"/> if this list is not a view.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the operation
            would bring either end of the view outside the underlying list.
            </summary>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.IList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.IList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverst part of the list so the items are in the opposite sequence order.
            <exception cref="T:System.ArgumentException"/> if the count is negative.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the part does not fit
            into the list.
            </summary>
            <param name="start">The index of the start of the part to reverse.</param>
            <param name="count">The size of the part to reverse.</param>
        </member>
        <member name="M:C5.IList`1.IsSorted(C5.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.IList`1.Sort(C5.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.IList`1.Shuffle">
            <summary>
            Randonmly shuffle the items of this list. 
            </summary>
        </member>
        <member name="M:C5.IList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="P:C5.IList`1.First">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.IList`1.Last">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.IList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end.</value>
        </member>
        <member name="P:C5.IList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.IList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.IList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for an underlying list.</value>
        </member>
        <member name="T:C5.IPriorityQueue`1">
            <summary>
            A generic collection of items prioritized by a comparison (order) relation.
            Supports adding items and reporting or removing extremal elements. 
            The priority queue itself exports the used
            order relation through its implementation of <code>IComparer&lt;T&gt;</code>
            </summary>
        </member>
        <member name="M:C5.IPriorityQueue`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.IPriorityQueue`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="P:C5.IPriorityQueue`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="T:C5.ISorted`1">
            <summary>
            A collection where items are maintained in sorted order.
            </summary>
        </member>
        <member name="M:C5.ISorted`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.ISorted`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)
            </summary>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.ISorted`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than the minimum of this collection.)
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.ISorted`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.ISorted`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-decreasing function from the item type to <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-decreasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is negative (if any).</param>
            <param name="lowIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is positive (if any).</param>
            <param name="highIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:C5.ISorted`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.ISorted`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:C5.ISorted`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.ISorted`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.ISorted`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="T:C5.IIndexedSorted`1">
            <summary>
            A collection where items are maintained in sorted order together
            with their indexes in that order.
            </summary>
        </member>
        <member name="M:C5.IIndexedSorted`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.FindAll(C5.Filter{`0})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="f">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.IIndexedSorted`1.Map``1(C5.Mapper{`0,``0},C5.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="m">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="T:C5.IPersistentSorted`1">
            <summary>
            The type of a sorted collection with persistence
            </summary>
        </member>
        <member name="M:C5.IPersistentSorted`1.Snapshot">
            <summary>
            Make a (read-only) snap shot of this collection.
            </summary>
            <returns>The snap shot.</returns>
        </member>
        <member name="T:C5.IDictionary`2">
            <summary>
            A dictionary with keys of type K and values of type V. Equivalent to a
            finite partial map from K to V.
            </summary>
        </member>
        <member name="M:C5.IDictionary`2.Add(`0,`1)">
            <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            <exception cref="T:System.InvalidOperationException"/> if there already is an entry with the same key. 
            </summary>
            <param name="key">Key to add</param>
            <param name="val">Value to add</param>
        </member>
        <member name="M:C5.IDictionary`2.Remove(`0)">
            <summary>
            Remove an entry with a given key from the dictionary
            </summary>
            <param name="key">The key of the entry to remove</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.IDictionary`2.Remove(`0,`1@)">
            <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
            <param name="key">The key of the entry to remove</param>
            <param name="val">On exit, the value of the removed entry</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.IDictionary`2.Clear">
            <summary>
            Remove all entries from the dictionary
            </summary>
        </member>
        <member name="M:C5.IDictionary`2.Contains(`0)">
            <summary>
            Check if there is an entry with a specified key
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.Find(`0,`1@)">
            <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On exit, the value of the entry</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.Update(`0,`1)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The new value</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.FindOrAdd(`0,`1@)">
            <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.IDictionary`2.UpdateOrAdd(`0,`1)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The value to add or replace with.</param>
            <returns>True if key was found and value updated.</returns>
        </member>
        <member name="M:C5.IDictionary`2.Check">
            <summary>
            Check the integrity of the internal data structures of this dictionary.
            Only avaliable in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:C5.IDictionary`2.Item(`0)">
            <summary>
            Indexer for dictionary.
            <exception cref="T:System.InvalidOperationException"/> if no entry is found. 
            </summary>
            <value>The value corresponding to the key</value>
        </member>
        <member name="P:C5.IDictionary`2.Count">
            <summary>
            
            </summary>
            <value>The number of entrues in the dictionary</value>
        </member>
        <member name="P:C5.IDictionary`2.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if dictionary is read  only</value>
        </member>
        <member name="P:C5.IDictionary`2.SyncRoot">
            <summary>
            
            </summary>
            <value>The distinguished object to use for locking to synchronize multithreaded access</value>
        </member>
        <member name="P:C5.IDictionary`2.Keys">
            <summary>
            
            </summary>
            <value>A collection containg the all the keys of the dictionary</value>
        </member>
        <member name="P:C5.IDictionary`2.Values">
            <summary>
            
            </summary>
            <value>A collection containing all the values of the dictionary</value>
        </member>
        <member name="T:C5.ISortedDictionary`2">
            <summary>
            A dictionary with sorted keys.
            </summary>
        </member>
        <member name="M:C5.ISortedDictionary`2.Predecessor(`0)">
            <summary>
            Find the entry with the largest key less than a given key.
            <exception cref="T:System.InvalidOperationException"/> if there is no such entry. 
            </summary>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.Successor(`0)">
            <summary>
            Find the entry with the least key greater than a given key.
            <exception cref="T:System.InvalidOperationException"/> if there is no such entry. 
            </summary>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.WeakPredecessor(`0)">
            <summary>
            Find the entry with the largest key less than or equal to a given key.
            <exception cref="T:System.InvalidOperationException"/> if there is no such entry. 
            </summary>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.ISortedDictionary`2.WeakSuccessor(`0)">
            <summary>
            Find the entry with the least key greater than or equal to a given key.
            <exception cref="T:System.InvalidOperationException"/> if there is no such entry. 
            </summary>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="T:C5.TreeBag`1">
            <summary>
            An implementation of Red-Black trees as an indexed, sorted collection with bag semantics,
            cf. <a href="litterature.htm#CLRS">CLRS</a>. (<see cref="T:C5.TreeBag!1"/> for an 
            implementation with set semantics).
            <br/>
            The comparer (sorting order) may be either natural, because the item type is comparable 
            (generic: <see cref="T:C5.IComparable!1"/> or non-generic: System.IComparable) or it can
            be external and supplied by the user in the constructor.
            <br/>
            Each distinct item is only kept in one place in the tree - together with the number
            of times it is a member of the bag. Thus, if two items that are equal according
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.left(C5.TreeBag{`0}.Node)">
            <summary>
            Fetch the left child of n taking node-copying persistence into
            account if relevant. 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.#ctor">
            <summary>
            Create a red-black tree collection with natural comparer and item hasher.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.#ctor(C5.IComparer{`0})">
            <summary>
            Create a red-black tree collection with an external comparer (and natural item hasher,
            assumed consistent).
            </summary>
            <param name="c">The external comparer</param>
        </member>
        <member name="M:C5.TreeBag`1.#ctor(C5.IComparer{`0},C5.IHasher{`0})">
            <summary>
            Create a red-black tree collection with an external comparer aand an external
            item hasher, assumed consistent.
            </summary>
            <param name="c">The external comparer</param>
            <param name="h">The external item hasher</param>
        </member>
        <member name="M:C5.TreeBag`1.GetEnumerator">
            <summary>
            Create an enumerator for this tree
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.TreeBag`1.addIterative(`0,`0@,System.Boolean,System.Boolean@)">
            <summary>
            Add item to tree. If already there, return the found item in the second argument.
            </summary>
            <param name="item">Item to add</param>
            <param name="founditem">item found</param>
            <param name="update">whether item in node should be updated</param>
            <param name="wasfound">true if found in bag, false if not found or tre is a set</param>
            <returns>True if item was added</returns>
        </member>
        <member name="M:C5.TreeBag`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.TreeBag`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.TreeBag`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.TreeBag`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items. <para>The idea is that the implementation may use
            a faster algorithm to merge the two collections.</para>
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:C5.TreeBag`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.FindOrAdd(`0@)">
             <summary>
             Find or add the item to the tree. If the tree does not contain
             an item equivalent to this item add it, else return the exisiting
             one in the ref argument. 
            
             </summary>
             <param name="item"></param>
             <returns>True if item was found</returns>
        </member>
        <member name="M:C5.TreeBag`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.TreeBag`1.UpdateOrAdd(`0)">
             <summary>
             Check if this collection contains an item equivalent according to the
             itemhasher to a particular value. If so, update the item in the collection 
             to with a binary copy of the supplied value; else add the value to the collection. 
            
             <p>NOTE: the bag implementation is currently wrong!</p>
             </summary>
             <param name="item">Value to add or update.</param>
             <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.TreeBag`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveWithReturn(`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeBag`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.TreeBag`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.TreeBag`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>NoDuplicates==false</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.FindAll(C5.Filter{`0})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Map``1(C5.Mapper{`0,``0},C5.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.TreeBag`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.TreeBag`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.TreeBag`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than the minimum of this collection.)
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)
            </summary>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeBag`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-decreasing function from the item type to <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-decreasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is negative (if any).</param>
            <param name="lowIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is positive (if any).</param>
            <param name="highIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeBag`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.TreeBag`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.TreeBag`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.TreeBag`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.TreeBag`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeBag`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeBag`1.Dispose">
            <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Finalize">
            <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Snapshot">
            <summary>
            Make a (read-only) snap shot of this collection.
            </summary>
            <returns>The snap shot.</returns>
        </member>
        <member name="M:C5.TreeBag`1.minidump(C5.TreeBag{`0}.Node,System.String)">
            <summary>
            Display this node on the console, and recursively its subnodes.
            </summary>
            <param name="n">Node to display</param>
            <param name="space">Indentation</param>
        </member>
        <member name="M:C5.TreeBag`1.dump">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.dump(System.String)">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.dump(System.String,System.String)">
            <summary>
            Display this tree on the console.
            </summary>
            <param name="msg">Identifying string of this call to dump</param>
            <param name="err">Extra (error)message to include</param>
        </member>
        <member name="M:C5.TreeBag`1.massert(System.Boolean,C5.TreeBag{`0}.Node,System.String,System.IO.TextWriter)">
            <summary>
            Print warning m on o if b is false.
            </summary>
            <param name="b">Condition that should hold</param>
            <param name="n">Place (used for id display)</param>
            <param name="m">Message</param>
            <param name="o">Output stream</param>
            <returns>b</returns>
        </member>
        <member name="M:C5.TreeBag`1.Check(System.String)">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <param name="name">Title of dump</param>
            <returns>false if invariant violation</returns>
        </member>
        <member name="M:C5.TreeBag`1.Check">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <returns>false if invariant violation</returns>
        </member>
        <member name="P:C5.TreeBag`1.Features">
            <summary>
            A debugging aid for making the selected compilation alternatives 
            available to the user. (To be removed when selection is finally fixed
            for production version).
            </summary>
        </member>
        <member name="P:C5.TreeBag`1.AllowsDuplicates">
            <summary></summary>
            <value>True since this collection has bag semantics.</value>
        </member>
        <member name="P:C5.TreeBag`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Log</value>
        </member>
        <member name="P:C5.TreeBag`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="P:C5.TreeBag`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="end">The high index of the interval (exclusive).</param>
        </member>
        <member name="P:C5.TreeBag`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="T:C5.TreeBag`1.Feature">
            <summary>
            A debugging aid for making the selected compilation alternatives 
            available to the user. (To be removed when selection is finally fixed
            for production version).
            </summary>
        </member>
        <member name="F:C5.TreeBag`1.Feature.Dummy">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:C5.TreeBag`1.Feature.NodeCopyPersistence">
            <summary>
            Node copy persistence as explained in <a href="litterature.htm#Tarjan1">Tarjan1</a>
            </summary>
        </member>
        <member name="F:C5.TreeBag`1.Feature.Sizes">
            <summary>
            Maintain sub tree sizes
            </summary>
        </member>
        <member name="F:C5.TreeBag`1.Feature.Heights">
            <summary>
            Maintain precise node heights
            </summary>
        </member>
        <member name="F:C5.TreeBag`1.Feature.Ranks">
            <summary>
            Maintain node ranks (~ black height)
            </summary>
        </member>
        <member name="F:C5.TreeBag`1.Feature.Traceid">
            <summary>
            Maintain unique ids on tree nodes.
            </summary>
        </member>
        <member name="T:C5.TreeBag`1.Node">
            <summary>
            The type of node in a Red-Black binary tree
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Node.update(C5.TreeBag{`0}.Node@,System.Boolean,C5.TreeBag{`0}.Node,System.Int32,System.Int32)">
            <summary>
            Update a child pointer
            </summary>
            <param name="cursor"></param>
            <param name="leftnode"></param>
            <param name="child"></param>
            <param name="maxsnapid"></param>
            <param name="generation"></param>
            <returns>True if node was *copied*</returns>
        </member>
        <member name="T:C5.TreeBag`1.Enumerator">
            <summary>
            An enumerator for a red-black tree collection. Based on an explicit stack
            of subtrees waiting to be enumerated. Currently only used for the tree set 
            enumerators (tree bag enumerators use an iterator block based enumerator).
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.#ctor(C5.TreeBag{`0})">
            <summary>
            Create a tree enumerator
            </summary>
            <param name="tree">The red-black tree to enumerate</param>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:System.InvalidOperationException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.Dispose">
            <summary>
            Call Dispose(true) and then suppress finalization of this enumerator.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.Dispose(System.Boolean)">
            <summary>
            Remove the internal data (notably the stack array).
            </summary>
            <param name="disposing">True if called from Dispose(),
            false if called from the finalizer</param>
        </member>
        <member name="M:C5.TreeBag`1.Enumerator.Finalize">
            <summary>
            Finalizer for enumeratir
            </summary>
        </member>
        <member name="P:C5.TreeBag`1.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current item of the enumerator.</value>
        </member>
        <member name="T:C5.TreeBag`1.SnapEnumerator">
            <summary>
            An enumerator for a snapshot of a node copy persistent red-black tree
            collection.
            </summary>
        </member>
        <member name="M:C5.TreeBag`1.SnapEnumerator.#ctor(C5.TreeBag{`0})">
            <summary>
            Creta an enumerator for a snapshot of a node copy persistent red-black tree
            collection
            </summary>
            <param name="tree">The snapshot</param>
        </member>
        <member name="M:C5.TreeBag`1.SnapEnumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:System.InvalidOperationException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:C5.TreeBag`1.SnapEnumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:C5.TreeBag`1.Range.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:System.InvalidOperationException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:C5.TreeBag`1.Range.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="T:C5.TreeDictionary`2">
            <summary>
            A sorted generic dictionary based on a red-black tree set.
            </summary>
        </member>
        <member name="T:C5.DictionaryBase`2">
            <summary>
            A base class for implementing a dictionary based on a set collection implementation.
            <p>See the source code for <see cref="T:C5.HashDictionary!2"/> for an example</p>
            
            </summary>
        </member>
        <member name="F:C5.DictionaryBase`2.pairs">
            <summary>
            The set collection of entries underlying this dictionary implementation
            </summary>
        </member>
        <member name="M:C5.DictionaryBase`2.Add(`0,`1)">
            <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            <exception cref="T:System.InvalidOperationException"/> if there already is an entry with the same key. 
            </summary>
            <param name="key">Key to add</param>
            <param name="val">Value to add</param>
        </member>
        <member name="M:C5.DictionaryBase`2.Remove(`0)">
            <summary>
            Remove an entry with a given key from the dictionary
            </summary>
            <param name="key">The key of the entry to remove</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Remove(`0,`1@)">
            <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
            <param name="key">The key of the entry to remove</param>
            <param name="val">On exit, the value of the removed entry</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Clear">
            <summary>
            Remove all entries from the dictionary
            </summary>
        </member>
        <member name="M:C5.DictionaryBase`2.Contains(`0)">
            <summary>
            Check if there is an entry with a specified key
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Find(`0,`1@)">
            <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On exit, the value of the entry</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Update(`0,`1)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The new value</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.FindOrAdd(`0,`1@)">
            <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.UpdateOrAdd(`0,`1)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The value to add or replace with.</param>
            <returns>True if entry was updated.</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.Check">
            <summary>
            Check the integrity of the internal data structures of this dictionary.
            Only avaliable in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="M:C5.DictionaryBase`2.GetEnumerator">
            <summary>
            Create an enumerator for the collection of entries of the dictionary
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:C5.DictionaryBase`2.Count">
            <summary>
            
            </summary>
            <value>The number of entrues in the dictionary</value>
        </member>
        <member name="P:C5.DictionaryBase`2.SyncRoot">
            <summary>
            
            </summary>
            <value>A distinguished object to use for locking to synchronize multithreaded access</value>
        </member>
        <member name="P:C5.DictionaryBase`2.Keys">
            <summary>
            
            </summary>
            <value>A collection containg the all the keys of the dictionary</value>
        </member>
        <member name="P:C5.DictionaryBase`2.Values">
            <summary>
            
            </summary>
            <value>A collection containing all the values of the dictionary</value>
        </member>
        <member name="P:C5.DictionaryBase`2.Item(`0)">
            <summary>
            Indexer for dictionary.
            <exception cref="T:System.InvalidOperationException"/> if no entry is found. 
            </summary>
            <value>The value corresponding to the key</value>
        </member>
        <member name="P:C5.DictionaryBase`2.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if dictionary is read  only</value>
        </member>
        <member name="M:C5.TreeDictionary`2.#ctor">
            <summary>
            Create a red-black tree dictionary using the natural comparer for keys.
            <exception cref="T:System.ArgumentException"/> if the key type K is not comparable.
            </summary>
        </member>
        <member name="M:C5.TreeDictionary`2.#ctor(C5.IComparer{`0})">
            <summary>
            Create a red-black tree dictionary using an external comparer for keys.
            </summary>
            <param name="c">The external comparer</param>
        </member>
        <member name="M:C5.TreeDictionary`2.Predecessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            predecessor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.TreeDictionary`2.WeakPredecessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            weak predecessor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.TreeDictionary`2.Successor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            successor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.TreeDictionary`2.WeakSuccessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            weak successor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.TreeDictionary`2.Snapshot">
            <summary>
            Make a snapshot of the current state of this dictionary
            </summary>
            <returns>The snapshot</returns>
        </member>
        <member name="T:C5.HashedLinkedList`1">
            <summary>
            A list collection based on a doubly linked list data structure with 
            a hash index mapping item to node.
            </summary>
        </member>
        <member name="T:C5.LinkedList`1">
            <summary>
            A list collection class based on a doubly linked list data structure.
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.fIFO">
            <summary>
            IExtensible.Add(T) always does AddLast(T), fIFO determines 
            if T Remove() does RemoveFirst() or RemoveLast()
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.maintaintags">
            <summary>
            True if we maintain tags for node ordering (false for plain linked list, true for hashed linked list).
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.startsentinel">
            <summary>
            Node to the left of first node 
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.endsentinel">
            <summary>
            Node to the right of last node
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.offset">
            <summary>
            Offset of this view in underlying list
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.underlying">
            <summary>
            underlying list of theis view (or null)
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.updatecheck">
            <summary>
            Check if it is valid to perform updates and increment stamp.
            <exception cref="T:System.InvalidOperationException"/> if check fails.
            <br/>This method should be called at the start of any public modifying methods.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.modifycheck">
            <summary>
            Check if we are a view that the underlyinglist has only been updated through us.
            <exception cref="T:System.InvalidOperationException"/> if check fails.
            <br/>
            This method should be called from enumerators etc to guard against 
            modification of the base collection.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.modifycheck(System.Int32)">
            <summary>
            Check that the list has not been updated since a particular time.
            <exception cref="T:System.InvalidOperationException"/> if check fails.
            </summary>
            <param name="stamp">The stamp indicating the time.</param>
        </member>
        <member name="M:C5.LinkedList`1.insertNode(C5.LinkedList{`0}.Node,C5.LinkedList{`0}.Node)">
            <summary>
            Insert a Node before another one. Unchecked internal version.
            </summary>
            <param name="succ">The successor to be</param>
            <param name="newnode">Node to insert</param>
        </member>
        <member name="M:C5.LinkedList`1.remove(C5.LinkedList{`0}.Node)">
            <summary>
            Remove a node. Unchecked internal version.
            </summary>
            <param name="node">Node to remove</param>
            <returns>The item of the removed node</returns>
        </member>
        <member name="M:C5.LinkedList`1.gettaggroup(C5.LinkedList{`0}.Node,C5.LinkedList{`0}.Node,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="pred"></param>
            <param name="succ"></param>
            <param name="lowbound"></param>
            <param name="highbound"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.settag(C5.LinkedList{`0}.Node)">
            <summary>
            Put a tag on a node (already inserted in the list). Split taggroups and renumber as 
            necessary.
            </summary>
            <param name="node">The node to tag</param>
        </member>
        <member name="M:C5.LinkedList`1.removefromtaggroup(C5.LinkedList{`0}.Node)">
            <summary>
            Remove a node from its taggroup.
            <br/> When this is called, node must already have been removed from the underlying list
            </summary>
            <param name="node">The node to remove</param>
        </member>
        <member name="M:C5.LinkedList`1.splittaggroup(C5.LinkedList{`0}.TagGroup)">
            <summary>
            Split a tag group to make rom for more tags.
            </summary>
            <param name="taggroup">The tag group</param>
        </member>
        <member name="M:C5.LinkedList`1.#ctor(C5.IHasher{`0})">
            <summary>
            Create a linked list with en external item hasher
            </summary>
            <param name="itemhasher">The external hasher</param>
        </member>
        <member name="M:C5.LinkedList`1.#ctor">
            <summary>
            Create a linked list with the nmatural item hasher
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.get(System.Int32)">
            <summary>
            Return the node at position n
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:C5.LinkedList`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.</summary>
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.
            </summary>
            <param name="i">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.LinkedList`1.InsertBefore(`0,`0)">
            <summary>
            Insert an item right before the first occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target before which to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.InsertAfter(`0,`0)">
            <summary>
            Insert an item right after the last(???) occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target after which to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.LinkedList`1.Map``1(C5.Mapper{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list.
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Map``1(C5.Mapper{`0,``0},C5.IHasher{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified hasher for the item type.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="hasher">The hasher to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the start or count is negative
            <exception cref="T:System.ArgumentException"/> if the range does not fit within list.
            </summary>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            <exception cref="T:System.InvalidOperationException"/> if this list is not a view.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the operation
            would bring either end of the view outside the underlying list.
            </summary>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.LinkedList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, changing its size.
            <exception cref="T:System.InvalidOperationException"/> if this list is not a view.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the operation
            would bring either end of the view outside the underlying list.
            </summary>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.LinkedList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverst part of the list so the items are in the opposite sequence order.
            <exception cref="T:System.ArgumentException"/> if the count is negative.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the part does not fit
            into the list.
            </summary>
            <param name="start">The index of the start of the part to reverse.</param>
            <param name="count">The size of the part to reverse.</param>
        </member>
        <member name="M:C5.LinkedList`1.IsSorted(C5.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Sort(C5.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            The sorting is stable.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.LinkedList`1.Shuffle">
            <summary>
            Randonmly shuffle the items of this list. 
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="M:C5.LinkedList`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.LinkedList`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.LinkedList`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.LinkedList`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. Will update a single item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.LinkedList`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.LinkedList`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was updated (hence not added).</returns>
        </member>
        <member name="M:C5.LinkedList`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. Since the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveWithReturn(`0@)">
            <summary>
            Remove a particular item from this collection if found (only one copy). 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.LinkedList`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.LinkedList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection
            with respect to multiplicities.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.LinkedList`1.FindAll(C5.Filter{`0})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.LinkedList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.LinkedList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.LinkedList`1.GetEnumerator">
            <summary>
            Create an enumerator for the collection
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.LinkedList`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. 
            </summary>
            <param name="item">The item to add.</param>
            <returns>True.</returns>
        </member>
        <member name="M:C5.LinkedList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection. 
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.LinkedList`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.LinkedList`1.Push(`0)">
            <summary>
            Push an item to the top of the stack.
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.LinkedList`1.Pop">
            <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="M:C5.LinkedList`1.EnQueue(`0)">
            <summary>
            Enqueue an item at the back of the queue. 
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.LinkedList`1.DeQueue">
            <summary>
            Dequeue an item from the front of the queue.
            </summary>
            <returns>The item</returns>
        </member>
        <member name="M:C5.LinkedList`1.Check">
            <summary>
            Check the sanity of this list
            </summary>
            <returns>true if sane</returns>
        </member>
        <member name="P:C5.LinkedList`1.First">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.LinkedList`1.Last">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.LinkedList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end.</value>
        </member>
        <member name="P:C5.LinkedList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="index">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.LinkedList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.LinkedList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for a underlying list.</value>
        </member>
        <member name="P:C5.LinkedList`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="P:C5.LinkedList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Linear</value>
        </member>
        <member name="P:C5.LinkedList`1.Count">
            <summary>
            
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="P:C5.LinkedList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True since this collection has bag semantics.</value>
        </member>
        <member name="T:C5.LinkedList`1.Node">
            <summary>
            An individual cell in the linked list
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.Node.prev">
            <summary>
            Previous-node reference
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.Node.next">
            <summary>
            Next-node reference
            </summary>
        </member>
        <member name="F:C5.LinkedList`1.Node.item">
            <summary>
            Node item
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.Node.#ctor(`0)">
            <summary>
            Create node
            </summary>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:C5.LinkedList`1.Node.#ctor(`0,C5.LinkedList{`0}.Node,C5.LinkedList{`0}.Node)">
            <summary>
            Create node, specifying predecessor and successor
            </summary>
            <param name="item"></param>
            <param name="prev"></param>
            <param name="next"></param>
        </member>
        <member name="M:C5.LinkedList`1.Node.ToString">
            <summary>
            Pretty print node
            </summary>
            <returns>Formatted node</returns>
        </member>
        <member name="T:C5.LinkedList`1.TagGroup">
            <summary>
            A group of nodes with the same high tag. Purpose is to be
            able to tell the sequence order of two nodes without having to scan through
            the list.
            </summary>
        </member>
        <member name="M:C5.LinkedList`1.TagGroup.ToString">
            <summary>
            Pretty print a tag group
            </summary>
            <returns>Formatted tag group</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.#ctor(C5.IHasher{`0})">
            <summary>
            Create a hashed linked list with an external item hasher.
            </summary>
            <param name="itemhasher">The external hasher</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.#ctor">
            <summary>
            Create a hashed linked list with the natural item hasher.
            </summary>
        </member>
        <member name="M:C5.HashedLinkedList`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.</summary>
            <exception cref="T:System.InvalidOperationException"/> if  the item is 
            already in the list.
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.
            <exception cref="T:System.InvalidOperationException"/> if one of the items to insert is
            already in the list.
            </summary>
            <param name="i">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertBefore(`0,`0)">
            <summary>
            Insert an item right before the first occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found
            <exception cref="T:System.InvalidOperationException"/> if the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target before which to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertAfter(`0,`0)">
            <summary>
            Insert an item right after the last(???) occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found
            <exception cref="T:System.InvalidOperationException"/> if the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target after which to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list.
            <exception cref="T:System.InvalidOperationException"/> if the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            <exception cref="T:System.InvalidOperationException"/> if  the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the view would not fit into
            this list.
            </summary>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverst part of the list so the items are in the opposite sequence order.
            <exception cref="T:System.ArgumentException"/> if the count is negative.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the part does not fit
            into the list.
            </summary>
            <param name="start">The index of the start of the part to reverse.</param>
            <param name="count">The size of the part to reverse.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. 
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveWithReturn(`0@)">
            <summary>
            Remove a particular item from this collection if found. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. 
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.HashedLinkedList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. 
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection
            Multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. Since this collection has set
            semantics, the item will be added if not already in the collection. 
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.HashedLinkedList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection.
            Only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            Only items not already in the collection
            will be added.
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashedLinkedList`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            Only avaliable in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:C5.HashedLinkedList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.HashedLinkedList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Constant</value>
        </member>
        <member name="P:C5.HashedLinkedList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>False since this collection has set semantics.</value>
        </member>
        <member name="T:C5.KeyValuePair`2">
            <summary>
            An entry in a dictionary from K to V.
            </summary>
        </member>
        <member name="F:C5.KeyValuePair`2.key">
            <summary>
            The key field of the entry
            </summary>
        </member>
        <member name="F:C5.KeyValuePair`2.value">
            <summary>
            The value field of the entry
            </summary>
        </member>
        <member name="M:C5.KeyValuePair`2.#ctor(`0,`1)">
            <summary>
            Create an entry with specified key and value
            </summary>
            <param name="k">The key</param>
            <param name="v">The value</param>
        </member>
        <member name="M:C5.KeyValuePair`2.#ctor(`0)">
            <summary>
            Create an entry with a specified key. The value is undefined.
            </summary>
            <param name="k">The key</param>
        </member>
        <member name="M:C5.KeyValuePair`2.ToString">
            <summary>
            Pretty print an entry
            </summary>
            <returns>(key, value)</returns>
        </member>
        <member name="M:C5.KeyValuePair`2.Equals(System.Object)">
            <summary>
            Check equality of entries
            </summary>
            <param name="obj">The other object</param>
            <returns>True if obj is an entry of the same type and has the same key</returns>
        </member>
        <member name="M:C5.KeyValuePair`2.GetHashCode">
            <summary>
            Get the hash code of the key.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="T:C5.KeyValuePairComparer`2">
            <summary>
            Default comparer for dictionary entries in a sorted dictionary.
            Entry comparisons only look at keys.
            </summary>
        </member>
        <member name="M:C5.KeyValuePairComparer`2.#ctor(C5.IComparer{`0})">
            <summary>
            Create an entry comparer for a item comparer of the keys
            </summary>
            <param name="c">Comparer of keys</param>
        </member>
        <member name="M:C5.KeyValuePairComparer`2.Compare(C5.KeyValuePair{`0,`1},C5.KeyValuePair{`0,`1})">
            <summary>
            Compare two entries
            </summary>
            <param name="a">First entry</param>
            <param name="b">Second entry</param>
            <returns>The result of comparing the keys</returns>
        </member>
        <member name="T:C5.KeyValuePairHasher`2">
            <summary>
            Default hasher for dictionary entries.
            Operations only look at keys.
            </summary>
        </member>
        <member name="M:C5.KeyValuePairHasher`2.#ctor">
            <summary>
            Create an entry hasher using the default hasher for keys
            </summary>
        </member>
        <member name="M:C5.KeyValuePairHasher`2.#ctor(C5.IHasher{`0})">
            <summary>
            Create an entry hasher from a specified item hasher for the keys
            </summary>
            <param name="c">The key hasher</param>
        </member>
        <member name="M:C5.KeyValuePairHasher`2.GetHashCode(C5.KeyValuePair{`0,`1})">
            <summary>
            Get the hash code of the entry
            </summary>
            <param name="item">The entry</param>
            <returns>The hash code of the key</returns>
        </member>
        <member name="M:C5.KeyValuePairHasher`2.Equals(C5.KeyValuePair{`0,`1},C5.KeyValuePair{`0,`1})">
            <summary>
            Test two entries for equality
            </summary>
            <param name="i1">First entry</param>
            <param name="i2">Second entry</param>
            <returns>True if keys are equal</returns>
        </member>
        <member name="T:C5.TreeSet`1">
             <summary>
             An implementation of Red-Black trees as an indexed, sorted collection with set semantics,
             cf. <a href="litterature.htm#CLRS">CLRS</a>. <see cref="T:C5.TreeBag!1"/> for a version 
             with bag semantics. <see cref="T:C5.TreeDictionary!2"/> for a sorted dictionary 
             based on this tree implementation.
             <p>
             The comparer (sorting order) may be either natural, because the item type is comparable 
             (generic: <see cref="T:C5.IComparable!1"/> or non-generic: System.IComparable) or it can
             be external and supplied by the user in the constructor.</p>
            
             <p><i>TODO: describe performance here</i></p>
             <p><i>TODO: discuss persistence and its useful usage modes. Warn about the space
             leak possible with other usage modes.</i></p>
             </summary>
        </member>
        <member name="M:C5.TreeSet`1.left(C5.TreeSet{`0}.Node)">
            <summary>
            Fetch the left child of n taking node-copying persistence into
            account if relevant. 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.#ctor">
            <summary>
            Create a red-black tree collection with natural comparer and item hasher.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.#ctor(C5.IComparer{`0})">
            <summary>
            Create a red-black tree collection with an external comparer (and natural item hasher,
            assumed consistent).
            </summary>
            <param name="c">The external comparer</param>
        </member>
        <member name="M:C5.TreeSet`1.#ctor(C5.IComparer{`0},C5.IHasher{`0})">
            <summary>
            Create a red-black tree collection with an external comparer aand an external
            item hasher, assumed consistent.
            </summary>
            <param name="c">The external comparer</param>
            <param name="h">The external item hasher</param>
        </member>
        <member name="M:C5.TreeSet`1.GetEnumerator">
            <summary>
            Create an enumerator for this tree
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.TreeSet`1.addIterative(`0,`0@,System.Boolean,System.Boolean@)">
            <summary>
            Add item to tree. If already there, return the found item in the second argument.
            </summary>
            <param name="item">Item to add</param>
            <param name="founditem">item found</param>
            <param name="update">whether item in node should be updated</param>
            <param name="wasfound">true if found in bag, false if not found or tre is a set</param>
            <returns>True if item was added</returns>
        </member>
        <member name="M:C5.TreeSet`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.TreeSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.TreeSet`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.TreeSet`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items. <para>The idea is that the implementation may use
            a faster algorithm to merge the two collections.</para>
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:C5.TreeSet`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.FindOrAdd(`0@)">
             <summary>
             Find or add the item to the tree. If the tree does not contain
             an item equivalent to this item add it, else return the exisiting
             one in the ref argument. 
            
             </summary>
             <param name="item"></param>
             <returns>True if item was found</returns>
        </member>
        <member name="M:C5.TreeSet`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.TreeSet`1.UpdateOrAdd(`0)">
             <summary>
             Check if this collection contains an item equivalent according to the
             itemhasher to a particular value. If so, update the item in the collection 
             to with a binary copy of the supplied value; else add the value to the collection. 
            
             <p>NOTE: the bag implementation is currently wrong!</p>
             </summary>
             <param name="item">Value to add or update.</param>
             <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.TreeSet`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveWithReturn(`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.TreeSet`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.TreeSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.TreeSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>NoDuplicates==false</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.FindAll(C5.Filter{`0})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Map``1(C5.Mapper{`0,``0},C5.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.TreeSet`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.TreeSet`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.TreeSet`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than the minimum of this collection.)
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)
            </summary>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.TreeSet`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-decreasing function from the item type to <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-decreasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is negative (if any).</param>
            <param name="lowIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is positive (if any).</param>
            <param name="highIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:C5.TreeSet`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.TreeSet`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.TreeSet`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.TreeSet`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.TreeSet`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeSet`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.TreeSet`1.Dispose">
            <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Finalize">
            <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Snapshot">
            <summary>
            Make a (read-only) snap shot of this collection.
            </summary>
            <returns>The snap shot.</returns>
        </member>
        <member name="M:C5.TreeSet`1.minidump(C5.TreeSet{`0}.Node,System.String)">
            <summary>
            Display this node on the console, and recursively its subnodes.
            </summary>
            <param name="n">Node to display</param>
            <param name="space">Indentation</param>
        </member>
        <member name="M:C5.TreeSet`1.dump">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.dump(System.String)">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.dump(System.String,System.String)">
            <summary>
            Display this tree on the console.
            </summary>
            <param name="msg">Identifying string of this call to dump</param>
            <param name="err">Extra (error)message to include</param>
        </member>
        <member name="M:C5.TreeSet`1.massert(System.Boolean,C5.TreeSet{`0}.Node,System.String,System.IO.TextWriter)">
            <summary>
            Print warning m on o if b is false.
            </summary>
            <param name="b">Condition that should hold</param>
            <param name="n">Place (used for id display)</param>
            <param name="m">Message</param>
            <param name="o">Output stream</param>
            <returns>b</returns>
        </member>
        <member name="M:C5.TreeSet`1.Check(System.String)">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <param name="name">Title of dump</param>
            <returns>false if invariant violation</returns>
        </member>
        <member name="M:C5.TreeSet`1.Check">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <returns>false if invariant violation</returns>
        </member>
        <member name="P:C5.TreeSet`1.Features">
            <summary>
            A debugging aid for making the selected compilation alternatives 
            available to the user. (To be removed when selection is finally fixed
            for production version).
            </summary>
        </member>
        <member name="P:C5.TreeSet`1.AllowsDuplicates">
            <summary></summary>
            <value>False since this tree has set semantics.</value>
        </member>
        <member name="P:C5.TreeSet`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Log</value>
        </member>
        <member name="P:C5.TreeSet`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="P:C5.TreeSet`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="end">The high index of the interval (exclusive).</param>
        </member>
        <member name="P:C5.TreeSet`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="T:C5.TreeSet`1.Feature">
            <summary>
            A debugging aid for making the selected compilation alternatives 
            available to the user. (To be removed when selection is finally fixed
            for production version).
            </summary>
        </member>
        <member name="F:C5.TreeSet`1.Feature.Dummy">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:C5.TreeSet`1.Feature.NodeCopyPersistence">
            <summary>
            Node copy persistence as explained in <a href="litterature.htm#Tarjan1">Tarjan1</a>
            </summary>
        </member>
        <member name="F:C5.TreeSet`1.Feature.Sizes">
            <summary>
            Maintain sub tree sizes
            </summary>
        </member>
        <member name="F:C5.TreeSet`1.Feature.Heights">
            <summary>
            Maintain precise node heights
            </summary>
        </member>
        <member name="F:C5.TreeSet`1.Feature.Ranks">
            <summary>
            Maintain node ranks (~ black height)
            </summary>
        </member>
        <member name="F:C5.TreeSet`1.Feature.Traceid">
            <summary>
            Maintain unique ids on tree nodes.
            </summary>
        </member>
        <member name="T:C5.TreeSet`1.Node">
            <summary>
            The type of node in a Red-Black binary tree
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Node.update(C5.TreeSet{`0}.Node@,System.Boolean,C5.TreeSet{`0}.Node,System.Int32,System.Int32)">
            <summary>
            Update a child pointer
            </summary>
            <param name="cursor"></param>
            <param name="leftnode"></param>
            <param name="child"></param>
            <param name="maxsnapid"></param>
            <param name="generation"></param>
            <returns>True if node was *copied*</returns>
        </member>
        <member name="T:C5.TreeSet`1.Enumerator">
            <summary>
            An enumerator for a red-black tree collection. Based on an explicit stack
            of subtrees waiting to be enumerated. Currently only used for the tree set 
            enumerators (tree bag enumerators use an iterator block based enumerator).
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.#ctor(C5.TreeSet{`0})">
            <summary>
            Create a tree enumerator
            </summary>
            <param name="tree">The red-black tree to enumerate</param>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:System.InvalidOperationException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.Dispose">
            <summary>
            Call Dispose(true) and then suppress finalization of this enumerator.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.Dispose(System.Boolean)">
            <summary>
            Remove the internal data (notably the stack array).
            </summary>
            <param name="disposing">True if called from Dispose(),
            false if called from the finalizer</param>
        </member>
        <member name="M:C5.TreeSet`1.Enumerator.Finalize">
            <summary>
            Finalizer for enumeratir
            </summary>
        </member>
        <member name="P:C5.TreeSet`1.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current item of the enumerator.</value>
        </member>
        <member name="T:C5.TreeSet`1.SnapEnumerator">
            <summary>
            An enumerator for a snapshot of a node copy persistent red-black tree
            collection.
            </summary>
        </member>
        <member name="M:C5.TreeSet`1.SnapEnumerator.#ctor(C5.TreeSet{`0})">
            <summary>
            Creta an enumerator for a snapshot of a node copy persistent red-black tree
            collection
            </summary>
            <param name="tree">The snapshot</param>
        </member>
        <member name="M:C5.TreeSet`1.SnapEnumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:System.InvalidOperationException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:C5.TreeSet`1.SnapEnumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:C5.TreeSet`1.Range.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:System.InvalidOperationException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:C5.TreeSet`1.Range.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="T:C5.IntervalHeap`1">
            <summary>
            A priority queue class based on an interval heap data structure.
            </summary>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor">
            <summary>
            Create an interval heap with natural item comparer and default initial capacity (16)
            </summary>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor(C5.IComparer{`0})">
            <summary>
            Create an interval heap with external item comparer and default initial capacity (16)
            </summary>
            <param name="c">The external comparer</param>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor(System.Int32)">
            <summary>
            Create an interval heap with natural item comparer and prescribed initial capacity
            </summary>
            <param name="capacity">The initial capacity</param>
        </member>
        <member name="M:C5.IntervalHeap`1.#ctor(C5.IComparer{`0},System.Int32)">
            <summary>
            Create an interval heap with external item comparer and prescribed initial capacity
            </summary>
            <param name="c">The external comparer</param>
            <param name="capacity">The initial capacity</param>
        </member>
        <member name="M:C5.IntervalHeap`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            <exception cref="T:System.InvalidOperationException"/> if queue is empty
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            <exception cref="T:System.InvalidOperationException"/> if queue is empty
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            <exception cref="T:System.InvalidOperationException"/> if queue is empty
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            <exception cref="T:System.InvalidOperationException"/> if queue is empty
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.Add(`0)">
            <summary>
            Add an item to this priority queue.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection. 
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.IntervalHeap`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.IntervalHeap`1.GetEnumerator">
            <summary>
            Create an enumerator for the collection
            <para>Note: the enumerator does *not* enumerate the items in sorted order, 
            but in the internal table order.</para>
            </summary>
            <returns>The enumerator(SIC)</returns>
        </member>
        <member name="M:C5.IntervalHeap`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            Only avaliable in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:C5.IntervalHeap`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="P:C5.IntervalHeap`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True since this collection has bag semantics</value>
        </member>
        <member name="P:C5.IntervalHeap`1.SyncRoot">
            <summary>
            
            </summary>
            <value>The distinguished object to use for locking to synchronize multithreaded access</value>
        </member>
        <member name="P:C5.IntervalHeap`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty.</value>
        </member>
        <member name="P:C5.IntervalHeap`1.Count">
            <summary>
            
            </summary>
            <value>The size of this collection</value>
        </member>
        <member name="P:C5.IntervalHeap`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="T:C5.HashDictionary`2">
            <summary>
            A generic dictionary class based on a hash set class <see cref="T:C5.HashSet!1"/>.
            </summary>
        </member>
        <member name="M:C5.HashDictionary`2.#ctor">
            <summary>
            Create a hash dictionary using a default hasher for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
        </member>
        <member name="M:C5.HashDictionary`2.#ctor(C5.IHasher{`0})">
            <summary>
            Create a hash dictionary using a custom hasher for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
            <param name="h">The external key hasher</param>
        </member>
        <member name="M:C5.HashDictionary`2.#ctor(System.Int32,System.Double,C5.IHasher{`0})">
            <summary>
            Create a hash dictionary using a custom hasher and prescribing the 
            initial size of the dictionary and a non-default threshold for internal table expansion.
            </summary>
            <param name="capacity">The initial capacity. Will be rounded upwards to nearest
            power of 2, at least 16.</param>
            <param name="fill">The expansion threshold. Must be between 10% and 90%.</param>
            <param name="h">The external key hasher</param>
        </member>
        <member name="T:C5.ArrayList`1">
             <summary>
             A list collection based on a plain dynamic array data structure.
             Expansion of the internal array is performed by doubling on demand. 
             The internal array is only shrinked by the Clear method. 
            
             <p>When the FIFO property is set to false this class works fine as a stack of T.
             When the FIFO property is set to true the class will function as a (FIFO) queue
             but very inefficiently, use a LinkedList (<see cref="T:C5.LinkedList!1"/>) instead.</p>
             </summary>
        </member>
        <member name="F:C5.ArrayList`1.underlying">
            <summary>
            The underlying list if we are a view, null else.
            </summary>
        </member>
        <member name="F:C5.ArrayList`1.underlyingsize">
            <summary>
            The size of the underlying list.
            </summary>
        </member>
        <member name="F:C5.ArrayList`1.fIFO">
            <summary>
            The underlying field of the FIFO property
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.expand">
            <summary>
            Double the size of the internal array.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.expand(System.Int32,System.Int32)">
            <summary>
            Expand the internal array, resetting the index of the first unused element.
            </summary>
            <param name="newcapacity">The new capacity (will be rouded upwards to a power of 2).</param>
            <param name="newsize">The new count of </param>
        </member>
        <member name="M:C5.ArrayList`1.updatecheck">
            <summary>
            Check if it is valid to perform updates and increment stamp.
            <exception cref="T:System.InvalidOperationException"/> if check fails.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.modifycheck">
            <summary>
            Check if we are a view that the underlying list has only been updated through us.
            <exception cref="T:System.InvalidOperationException"/> if check fails.
            <br/>
            This method should be called from enumerators etc to guard against 
            modification of the base collection.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.modifycheck(System.Int32)">
            <summary>
            Check that the list has not been updated since a particular time.
            <exception cref="T:System.InvalidOperationException"/> if check fails.
            </summary>
            <param name="stamp">The stamp indicating the time.</param>
        </member>
        <member name="M:C5.ArrayList`1.addtosize(System.Int32)">
            <summary>
            Increment or decrement the private size fields
            </summary>
            <param name="delta">Increment (with sign)</param>
        </member>
        <member name="M:C5.ArrayList`1.indexOf(`0)">
            <summary>
            Internal version of IndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of first occurrence</returns>
        </member>
        <member name="M:C5.ArrayList`1.lastIndexOf(`0)">
            <summary>
            Internal version of LastIndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of last occurrence</returns>
        </member>
        <member name="M:C5.ArrayList`1.insert(System.Int32,`0)">
            <summary>
            Internal version of Insert with no modification checks.
            </summary>
            <param name="i">Index to insert at</param>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:C5.ArrayList`1.removeAt(System.Int32)">
            <summary>
            Internal version of RemoveAt with no modification checks.
            </summary>
            <param name="i">Index to remove at</param>
            <returns>The removed item</returns>
        </member>
        <member name="M:C5.ArrayList`1.#ctor">
            <summary>
            Create an array list with default item hasher and initial capacity 8 items.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.#ctor(C5.IHasher{`0})">
            <summary>
            Create an array list with external item hasher and initial capacity 8 items.
            </summary>
            <param name="hasher">The external hasher</param>
        </member>
        <member name="M:C5.ArrayList`1.#ctor(System.Int32)">
            <summary>
            Create an array list with default item hasher and prescribed initial capacity.
            </summary>
            <param name="capacity">The prescribed capacity</param>
        </member>
        <member name="M:C5.ArrayList`1.#ctor(System.Int32,C5.IHasher{`0})">
            <summary>
            Create an array list with external item hasher and prescribed initial capacity.
            </summary>
            <param name="capacity">The prescribed capacity</param>
            <param name="hasher">The external hasher</param>
        </member>
        <member name="M:C5.ArrayList`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.</summary>
            <param name="i">The index at which to insert.</param>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.
            </summary>
            <param name="i">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.ArrayList`1.InsertBefore(`0,`0)">
            <summary>
            Insert an item right before the first occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target before which to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.InsertAfter(`0,`0)">
            <summary>
            Insert an item right after the last(???) occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target after which to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list;
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:C5.ArrayList`1.FindAll(C5.Filter{`0})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Map``1(C5.Mapper{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default hasher for the item type V.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Map``1(C5.Mapper{`0,``0},C5.IHasher{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified hasher for the item type.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="hasher">The hasher to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveFirst">
            <summary>
            Remove one item from the fromnt of the list.
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this list is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the start or count is negative
            <exception cref="T:System.ArgumentException"/> if the range does not fit within list.
            </summary>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            <exception cref="T:System.InvalidOperationException"/> if this list is not a view.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the operation
            would bring either end of the view outside the underlying list.
            </summary>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:C5.ArrayList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, changing its size.
            <exception cref="T:System.InvalidOperationException"/> if this list is not a view.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the operation
            would bring either end of the view outside the underlying list.
            </summary>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:C5.ArrayList`1.Reverse">
            <summary>
            Reverst the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverst part of the list so the items are in the opposite sequence order.
            <exception cref="T:System.ArgumentException"/> if the count is negative.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the part does not fit
            into the list.
            </summary>
            <param name="start">The index of the start of the part to reverse.</param>
            <param name="count">The size of the part to reverse.</param>
        </member>
        <member name="M:C5.ArrayList`1.IsSorted(C5.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Sort(C5.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.ArrayList`1.Shuffle">
            <summary>
            Randonmly shuffle the items of this list. 
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="M:C5.ArrayList`1.IndexOf(`0)">
            <summary>
            Search for an item in the list going forwrds from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.ArrayList`1.LastIndexOf(`0)">
            <summary>
            Search for an item in the list going backwords from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.ArrayList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.ArrayList`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:C5.ArrayList`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Remove(`0)">
            <summary>
            Remove the first copy of a particular item from this collection. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveWithReturn(`0@)">
            <summary>
            Remove the first copy of a particular item from this collection if found.
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            Matching items will be removed from the front. Current implementation is not optimal.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.ArrayList`1.Clear">
            <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
        </member>
        <member name="M:C5.ArrayList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            Items are retained front first.  Current implementation is not optimal.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.ArrayList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection,
            taking multiplicities into account.
            Current implementation is not optimal.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.ArrayList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:C5.ArrayList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equal to a given one.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.ArrayList`1.Check">
            <summary>
            Check the integrity of the internal data structures of this array list.
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Add(`0)">
            <summary>
            Add an item to end of this list.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True</returns>
        </member>
        <member name="M:C5.ArrayList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection. 
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.ArrayList`1.C5#IDirectedEnumerable{T}#Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="M:C5.ArrayList`1.Push(`0)">
            <summary>
            Push an item to the top of the stack.
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.ArrayList`1.Pop">
            <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="M:C5.ArrayList`1.EnQueue(`0)">
            <summary>
            Enqueue an item at the back of the queue. 
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:C5.ArrayList`1.DeQueue">
            <summary>
            Dequeue an item from the front of the queue.
            </summary>
            <returns>The item</returns>
        </member>
        <member name="P:C5.ArrayList`1.First">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <value>The first item in this list.</value>
        </member>
        <member name="P:C5.ArrayList`1.Last">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if this list is empty.
            </summary>
            <value>The last item in this list.</value>
        </member>
        <member name="P:C5.ArrayList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end.</value>
        </member>
        <member name="P:C5.ArrayList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">The index of the item to fetch or store.</param>
        </member>
        <member name="P:C5.ArrayList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:C5.ArrayList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for an underlying list.</value>
        </member>
        <member name="P:C5.ArrayList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Linear</value>
        </member>
        <member name="P:C5.ArrayList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>True, indicating array list has bag semantics.</value>
        </member>
        <member name="T:C5.ComparerBuilder.FromComparable`1">
            <summary>
            A default item comparer for an item type that is either generic (IComparable&lt;T&gt;)
            or ordinarily (System.IComparable) comparable.
            </summary>
        </member>
        <member name="M:C5.ComparerBuilder.FromComparable`1.Examine">
            <summary>
            Create a default comparer
            <exception cref="T:System.ArgumentException"/> if T is not comparable. 
            </summary>
            <returns>The comparer</returns>
        </member>
        <member name="T:C5.HasherBuilder.SequencedHasher`2">
            <summary>
            Prototype for an sequenced hasher for IIndexed[W]
            This will use the IIndexed[W] specific operations
            </summary>
        </member>
        <member name="M:C5.HasherBuilder.SequencedHasher`2.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this sequenced hasher
            </summary>
            <param name="item">The item</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.HasherBuilder.SequencedHasher`2.Equals(`0,`0)">
            <summary>
            Check if two items are equal with respect to this sequenced hasher
            </summary>
            <param name="i1">first item</param>
            <param name="i2">second item</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:C5.HasherBuilder.UnsequencedHasher`2">
            <summary>
            Prototype for an unsequenced hasher for ICollection[W]
            This will use the ICollection[W] specific operations
            </summary>
        </member>
        <member name="M:C5.HasherBuilder.UnsequencedHasher`2.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this unsequenced hasher
            </summary>
            <param name="item">The item</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:C5.HasherBuilder.UnsequencedHasher`2.Equals(`0,`0)">
            <summary>
            Check if two items are equal with respect to this unsequenced hasher
            </summary>
            <param name="i1">first item</param>
            <param name="i2">second item</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:C5.HasherBuilder.ByPrototype`1">
            <summary>
            Create a hasher for T that is DefaultValueTypeHasher[T] 
            or DefaultReferenceTypeHasher[T] unless T has been 
            instatiated to a type of the exact form IIndexed[W] or ICollection[W]
            in which case Examine will return Sequenced- repectively UnsequencedHasher.
            </summary>
        </member>
        <member name="M:C5.HasherBuilder.ByPrototype`1.Examine">
            <summary>
            See class description
            </summary>
            <returns>The hasher</returns>
        </member>
        <member name="T:C5.HasherBuilder.ByInvoke`1">
            <summary>
            IHasher factory class: examines at instatiation time if T is an
            interface implementing "int GetHashCode()" and "bool Equals(T)".
            If those are not present, MakeHasher will return a default hasher,
            else this class will implement Ihasher[T] via Invoke() on the
            reflected method infos.
            </summary>
        </member>
        <member name="M:C5.HasherBuilder.ByInvoke`1.MakeHasher">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.HasherBuilder.ByInvoke`1.GetHashCode(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HasherBuilder.ByInvoke`1.Equals(`0,`0)">
            <summary>
            
            </summary>
            <param name="i1"></param>
            <param name="i2"></param>
            <returns></returns>
        </member>
        <member name="T:C5.HasherBuilder.ByRTCG">
            <summary>
            Like ByInvoke, but tries to build a hasher by RTCG to
            avoid the Invoke() overhead. Does not work as intended 
            because of a Whidbey RTCG bug.
            </summary>
        </member>
        <member name="M:C5.HasherBuilder.ByRTCG.CreateHasher``1(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            
            </summary>
            <param name="hinfo"></param>
            <param name="einfo"></param>
            <returns></returns>
        </member>
        <member name="M:C5.HasherBuilder.ByRTCG.build``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:C5.HasherBuilder.ByRTCG.dump">
            <summary>
            
            </summary>
        </member>
        <member name="T:C5.HashSet`1">
            <summary>
            A set collection class based on linear hashing
            </summary>
        </member>
        <member name="M:C5.HashSet`1.#ctor">
            <summary>
            Create a hash set with natural item hasher and default fill threshold (66%)
            and initial table size (16).
            </summary>
        </member>
        <member name="M:C5.HashSet`1.#ctor(C5.IHasher{`0})">
            <summary>
            Create a hash set with external item hasher and default fill threshold (66%)
            and initial table size (16).
            </summary>
            <param name="itemhasher">The external item hasher</param>
        </member>
        <member name="M:C5.HashSet`1.#ctor(System.Int32,C5.IHasher{`0})">
            <summary>
            Create a hash set with external item hasher and default fill threshold (66%)
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="itemhasher">The external item hasher</param>
        </member>
        <member name="M:C5.HashSet`1.#ctor(System.Int32,System.Double,C5.IHasher{`0})">
            <summary>
            Create a hash set with external item hasher.
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="fill">Fill threshold (in range 10% to 90%)</param>
            <param name="itemhasher">The external item hasher</param>
        </member>
        <member name="M:C5.HashSet`1.Contains(`0)">
            <summary>
            Check if an item is in the set 
            </summary>
            <param name="item">The item to look for</param>
            <returns>True if set contains item</returns>
        </member>
        <member name="M:C5.HashSet`1.Find(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so report the actual item object found.
            </summary>
            <param name="item">On entry, the item to look for.
            On exit the item found, if any</param>
            <returns>True if set contains item</returns>
        </member>
        <member name="M:C5.HashSet`1.Update(`0)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so replace the item object in the set with the supplied one.
            </summary>
            <param name="item">The item object to update with</param>
            <returns>True if item was found (and updated)</returns>
        </member>
        <member name="M:C5.HashSet`1.FindOrAdd(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set.
            If found, report the actual item object in the set,
            else add the supplied one.
            </summary>
            <param name="item">On entry, the item to look for or add.
            On exit the actual object found, if any.</param>
            <returns>True if item was found</returns>
        </member>
        <member name="M:C5.HashSet`1.UpdateOrAdd(`0)">
            <summary>
            Check if an item (collection equal to a supplied one) is in the set and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
            <param name="item">The item to look for and update or add</param>
            <returns>True if item was updated</returns>
        </member>
        <member name="M:C5.HashSet`1.Remove(`0)">
            <summary>
            Remove an item from the set
            </summary>
            <param name="item">The item to remove</param>
            <returns>True if item was (found and) removed </returns>
        </member>
        <member name="M:C5.HashSet`1.RemoveWithReturn(`0@)">
            <summary>
            Remove an item from the set, reporting the actual matching item object.
            </summary>
            <param name="item">On entry the item to remove.
            On exit, the actual removed item object.</param>
            <returns>True if item was found.</returns>
        </member>
        <member name="M:C5.HashSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a supplied collection from this set.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashSet`1.Clear">
            <summary>
            Remove all items from the set, resetting internal table to initial size.
            </summary>
        </member>
        <member name="M:C5.HashSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items *not* in a supplied collection from this set.
            </summary>
            <param name="items">The items to retain</param>
        </member>
        <member name="M:C5.HashSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if all items in a supplied collection is in this set
            (ignoring multiplicities). 
            </summary>
            <param name="items">The items to look for.</param>
            <returns>True if all items are found.</returns>
        </member>
        <member name="M:C5.HashSet`1.ToArray">
            <summary>
            Create an array containing all items in this set (in enumeration order).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.HashSet`1.ContainsCount(`0)">
            <summary>
            Count the number of times an item is in this set (either 0 or 1).
            </summary>
            <param name="item">The item to look for.</param>
            <returns>1 if item is in set, 0 else</returns>
        </member>
        <member name="M:C5.HashSet`1.RemoveAllCopies(`0)">
            <summary>
            Remove all (at most 1) copies of item from this set.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:C5.HashSet`1.GetEnumerator">
            <summary>
            Create an enumerator for this set.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:C5.HashSet`1.Add(`0)">
            <summary>
            Add an item to this set.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added (i.e. not found)</returns>
        </member>
        <member name="M:C5.HashSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items of a collection to this set.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashSet`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. Since this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.HashSet`1.Check">
            <summary>
            Test internal structure of data (invariants)
            </summary>
            <returns>True if pass</returns>
        </member>
        <member name="M:C5.HashSet`1.BucketSizeDistribution">
            <summary>
            Produce statistics on distribution of bucket sizes. Current implementation is incomplete.
            </summary>
            <returns>Histogram data.</returns>
        </member>
        <member name="P:C5.HashSet`1.Features">
            <summary>
            Show which implementation features was chosen at compilation time
            </summary>
        </member>
        <member name="P:C5.HashSet`1.ContainsSpeed">
            <summary>
            The complexity of the Contains operation
            </summary>
            <value>Always returns Speed.Constant</value>
        </member>
        <member name="P:C5.HashSet`1.AllowsDuplicates">
            <summary>
            Report if this is a set collection.
            </summary>
            <value>Always false</value>
        </member>
        <member name="T:C5.HashSet`1.Feature">
            <summary>
            Enum class to assist printing of compilation alternatives.
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.Dummy">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.RefTypeBucket">
            <summary>
            Buckets are of reference type
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.ValueTypeBucket">
            <summary>
            Primary buckets are of value type
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.LinearProbing">
            <summary>
            Using linear probing to resolve index clashes
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.ShrinkTable">
            <summary>
            Shrink table when very sparsely filled
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.Chaining">
            <summary>
            Use chaining to resolve index clashes
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.InterHasher">
            <summary>
            Use hash function on item hash code
            </summary>
        </member>
        <member name="F:C5.HashSet`1.Feature.RandomInterHasher">
            <summary>
            Use a universal family of hash functions on item hash code
            </summary>
        </member>
        <member name="T:C5.GuardedEnumerator`1">
            <summary>
            A read-only wrapper class for a generic enumerator
            </summary>
        </member>
        <member name="M:C5.GuardedEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Create a wrapper around a generic enumerator
            </summary>
            <param name="enumerator">The enumerator to wrap</param>
        </member>
        <member name="M:C5.GuardedEnumerator`1.MoveNext">
            <summary>
            Move wrapped enumerator to next item, or the first item if
            this is the first call to MoveNext. 
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:C5.GuardedEnumerator`1.Dispose">
            <summary>
            Dispose wrapped enumerator
            </summary>
        </member>
        <member name="P:C5.GuardedEnumerator`1.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current item of the wrapped enumerator.</value>
        </member>
        <member name="T:C5.GuardedEnumerable`1">
             <summary>
             A read-only wrapper class for a generic enumerable
            
             <p>This is mainly interesting as a base of other guard classes</p>
             </summary>
        </member>
        <member name="M:C5.GuardedEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Wrap an enumerable in a read-only wrapper
            </summary>
            <param name="enumerable">The enumerable to wrap</param>
        </member>
        <member name="M:C5.GuardedEnumerable`1.GetEnumerator">
            <summary>
            Get an enumerator from the wrapped enumerable
            </summary>
            <returns>The enumerator (itself wrapped)</returns>
        </member>
        <member name="T:C5.GuardedDirectedEnumerable`1">
             <summary>
             A read-only wrapper for a generic directed enumerable
            
             <p>This is mainly interesting as a base of other guard classes</p>
             </summary>
        </member>
        <member name="M:C5.GuardedDirectedEnumerable`1.#ctor(C5.IDirectedEnumerable{`0})">
            <summary>
            Wrap a directed enumerable in a read-only wrapper
            </summary>
            <param name="directedenumerable">the collection to wrap</param>
        </member>
        <member name="M:C5.GuardedDirectedEnumerable`1.Backwards">
            <summary>
            Get a enumerable that enumerates the wrapped collection in the opposite direction
            </summary>
            <returns>The mirrored enumerable</returns>
        </member>
        <member name="P:C5.GuardedDirectedEnumerable`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.GuardedCollectionValue`1">
             <summary>
             A read-only wrapper for an ICollectionValue&lt;T&gt;
            
             <p>This is mainly interesting as a base of other guard classes</p>
             </summary>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.#ctor(C5.ICollectionValue{`0})">
            <summary>
            Wrap a ICollectionValue&lt;T&gt; in a read-only wrapper
            </summary>
            <param name="collection">the collection to wrap</param>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of the wrapped collection to an array
            </summary>
            <param name="a">The array</param>
            <param name="i">Starting offset</param>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.ToArray">
            <summary>
            Create an array from the items of the wrapped collection
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Apply(C5.Applier{`0})">
            <summary>
            Apply a delegate to all items of the wrapped enumerable.
            </summary>
            <param name="a">The delegate to apply</param>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.Exists(C5.Filter{`0})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in the wrapped enumerable.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter!1"/>) defining the predicate</param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:C5.GuardedCollectionValue`1.All(C5.Filter{`0})">
            <summary>
            Check if all items in the wrapped enumerable satisfies a specific predicate.
            </summary>
            <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter!1"/>) defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="P:C5.GuardedCollectionValue`1.Count">
            <summary>
            Get the size of the wrapped collection
            </summary>
            <value>The size</value>
        </member>
        <member name="P:C5.GuardedCollectionValue`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="T:C5.GuardedDirectedCollectionValue`1">
             <summary>
             A read-only wrapper for a directed collection
            
             <p>This is mainly interesting as a base of other guard classes</p>
             </summary>
        </member>
        <member name="M:C5.GuardedDirectedCollectionValue`1.#ctor(C5.IDirectedCollectionValue{`0})">
            <summary>
            Wrap a directed collection in a read-only wrapper
            </summary>
            <param name="directedcollection">the collection to wrap</param>
        </member>
        <member name="M:C5.GuardedDirectedCollectionValue`1.Backwards">
            <summary>
            Get a collection that enumerates the wrapped collection in the opposite direction
            </summary>
            <returns>The mirrored collection</returns>
        </member>
        <member name="P:C5.GuardedDirectedCollectionValue`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.GuardedCollection`1">
             <summary>
             A read-only wrapper for an ICollection&lt;T&gt;.
             <see cref="T:C5.ICollection!1"/>
            
             <p>Suitable for wrapping hash tables, <see cref="T:C5.HashSet!1"/>
             and <see cref="T:C5.HashBag!1"/>  </p>
             </summary>
        </member>
        <member name="M:C5.GuardedCollection`1.#ctor(C5.ICollection{`0})">
            <summary>
            Wrap an ICollection&lt;T&gt; in a read-only wrapper
            </summary>
            <param name="collection">the collection to wrap</param>
        </member>
        <member name="M:C5.GuardedCollection`1.Contains(`0)">
            <summary>
            Check if an item is in the wrapped collection
            </summary>
            <param name="item">The item</param>
            <returns>True if found</returns>
        </member>
        <member name="M:C5.GuardedCollection`1.ContainsCount(`0)">
            <summary>
            Count the number of times an item appears in the wrapped collection
            </summary>
            <param name="item">The item</param>
            <returns>The number of copies</returns>
        </member>
        <member name="M:C5.GuardedCollection`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if all items in the argument is in the wrapped collection
            </summary>
            <param name="items">The items</param>
            <returns>True if so</returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Find(`0@)">
            <summary>
            Search for an item in the wrapped collection
            </summary>
            <param name="item">On entry the item to look for, on exit the equivalent item found (if any)</param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.FindOrAdd(`0@)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Update(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.UpdateOrAdd(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Remove(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.RemoveWithReturn(`0@)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.RemoveAllCopies(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.Clear">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
        </member>
        <member name="M:C5.GuardedCollection`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.Check">
            <summary>
            Check  wrapped collection for internal consistency
            </summary>
            <returns>True if check passed</returns>
        </member>
        <member name="M:C5.GuardedCollection`1.Add(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedCollection`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedCollection`1.C5#IExtensible{T}#AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="items"></param>
        </member>
        <member name="P:C5.GuardedCollection`1.IsReadOnly">
            <summary>
            (This is a read-only wrapper)
            </summary>
            <value>True</value>
        </member>
        <member name="P:C5.GuardedCollection`1.ContainsSpeed">
            <summary> </summary>
            <value>Speed of wrapped collection</value>
        </member>
        <member name="P:C5.GuardedCollection`1.AllowsDuplicates">
            <summary> </summary>
            <value>False if wrapped collection has set semantics</value>
        </member>
        <member name="P:C5.GuardedCollection`1.SyncRoot">
            <summary> </summary>
            <value>The sync root of the wrapped collection</value>
        </member>
        <member name="P:C5.GuardedCollection`1.IsEmpty">
            <summary> </summary>
            <value>True if wrapped collection is empty</value>
        </member>
        <member name="T:C5.GuardedSequenced`1">
             <summary>
             A read-only wrapper for a sequenced collection
            
             <p>This is mainly interesting as a base of other guard classes</p>
             </summary>
        </member>
        <member name="M:C5.GuardedSequenced`1.#ctor(C5.ISequenced{`0})">
            <summary>
            Wrap a sequenced collection in a read-only wrapper
            </summary>
            <param name="sorted"></param>
        </member>
        <member name="M:C5.GuardedSequenced`1.Backwards">
            <summary>
            Get a collection that enumerates the wrapped collection in the opposite direction
            </summary>
            <returns>The mirrored collection</returns>
        </member>
        <member name="P:C5.GuardedSequenced`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:C5.GuardedSorted`1">
             <summary>
             A read-only wrapper for a sorted collection
            
             <p>This is mainly interesting as a base of other guard classes</p>
             </summary>
        </member>
        <member name="M:C5.GuardedSorted`1.#ctor(C5.ISorted{`0})">
            <summary>
            Wrap a sorted collection in a read-only wrapper
            </summary>
            <param name="sorted"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.Predecessor(`0)">
            <summary>
            Find the predecessor of the item in the wrapped sorted collection
            </summary>
            <param name="item">The item</param>
            <returns>The predecessor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.Successor(`0)">
            <summary>
            Find the Successor of the item in the wrapped sorted collection
            </summary>
            <param name="item">The item</param>
            <returns>The Successor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor of the item in the wrapped sorted collection
            </summary>
            <param name="item">The item</param>
            <returns>The weak predecessor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.WeakSuccessor(`0)">
            <summary>
            Find the weak Successor of the item in the wrapped sorted collection
            </summary>
            <param name="item">The item</param>
            <returns>The weak Successor</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Run Cut on the wrapped sorted collection
            </summary>
            <param name="c"></param>
            <param name="low"></param>
            <param name="lval"></param>
            <param name="high"></param>
            <param name="hval"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeFrom(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeFromTo(`0,`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeTo(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.RangeAll">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.RemoveRangeFrom(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="low"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="low"></param>
            <param name="hi"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.RemoveRangeTo(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="hi"></param>
        </member>
        <member name="M:C5.GuardedSorted`1.FindMin">
            <summary>
            Find the minimum of the wrapped collection
            </summary>
            <returns>The minimum</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.DeleteMin">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedSorted`1.FindMax">
            <summary>
            Find the maximum of the wrapped collection
            </summary>
            <returns>The maximum</returns>
        </member>
        <member name="M:C5.GuardedSorted`1.DeleteMax">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <returns></returns>
        </member>
        <member name="P:C5.GuardedSorted`1.Comparer">
            <summary>
            The comparer object supplied at creation time for the underlying collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="T:C5.GuardedIndexedSorted`1">
             <summary>
             Read-only wrapper for indexed sorted collections
            
             <p>Suitable for wrapping TreeSet, TreeBag and SortedArray</p>
             </summary>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.#ctor(C5.IIndexedSorted{`0})">
            <summary>
            Wrap an indexed sorted collection in a read-only wrapper
            </summary>
            <param name="list">the indexed sorted collection</param>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RangeFrom(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RangeFromTo(`0,`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RangeTo(`0)">
            <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.CountFrom(`0)">
            <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.CountFromTo(`0,`0)">
            <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.CountTo(`0)">
            <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.FindAll(C5.Filter{`0})">
            <summary>
            Run FindAll on the wrapped collection with the indicated filter.
            The result will <b>not</b> be read-only.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.Map``1(C5.Mapper{`0,``0},C5.IComparer{``0})">
            <summary>
            Run Map on the wrapped collection with the indicated mapper.
            The result will <b>not</b> be read-only.
            </summary>
            <param name="m"></param>
            <param name="c">The comparer to use in the result</param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.IndexOf(`0)">
            <summary>
            Find the (first) index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.LastIndexOf(`0)">
            <summary>
            Find the last index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RemoveAt(System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedIndexedSorted`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="P:C5.GuardedIndexedSorted`1.Item(System.Int32)">
            <summary>
            
            </summary>
            <value>The i'th item of the wrapped sorted collection</value>
        </member>
        <member name="P:C5.GuardedIndexedSorted`1.Item(System.Int32,System.Int32)">
            <summary> </summary>
            <value>A directed collection of the items in the indicated interval of the wrapped collection</value>
        </member>
        <member name="T:C5.GuardedList`1">
            <summary>
            A read-only wrapper for a generic list collection
            <p>Suitable as a wrapper for LinkedList, HashedLinkedList, ArrayList and HashedArray.
            <see cref="T:C5.LinkedList!1"/>, 
            <see cref="T:C5.HashedLinkedList!1"/>, 
            <see cref="T:C5.ArrayList!1"/> or
            <see cref="T:C5.HashedArray!1"/>.
            </p>
            </summary>
        </member>
        <member name="M:C5.GuardedList`1.#ctor(C5.IList{`0})">
            <summary>
            Wrap a list in a read-only wrapper
            </summary>
            <param name="list">The list</param>
        </member>
        <member name="M:C5.GuardedList`1.Insert(System.Int32,`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="i"></param>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertFirst(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertLast(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertBefore(`0,`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <param name="target"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertAfter(`0,`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="item"></param>
            <param name="target"></param>
        </member>
        <member name="M:C5.GuardedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="i"></param>
            <param name="items"></param>
        </member>
        <member name="M:C5.GuardedList`1.FindAll(C5.Filter{`0})">
            <summary>
            Perform FindAll on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
            <param name="filter">The filter to use</param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.Map``1(C5.Mapper{`0,``0})">
            <summary>
            Perform Map on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The mapper to use.</param>
            <returns>The mapped list</returns>
        </member>
        <member name="M:C5.GuardedList`1.Map``1(C5.Mapper{`0,``0},C5.IHasher{``0})">
            <summary>
            Perform Map on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="hasher">The hasher to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:C5.GuardedList`1.Remove">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveFirst">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveLast">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.View(System.Int32,System.Int32)">
            <summary>
            Create the indicated view on the wrapped list and wrap it read-only.
            </summary>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.Slide(System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:C5.GuardedList`1.Slide(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="offset"></param>
            <param name="size"></param>
        </member>
        <member name="M:C5.GuardedList`1.Reverse">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
        </member>
        <member name="M:C5.GuardedList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="M:C5.GuardedList`1.IsSorted(C5.IComparer{`0})">
            <summary>
            Check if wrapped list is sorted
            </summary>
            <param name="c">The sorting order to use</param>
            <returns>True if sorted</returns>
        </member>
        <member name="M:C5.GuardedList`1.Sort(C5.IComparer{`0})">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:C5.GuardedList`1.Shuffle">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
        </member>
        <member name="M:C5.GuardedList`1.Shuffle(System.Random)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="rnd"></param>
        </member>
        <member name="M:C5.GuardedList`1.IndexOf(`0)">
            <summary>
            Find the (first) index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.LastIndexOf(`0)">
            <summary>
            Find the last index of an item in the wrapped collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveAt(System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="M:C5.GuardedList`1.Push(`0)">
            <summary>
            
            </summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedList`1.Pop">
            <summary>
            
            </summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedList`1.EnQueue(`0)">
            <summary>
            
            </summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            <returns>-</returns>
        </member>
        <member name="M:C5.GuardedList`1.DeQueue">
            <summary>
            
            </summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            <returns>-</returns>
        </member>
        <member name="P:C5.GuardedList`1.First">
            <summary>
            
            </summary>
            <value>The first item of the wrapped list</value>
        </member>
        <member name="P:C5.GuardedList`1.Last">
            <summary>
            
            </summary>
            <value>The last item of the wrapped list</value>
        </member>
        <member name="P:C5.GuardedList`1.FIFO">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if used as setter
            </summary>
            <value>True if wrapped list has FIFO semantics for the Add(T item) and Remove() methods</value>
        </member>
        <member name="P:C5.GuardedList`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> if used as setter
            </summary>
            <value>The i'th item of the wrapped list</value>
        </member>
        <member name="P:C5.GuardedList`1.Underlying">
            <summary>
            (This is wrong functionality)
            </summary>
            <value>The wrapped underlying list of the wrapped view </value>
        </member>
        <member name="P:C5.GuardedList`1.Offset">
            <summary>
            
            </summary>
            <value>The offset of the wrapped list as a view.</value>
        </member>
        <member name="P:C5.GuardedList`1.Item(System.Int32,System.Int32)">
            <summary> </summary>
            <value>A directed collection of the items in the indicated interval of the wrapped collection</value>
        </member>
        <member name="T:C5.GuardedDictionary`2">
             <summary>
             A read-only wrapper for a dictionary.
            
             <p>Suitable for wrapping a HashDictionary. <see cref="T:C5.HashDictionary!2"/></p>
             </summary>
        </member>
        <member name="M:C5.GuardedDictionary`2.#ctor(C5.IDictionary{`0,`1})">
            <summary>
            Wrap a dictionary in a read-only wrapper
            </summary>
            <param name="dict">the dictionary</param>
        </member>
        <member name="M:C5.GuardedDictionary`2.Add(`0,`1)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="key"></param>
            <param name="val"></param>
        </member>
        <member name="M:C5.GuardedDictionary`2.Remove(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Remove(`0,`1@)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Clear">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
        </member>
        <member name="M:C5.GuardedDictionary`2.Contains(`0)">
            <summary>
            Check if the wrapped dictionary contains a specific key
            </summary>
            <param name="key">The key</param>
            <returns>True if it does</returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Find(`0,`1@)">
            <summary>
            Search for a key in the wrapped dictionary, reporting the value if found
            </summary>
            <param name="key">The key</param>
            <param name="val">On exit: the value if found</param>
            <returns>True if found</returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Update(`0,`1)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.FindOrAdd(`0,`1@)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.UpdateOrAdd(`0,`1)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a read-only wrappper
            </summary>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:C5.GuardedDictionary`2.Check">
            <summary>
            Check the internal consistency of the wrapped dictionary
            </summary>
            <returns>True if check passed</returns>
        </member>
        <member name="P:C5.GuardedDictionary`2.Item(`0)">
            <summary>
            <exception cref="T:System.InvalidOperationException"/> since this is a
            read-only wrappper if used as a setter
            </summary>
            <value>Get the value corresponding to a key in the wrapped dictionary</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.Count">
            <summary> </summary>
            <value>The size of the wrapped dictionary</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.IsReadOnly">
            <summary>
            (This is a read-only wrapper)
            </summary>
            <value>True</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.SyncRoot">
            <summary> </summary>
            <value>The sync root of the wrapped dictionary</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.Keys">
            <summary> </summary>
            <value>The collection of keys of the wrapped dictionary</value>
        </member>
        <member name="P:C5.GuardedDictionary`2.Values">
            <summary> </summary>
            <value>The collection of values of the wrapped dictionary</value>
        </member>
        <member name="T:C5.GuardedSortedDictionary`2">
             <summary>
             A read-only wrapper for a sorted dictionary.
            
             <p>Suitable for wrapping a Dictionary. <see cref="T:C5.Dictionary!2"/></p>
             </summary>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.#ctor(C5.ISortedDictionary{`0,`1})">
            <summary>
            Wrap a sorted dictionary in a read-only wrapper
            </summary>
            <param name="sorteddict">the dictionary</param>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.Predecessor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            predecessor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.Successor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            successor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.WeakPredecessor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            weak predecessor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:C5.GuardedSortedDictionary`2.WeakSuccessor(`0)">
            <summary>
            Get the entry in the wrapped dictionary whose key is the
            weak successor of a specified key.
            </summary>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="T:C5.SortedArray`1">
            <summary>
            A collection class implementing a sorted dynamic array data structure.
            </summary>
        </member>
        <member name="M:C5.SortedArray`1.binarySearch(`0,System.Int32@)">
            <summary>
            
            </summary>
            <param name="item">The item to search for</param>
            <param name="mid">The least index, mid, for which array[mid] >= item</param>
            <returns>True if item found</returns>
        </member>
        <member name="M:C5.SortedArray`1.#ctor">
            <summary>
            Create a dynamic sorted array with a natural comparer
            </summary>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(System.Int32)">
            <summary>
            Create a dynamic sorted array with a natural comparer
            and prescribed initial capacity.
            </summary>
            <param name="capacity">The capacity</param>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(C5.IComparer{`0})">
            <summary>
            Create a dynamic sorted array with an external comparer
            </summary>
            <param name="c">The comparer</param>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(System.Int32,C5.IComparer{`0})">
            <summary>
            Create a dynamic sorted array with an external comparer
            and prescribed initial capacity.
            </summary>
            <param name="capacity">The capacity</param>
            <param name="c">The comparer</param>
        </member>
        <member name="M:C5.SortedArray`1.#ctor(System.Int32,C5.IComparer{`0},C5.IHasher{`0})">
            <summary>
            Create a dynamic sorted array with an external comparer, an external hasher
            and prescribed initial capacity.
            </summary>
            <param name="capacity">The capacity</param>
            <param name="c">The comparer</param>
            <param name="h">The hasher (compatible)</param>
        </member>
        <member name="M:C5.SortedArray`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.SortedArray`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.SortedArray`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matcing items.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.FindAll(C5.Filter{`0})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="f">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Map``1(C5.Mapper{`0,``0},C5.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="m">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)
            </summary>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is less than the minimum of this collection.)
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:System.InvalidOperationException"/> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-decreasing function from the item type to <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-decreasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is negative (if any).</param>
            <param name="lowIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is positive (if any).</param>
            <param name="highIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:C5.SortedArray`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:C5.SortedArray`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:C5.SortedArray`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.SortedArray`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:C5.SortedArray`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was added (hence not found).</returns>
        </member>
        <member name="M:C5.SortedArray`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            it is implementation dependent if this updates all equivalent copies in
            the collection or just one.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:C5.SortedArray`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemhasher to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:C5.SortedArray`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveWithReturn(`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove on input.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. 
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.SortedArray`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. 
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.SortedArray`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            Multiplicities are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.SortedArray`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found (0 or 1).</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveAllCopies(`0)">
            <summary>
            Remove all (0 or 1) items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.SortedArray`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            Only avaliable in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="M:C5.SortedArray`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:C5.SortedArray`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:C5.SortedArray`1.AddAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. Since this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <typeparam name="U">The type of items to add</typeparam>
            <param name="items">The items to add</param>
        </member>
        <member name="M:C5.SortedArray`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start.</returns>
        </member>
        <member name="M:C5.SortedArray`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:C5.SortedArray`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.SortedArray`1.C5#IDirectedEnumerable{T}#Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:C5.SortedArray`1.Features">
            <summary>
            A debugging artifact. To be removed.
            </summary>
            <value></value>
        </member>
        <member name="P:C5.SortedArray`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case).
            </summary>
            <value>Speed.Log</value>
        </member>
        <member name="P:C5.SortedArray`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>False since this collection has set semantics</value>
        </member>
        <member name="P:C5.SortedArray`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="P:C5.SortedArray`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="T:C5.SortedArray`1.Feature">
            <summary>
            A debugging artifact. To be removed.
            </summary>
        </member>
        <member name="F:C5.SortedArray`1.Feature.Standard">
            <summary>
            A debugging artifact. To be removed.
            </summary>
        </member>
        <member name="T:C5.HashedArrayList`1">
            <summary>
            A set collection based on a dynamic  array combined with a hash index
            for item to index lookup.
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.indexOf(`0)">
            <summary>
            Internal version of IndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of first occurrence</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.lastIndexOf(`0)">
            <summary>
            Internal version of LastIndexOf without modification checks.
            </summary>
            <param name="item">Item to look for</param>
            <returns>The index of last occurrence</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.insert(System.Int32,`0)">
            <summary>
            Internal version of Insert with no modification checks.
            <exception cref="T:System.ArgumentException"/> if item already in list.
            </summary>
            <param name="i">Index to insert at</param>
            <param name="item">Item to insert</param>
        </member>
        <member name="M:C5.HashedArrayList`1.removeAt(System.Int32)">
            <summary>
            Internal version of RemoveAt with no modification checks.
            </summary>
            <param name="i">Index to remove at</param>
            <returns>The removed item</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor">
            <summary>
            Create a hashed array list with the natural hasher 
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor(System.Int32)">
            <summary>
            Create a hashed array list with the natural hasher and specified capacity
            </summary>
            <param name="cap">The initial capacity</param>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor(C5.IHasher{`0})">
            <summary>
            Create a hashed array list with an external hasher
            </summary>
            <param name="hasher">The external hasher</param>
        </member>
        <member name="M:C5.HashedArrayList`1.#ctor(System.Int32,C5.IHasher{`0})">
            <summary>
            Create a hashed array list with an external hasher and specified capacity
            </summary>
            <param name="capacity">The initial capacity</param>
            <param name="hasher">The external hasher</param>
        </member>
        <member name="M:C5.HashedArrayList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt; the size of the collection.
            <exception cref="T:System.InvalidOperationException"/> if one of the items to insert is
            already in the list.
            </summary>
            <param name="i">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:C5.HashedArrayList`1.InsertBefore(`0,`0)">
            <summary>
            Insert an item right before the first occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found.
            <exception cref="T:System.InvalidOperationException"/> if the item to insert is
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target before which to insert.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.InsertAfter(`0,`0)">
            <summary>
            Insert an item right after the last(???) occurrence of some target item.
            <exception cref="T:System.ArgumentException"/> if target	is not found.
            <exception cref="T:System.InvalidOperationException"/> if the item to insert is
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="target">The target after which to insert.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the view would not fit into
            this list.
            </summary>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverst part of the list so the items are in the opposite sequence order.
            <exception cref="T:System.ArgumentException"/> if the count is negative.
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the part does not fit
            into the list.
            </summary>
            <param name="start">The index of the start of the part to reverse.</param>
            <param name="count">The size of the part to reverse.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Sort(C5.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specific sorting order.
            </summary>
            <param name="c">The comparer defining the sorting order.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemhasher) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Remove(`0)">
            <summary>
            Remove the first copy of a particular item from this collection. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            Matching items will be removed from the front. Current implementation is not optimal.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Clear">
            <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
        </member>
        <member name="M:C5.HashedArrayList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found (0 or 1).</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equal to a given one.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:C5.HashedArrayList`1.Check">
            <summary>
            Check the integrity of the internal data structures of this array list.
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="M:C5.HashedArrayList`1.Add(`0)">
            <summary>
            Add an item to end of this list if not already in list.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added</returns>
        </member>
        <member name="P:C5.HashedArrayList`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (expected).
            </summary>
            <value>Speed.Constant</value>
        </member>
        <member name="P:C5.HashedArrayList`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>False, indicating hashed array list has set semantics.</value>
        </member>
    </members>
</doc>
