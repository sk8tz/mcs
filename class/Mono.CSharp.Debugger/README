This is an implementation of the System.Diagnostics.SymbolStore.ISymbolWriter
interface which writes a dwarf debugging information file.

Unfortunately there are several major problems with this interface and I'm
unsure how to solve them:

1.) The interface contains a constructor method `Initialize' which has an
    'IntPtr' emitter argument which seems to be a pointer to the actual
    symbol writer which resides in a proprietary, undocumented DLL (I spent
    almost 3 hours browsing the ".NET Framework SDK Documentation" and
    msdn.microsoft.com - without success.

    A short test showed me that mscorlib doesn't like passing zero, this
    won't give you the system's default implementation.

    To solve this problem, I created a derived interface IMonoSymbolWriter
    which contains an additional constructor which only takes the name of
    the symbol file as argument.

        void Initialize (string filename);

2.) You seem to get an instance of a class implementing this interface by
    creating a new instance of System.Reflection.Emit.ModuleBuilder (with the
    `bool createSymbolFile' argument) and then calling GetSymWriter() on
    the returned object.

    So far so good, but how does this method find out which symbol writer
    to use ?

3.) According to the documentation, some of the methods of
    System.Reflection.Emit.ILGenerator and System.Reflection.Emit.LocalBuilder
    seem to use the symbol writer to emit symbol debugging information.

    But again, how do these objects get the symbol writer ?

Currently, there are two ways to use this assembly:

a.) Fix the problems outlined above and dynamically load this assembly
    (Mono.CSharp.Debugger.dll) when a new symbol writer is created.

b.) Reference this assembly in your application and manually create the
    symbol writer using the constructor.

