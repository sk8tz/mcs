%{

using System;
using System.Text;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Exceptions;
using Microsoft.Build.Framework;

/*

Pseudo formal syntax for .NET 4.0 expression:

Condition = Expression
Include = Expression*

 Expression
	BooleanLiteral
		TrueLiteral
		FalseLiteral
	BinaryExpression
		Expression "==" Expression
		Expression "!=" Expression
		Expression ">" Expression
		Expression ">=" Expression
		Expression "<" Expression
		Expression "<=" Expression
		Expression "And" Expression
		Expression "Or" Expression
	UnaryExpression
		"!" Expression
	PropertyExpression
		"$(" PropertyApplication ")"
	ItemExpression
		"@(" ItemApplication ")"
	MetadataBatchingExpression
		"%(" MetadataBatchingApplication ")"
  StringLiteralOrFunction
		StringLiteralOrFunctionName ( "(" FunctionArguments ")" )?

.NET error messages are so detailed which is something like "you forgot '(' after '$' ?" - so
it is likely that the MS tokenizer is hand-written.

*/

namespace Microsoft.Build.Internal
{
	class ExpressionParser
	{
		const int yacc_verbose_flag = 0;

		object debug_obj = yacc_verbose_flag == 0 ? null : new yydebug.yyDebugSimple ();
		
		public ExpressionList Parse (string source, ExpressionValidationType validationType)
		{
			var tokenizer = new ExpressionTokenizer (source, validationType);
			return (ExpressionList) yyparse (tokenizer, debug_obj);
		}
		
		BinaryExpression Binary (Operator op, object left, object right)
		{
			return new BinaryExpression () { Operator = op, Left = (Expression) left, Right = (Expression) right, Location = (ILocation) left };
		}
%}

%token TRUE_LITERAL
%token FALSE_LITERAL
%token STRING_LITERAL
%token EQ // ==
%token NE // !=
%token GT // >
%token GE // >=
%token LT // <
%token LE // <=
%token AND // AND
%token OR // OR
%token NOT //!
%token DOT //.
%token COMMA //,
%token PROP_OPEN // $(
%token ITEM_OPEN // @(
%token METADATA_OPEN // %(
%token PAREN_OPEN // (
%token PAREN_CLOSE // )
%token BRACE_OPEN // [
%token BRACE_CLOSE // ]
%token COLON2 // ::
%token ARROW // ->
%token NAME
%token ERROR

%start ExpressionList

%%

ExpressionList
	: /* empty */
	  { $$ = new ExpressionList (); }
	| ExpressionList Expression
	  { $$ = ((ExpressionList) $1).Add ((Expression) $2); }
	;

Expression
	: BinaryExpression
	;

BinaryExpression
	: PrimaryExpression
	| PrimaryExpression EQ PrimaryExpression
	  { $$ = Binary (Operator.EQ, $1, $3); }
	| PrimaryExpression NE PrimaryExpression
	  { $$ = Binary (Operator.NE, $1, $3); }
	| PrimaryExpression GT PrimaryExpression
	  { $$ = Binary (Operator.GT, $1, $3); }
	| PrimaryExpression GE PrimaryExpression
	  { $$ = Binary (Operator.GE, $1, $3); }
	| PrimaryExpression LT PrimaryExpression
	  { $$ = Binary (Operator.LT, $1, $3); }
	| PrimaryExpression LE PrimaryExpression
	  { $$ = Binary (Operator.LE, $1, $3); }
	| PrimaryExpression AND PrimaryExpression
	  { $$ = Binary (Operator.And, $1, $3); }
	| PrimaryExpression OR PrimaryExpression
	  { $$ = Binary (Operator.Or, $1, $3); }
	;

PrimaryExpression
	: BooleanLiteral
	| StringLiteral
	| UnaryExpression
	| PropertyAccessExpression
	| ItemAccessExpression
	| MetadataAccessExpression
	| RawStringLiteralOrFunction
	| ParenthesizedExpression
	
BooleanLiteral
	: TRUE_LITERAL
	  { $$ = new BooleanLiteral () { Value = true, Location = (ILocation) $1 }; }
	| FALSE_LITERAL
	  { $$ = new BooleanLiteral () { Value = false, Location = (ILocation) $1 }; }
	;

UnaryExpression
	: NOT Expression
	  { $$ = new NotExpression () { Negated = (Expression) $2, Location = (ILocation) $1 }; }
	;

PropertyAccessExpression
	: PROP_OPEN PropertyAccess PAREN_CLOSE
	  { $$ = new PropertyAccessExpression () { Access = (PropertyAccess) $2, Location = (ILocation) $1 }; }
	;

PropertyAccess
	: NAME
	  { $$ = new PropertyAccess () { Name = (NameToken) $1, TargetType = PropertyTargetType.Object, Location = (NameToken) $1 }; }
	| Expression DOT NAME
	  { $$ = new PropertyAccess () { Name = (NameToken) $3, Target = (Expression) $1, TargetType = PropertyTargetType.Object, Location = (ILocation) $1 }; }
	| BRACE_OPEN NAME BRACE_CLOSE COLON2 NAME
	  { $$ = new PropertyAccess () { Name = (NameToken) $5, Target = (Expression) $2, TargetType = PropertyTargetType.Type, Location = (ILocation) $1 }; }
	| BRACE_OPEN NAME BRACE_CLOSE COLON2 NAME PAREN_OPEN FunctionCallArguments PAREN_CLOSE
	  { $$ = new PropertyAccess () { Name = (NameToken) $5, Target = (Expression) $2, TargetType = PropertyTargetType.Type, Arguments = (ExpressionList) $7, Location = (ILocation) $1 }; }
	;

ItemAccessExpression
	: ITEM_OPEN ItemApplication PAREN_CLOSE
	  { $$ = new ItemAccessExpression () { Application = (ItemApplication) $2, Location = (ILocation) $1 }; }
	;

// looking a bit messy, but gives different location
ItemApplication
	: NAME
	| NAME ARROW ExpressionList
	  { $$ = new ItemApplication () { Name = (NameToken) $1, Expressions = (ExpressionList) $3, Location = (ILocation) $1 }; }
	;

MetadataAccessExpression
	: METADATA_OPEN MetadataAccess PAREN_CLOSE
	  { $$ = new MetadataAccessExpression () { Access = (MetadataAccess) $2, Location = (ILocation) $1 }; }
	;

// looking a bit messy, but gives different location
MetadataAccess
	: NAME
	  { $$ = new MetadataAccess () { Metadata = (NameToken) $1, Location = (ILocation) $1 }; }
	| NAME DOT NAME
	  { $$ = new MetadataAccess () { Item = (NameToken) $1, Metadata = (NameToken) $3, Location = (ILocation) $1 }; }
	;

StringLiteral
	: STRING_LITERAL
	  { $$ = new StringLiteral () { Value = (NameToken) $1, Location = (ILocation) $1 }; }
	;

RawStringLiteralOrFunction
	: NAME
	  { $$ = new RawStringLiteral () { Value = (NameToken) $1, Location = (ILocation) $1 }; }
	| NAME PAREN_OPEN PAREN_CLOSE
	  { $$ = new FunctionCallExpression () { Name = (NameToken) $1, Arguments = new ExpressionList (), Location = (ILocation) $1 }; }
	| NAME PAREN_OPEN FunctionCallArguments PAREN_CLOSE
	  { $$ = new FunctionCallExpression () { Name = (NameToken) $1, Arguments = (ExpressionList) $3, Location = (ILocation) $1 }; }
	;

FunctionCallArguments
	: Expression
	  { $$ = new ExpressionList (); }
	| FunctionCallArguments COMMA Expression
	  { $$ = ((ExpressionList) $1).Add ((Expression) $3); }
	;

ParenthesizedExpression
	: PAREN_OPEN Expression PAREN_CLOSE
	  { $$ = (Expression) $2; }
	;

%%

	}
