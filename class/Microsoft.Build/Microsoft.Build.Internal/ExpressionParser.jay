%{

using System;
using System.Text;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Exceptions;
using Microsoft.Build.Framework;

/*

Pseudo formal syntax for .NET 4.0 expression:

Condition = Expression
Include = Expression*

 Expression
	BooleanLiteral
		TrueLiteral
		FalseLiteral
	BinaryExpression
		Expression "==" Expression
		Expression "!=" Expression
		Expression ">" Expression
		Expression ">=" Expression
		Expression "<" Expression
		Expression "<=" Expression
		Expression "And" Expression
		Expression "Or" Expression
	UnaryExpression
		"!" Expression
	PropertyExpression
		"$(" PropertyApplication ")"
	ItemExpression
		"@(" ItemApplication ")"
	MetadataBatchingExpression
		"%(" MetadataBatchingApplication ")"
  StringLiteralOrFunction
		StringLiteralOrFunctionName ( "(" FunctionArguments ")" )?

.NET error messages are so detailed which is something like "you forgot '(' after '$' ?" - so
it is likely that the MS tokenizer is hand-written.

*/

namespace Microsoft.Build.Internal
{
	class ExpressionParser
	{
		const int yacc_verbose_flag = 1;

		object debug_obj = yacc_verbose_flag == 0 ? null : new yydebug.yyDebugSimple ();
		
		public ExpressionList Parse (string source, ExpressionValidationType validationType)
		{
			var tokenizer = new ExpressionTokenizer (source, validationType);
			return (ExpressionList) yyparse (tokenizer, debug_obj);
		}
%}

%token TRUE_LITERAL
%token FALSE_LITERAL
%token EQ // ==
%token NE // !=
%token GT // >
%token GE // >=
%token LT // <
%token LE // <=
%token AND // AND
%token OR // OR
%token NOT //!
%token DOT //.
%token COMMA //,
%token APOS // '
%token QUOT // "
%token PROP_OPEN // $(
%token ITEM_OPEN // @(
%token METADATA_OPEN // %(
%token PAREN_OPEN // (
%token PAREN_CLOSE // )
%token COLON2 // ::
%token ARROW // ->
%token NAME
%token ERROR

%start ExpressionList

%%

ExpressionList
	: /* empty */
	  { $$ = new ExpressionList (); }
	| ExpressionList Expression
	  { $$ = ((ExpressionList) $1).Add ((Expression) $2); }
	;

ExpressionExceptStringLiteralList
	: /* empty */
	  { $$ = new ExpressionList (); }
	| ExpressionExceptStringLiteralList ExpressionExceptStringLiteral
	  { $$ = ((ExpressionList) $1).Add ((Expression) $2); }
	;

Expression
	: ExpressionExceptStringLiteral
	| StringLiteralExpression
	;

ExpressionExceptStringLiteral
	: BooleanLiteral
	| BinaryExpression
	| UnaryExpression
	| PropertyAccessExpression
	| ItemAccessExpression
	| MetadataAccessExpression
	| RawStringLiteralOrFunction
	| ParenthesizedExpression
	;

BooleanLiteral
	: TRUE_LITERAL
	  { $$ = new BooleanLiteral () { Value = true, Location = (ILocation) $1 }; }
	| FALSE_LITERAL
	  { $$ = new BooleanLiteral () { Value = false, Location = (ILocation) $1 }; }
	;

BinaryExpression
	: Expression EQ Expression
	| Expression NE Expression
	| Expression GT Expression
	| Expression GE Expression
	| Expression LT Expression
	| Expression LE Expression
	| Expression AND Expression
	| Expression OR Expression
	;

UnaryExpression
	: NOT Expression
	  { $$ = new NotExpression () { Negated = (Expression) $2, Location = (ILocation) $1 }; }
	;

PropertyAccessExpression
	: PROP_OPEN PropertyAccess PAREN_CLOSE
	  { $$ = new PropertyAccessExpression () { Access = (PropertyAccess) $2, Location = (ILocation) $1 }; }
	;

PropertyAccess
	: NAME
	  { $$ = new PropertyAccess () { Name = (NameToken) $1, Location = (NameToken) $1 }; }
	| Expression DOT NAME
	  { $$ = new PropertyAccess () { Name = (NameToken) $3, Target = (Expression) $1, Location = (ILocation) $1 }; }
	;

ItemAccessExpression
	: ITEM_OPEN ItemApplication PAREN_CLOSE
	  { $$ = new ItemAccessExpression () { Application = (ItemApplication) $2, Location = (ILocation) $1 }; }
	;

// looking a bit messy, but gives different location
ItemApplication
	: NAME
	| NAME ARROW ExpressionList
	  { $$ = new ItemApplication () { Name = (NameToken) $1, Expressions = (ExpressionList) $3, Location = (ILocation) $1 }; }
	;

MetadataAccessExpression
	: METADATA_OPEN MetadataAccess PAREN_CLOSE
	  { $$ = new MetadataAccessExpression () { Access = (MetadataAccess) $2, Location = (ILocation) $1 }; }
	;

// looking a bit messy, but gives different location
MetadataAccess
	: NAME
	  { $$ = new MetadataAccess () { Metadata = (NameToken) $1, Location = (ILocation) $1 }; }
	| NAME DOT NAME
	  { $$ = new MetadataAccess () { Item = (NameToken) $1, Metadata = (NameToken) $3, Location = (ILocation) $1 }; }
	;

StringLiteralExpression
	: APOS ExpressionExceptStringLiteralList APOS
	  { $$ = new StringLiteralExpression () { Contents = (ExpressionList) $2, Location = (ILocation) $1 }; }
	| QUOT ExpressionExceptStringLiteralList QUOT
	  { $$ = new StringLiteralExpression () { Contents = (ExpressionList) $2, Location = (ILocation) $1 }; }
	;

RawStringLiteralOrFunction
	: NAME
	  { $$ = new RawStringLiteral () { Value = (NameToken) $1, Location = (ILocation) $1 }; }
	| NAME PAREN_OPEN PAREN_CLOSE
	  { $$ = new FunctionCallExpression () { Name = (NameToken) $1, Arguments = new ExpressionList (), Location = (ILocation) $1 }; }
	| NAME PAREN_OPEN FunctionCallArguments PAREN_CLOSE
	  { $$ = new FunctionCallExpression () { Name = (NameToken) $1, Arguments = (ExpressionList) $3, Location = (ILocation) $1 }; }
	;

FunctionCallArguments
	: Expression
	  { $$ = new ExpressionList (); }
	| FunctionCallArguments COMMA Expression
	  { $$ = ((ExpressionList) $1).Add ((Expression) $3); }
	;

ParenthesizedExpression
	: PAREN_OPEN Expression PAREN_CLOSE
	  { $$ = (Expression) $2; }
	;

%%

	}
