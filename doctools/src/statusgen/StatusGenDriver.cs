using System;
using System.IO;
using System.Reflection;
using System.Xml;
using Mono.Doc.Utils;

/* TODO: write MonoTODO percentage calc, etc. (?)
 * TODO: merge old class.xml file */
namespace Mono.Doc.StatusGen
{
	/// <summary>
	/// Generates and updates assembly status XML documents.
	/// They contain information like test suite status, maintainers, et cetera.
	/// </summary>
	class StatusGenDriver
	{
		private const string DEFAULT_MAINTAINER = "mono-list@ximian.com";
		private const string BACKUP_EXT         = ".old";

		private Assembly    assembly     = null;
		private Assembly    diffAssembly = null;
		private XmlDocument doc          = null;


		public StatusGenDriver(string assemblyName) : this (assemblyName, null) {}


		public StatusGenDriver(string assemblyName, string diffAssemblyName)
		{
			assembly = AssemblyLoader.Load(assemblyName);

			if (diffAssemblyName != null) {
				diffAssembly = AssemblyLoader.Load(diffAssemblyName);
			}
		}


		public void Create(string fileName)
		{
			doc = new XmlDocument();

			// XML declaration
			doc.AppendChild(doc.CreateXmlDeclaration("1.0", null, null));

			// <assembly>
			XmlElement root = doc.CreateElement("assembly");
			doc.AppendChild(root);

			// assembly name
			root.SetAttribute("name", assembly.GetName().Name);

			// <types>
			XmlElement types = doc.CreateElement("types");
			root.AppendChild(types);

			// <type>
			Type[] assemblyTypes = assembly.GetTypes();
			foreach (Type t in assemblyTypes) {
				if (t.IsPublic) {
					types.AppendChild(GetElementForType(t));
				}
			}

			// generate diff
			if (diffAssembly != null) {
				XmlElement missingTypes = GetMissingTypesElement(assembly, diffAssembly);
				
				if (missingTypes.ChildNodes.Count > 0) {
					root.AppendChild(doc.CreateComment(" missing-types is autogenerated. DO NOT MODIFY. "));
					root.AppendChild(missingTypes);
				}
			}

			// save this stub
			try {
				doc.Save(new StreamWriter(fileName));
			} catch (Exception e) {
				throw new ApplicationException("Can't write to '" + fileName + ".", e);
			}
		}


		public void Update(string fileName)
		{
			Update(fileName, true, true, true);
		}


		public void Update(string fileName, bool add, bool prune, bool createBackup)
		{
			bool dirty = false;

			try {
				doc = new XmlDocument();
				doc.Load(fileName);
			} catch (Exception e) {
				throw new ApplicationException("Problem loading '" + fileName + "'.", e);
			}

			Type[] assemblyTypes = assembly.GetTypes();
			XmlNode typesNode    = doc.SelectSingleNode("/assembly/types");

			if (typesNode == null) {
				throw new ApplicationException(fileName + " is not a valid XML status document.");
			}

			// types missing in XML
			foreach (Type t in assemblyTypes) {
				if (t.IsPublic) {
					string name  = t.FullName;
					string path  = "type[@name='" + name + "']";
					XmlNode node = typesNode.SelectSingleNode(path);
					
					if (node == null) {
						Console.Write("Missing type " + name + ".");
						if (add) {
							Console.WriteLine("  Adding stub.");
							typesNode.AppendChild(GetElementForType(t));
							dirty = true;
						} else {
							Console.WriteLine();
						}
					}
				}
			}

			// extra types in XML
			XmlNodeList xmlTypes = typesNode.SelectNodes("type");

			foreach (XmlNode type in xmlTypes) {
				string name = type.Attributes["name"].Value;

				if (assembly.GetType(name, false) == null) {
					Console.Write("Extra type " + name + ".");
					if (prune) {
						Console.WriteLine("  Pruning.");
						typesNode.RemoveChild(type);
						dirty = true;
					} else {
						Console.WriteLine();
					}
				}
			}

			// generate diff
			if (diffAssembly != null) {
				XmlElement newMissingTypes = GetMissingTypesElement(assembly, diffAssembly);
				XmlNode    oldMissingTypes = doc.SelectSingleNode("/assembly/missing-types");

				// FIXME: this will dirty and update even if the lists are exactly the same.
				if (newMissingTypes.ChildNodes.Count > 0) {
					if (oldMissingTypes != null) {
						oldMissingTypes.ParentNode.ReplaceChild(oldMissingTypes, newMissingTypes);
					} else {
						doc.DocumentElement.AppendChild(newMissingTypes);
					}

					dirty = true;
				}
			}

			// update the file if necessary
			if (dirty) {
				try {
					if (createBackup) {
						File.Move(fileName, fileName + BACKUP_EXT);
					}

					doc.Save(fileName);
				} catch (Exception e) {
					throw new ApplicationException("Could not update '" + fileName + "'.", e);
				}
			}
		}
		

		public static void Main(string[] args)
		{
			string assemblyName     = null;
			string diffAssemblyName = null;
			string createFile       = null;
			string updateFile       = null;
			bool   add              = true;
			bool   prune            = true;
			bool   backup           = true;

			if (args.Length < 3) {
				Usage();
				return;
			}

			for (int i = 0; i < args.Length; i++) {
				string arg = args[i];
				
				if (arg.StartsWith("-")) {
					switch (arg) {
						case "--about":
							Usage();
							return;
						case "-c":
						case "--create":
							if ((i + 1) >= args.Length) {
								Usage();
								return;
							}

							createFile = args[++i];
							break;
						case "-u":
						case "--update":
							if ((i + 1) >= args.Length) {
								Usage();
								return;
							}

							updateFile = args[++i];
							break;
						case "-d":
						case "--diff":
							if ((i + 1) >= args.Length) {
								Usage();
								return;
							}

							diffAssemblyName = args[++i];
							break;
						case "--noadd":
							add = false;
							break;
						case "--noprune":
							prune = false;
							break;
						case "--nobackup":
							backup = false;
							break;
						default:
							Usage();
							return;
					}
				} else {
					assemblyName = arg;
					break;
				}
			}


			try {
				StatusGenDriver driver = new StatusGenDriver(assemblyName, diffAssemblyName);

				if (createFile != null) {
					driver.Create(createFile);
				} else if (updateFile != null) {
					driver.Update(updateFile, add, prune, backup);
				} else {
					Usage();
				}
			} catch (ApplicationException ae) {
				Usage();
				Console.WriteLine("Error: {0}", ae.Message);
			}
		}

		
		# region Private Methods
		private XmlElement GetMissingTypesElement(Assembly assem, Assembly diffAssem)
		{
			XmlElement missingTypes = doc.CreateElement("missing-types");

			Type[] diffTypes = diffAssem.GetTypes();
			foreach (Type t in diffTypes) {
				if (t.IsPublic) {
					if (assem.GetType(t.FullName, false) == null) {
						XmlElement typeElem = doc.CreateElement("type");
						typeElem.SetAttribute("name", t.FullName);
						missingTypes.AppendChild(typeElem);
					}
				}
			}

			return missingTypes;
		}


		private XmlElement GetElementForType(Type t)
		{
			XmlElement type = doc.CreateElement("type");

			// name
			type.SetAttribute("name", t.FullName);

			// kind
			type.SetAttribute("kind", GetKind(t));

			// item: maintainer
			type.AppendChild(CreateItem("maintainer", DEFAULT_MAINTAINER));

			// item: test-case
			type.AppendChild(CreateItem("test-case", "no"));

			// item: implementation
			type.AppendChild(CreateItem("implementation", "no"));

			return type;
		}


		private XmlElement CreateItem(string key, string value)
		{
			XmlElement item = doc.CreateElement("item");
			item.SetAttribute("key", key);
			item.SetAttribute("value", value);

			return item;
		}


		private static string GetKind(Type t)
		{
			if (t.IsClass)
				return "class";
			
			if (t.IsInterface)
				return "interface";
			
			if (t.IsValueType) {
				if (t.BaseType.FullName == "System.Enum")
					return "enum";
				else
					return "struct";
			}
			
			else
				return "UNKNOWN";
		}
		#endregion


		static void Usage()
		{
			Console.WriteLine(
				"Mono Assembly Status Generator\n" +
				"statusgen [options] ASSEMBLYNAME\n" +
				"   ASSEMBLYNAME can be either or an assembly file or a string in the\n" +
				"   format 'int:ASSEMBLY', which will attempt to load ASSEMBLY from\n" +
				"   the current AppDomain.\n\n" +
				"   --about            Display this message.\n" +
				"   -c --create FILE   Create stub status XML for ASSEMBLYNAME in FILE.\n" +
				"   -u --update FILE   Update the assembly status XML in FILE by\n" +
				"                      scanning ASSEMBLYNAME and adding or deleting\n" +
				"                      types from the XML when necessary.\n" +
				"   -d --diff ASMNAME  Generate a list of missing public types by comparing\n" +
				"                      with the assembly specified in ASMNAME and insert it\n" +
				"                      in the status XML.\n" +
				"   --noadd            When updating, do not add missing types to XML.\n" +
				"   --noprune          When updating, do not remove irrelevant types from XML.\n" +
				"   --nobackup         When updating, do not create a backup file.\n" +
				"\n"
				);
		}
	}
}
